# Story 2.4 — Adjust Assumptions Implementation Plan

## Overview

Implement an Assumptions Panel UI that allows users to explore "what-if" scenarios by adjusting projection parameters (expected return, inflation rate, retirement age). Changes are ephemeral (session-only) and trigger real-time projection recalculation via the existing POST `/api/projections/calculate` endpoint.

## Current State Analysis

### What Exists (Complete)
- **Projection Engine**: `runProjection()` in [engine.ts](src/lib/projections/engine.ts:98-223) handles year-by-year calculations
- **API Support**: POST endpoint at [route.ts:177-209](src/app/api/projections/calculate/route.ts#L177-L209) accepts optional overrides
- **Validation Schemas**: [projections.ts:20-81](src/lib/validation/projections.ts#L20-L81) defines valid ranges
- **Default Values**: [assumptions.ts:7-45](src/lib/projections/assumptions.ts#L7-L45) defines DEFAULT_RETURN_RATES, DEFAULT_INFLATION_RATE, etc.
- **UI Components**: Card, Button, Collapsible, Dialog, Input all available in `src/components/ui/`

### What's Missing (This Story)
- **Slider Component**: No `@radix-ui/react-slider` installed, no slider component exists
- **Assumptions Panel**: No UI for adjusting assumptions
- **Client-Side State**: Plans page is server-only; needs client component wrapper for ephemeral state
- **Real-Time Recalculation**: No debounced API call pattern for live updates

### Key Discoveries
- Plans page ([page.tsx](src/app/plans/page.tsx)) is entirely server-rendered with no client interactivity
- API already returns `inputs` echo showing applied values ([route.ts:126-140](src/app/api/projections/calculate/route.ts#L126-L140))
- Validation allows: expectedReturn 0-20%, inflationRate 0-15%, retirementAge varies by user
- Story scope requires: expectedReturn 1-10%, inflationRate 1-8%, retirementAge > currentAge

## Desired End State

Users see an "Assumptions" panel on the plans page with:
1. Three sliders: Expected Return, Inflation Rate, Retirement Age
2. Current value displayed next to each slider
3. "Reset to Defaults" button that restores original values
4. Real-time chart/summary updates when sliders change (≤2 second latency)
5. Visual indicator showing which values differ from defaults

**Verification**:
- Adjusting any slider triggers API call and chart updates within 2 seconds
- Navigating away and returning resets assumptions to defaults
- Values cannot exceed validation bounds (enforced by slider min/max)

## What We're NOT Doing

- Persisting assumption changes to database
- Creating named scenarios (Epic 3 scope)
- Running Monte Carlo/probabilistic simulations
- Editing core financial data (assets, income, debts)
- Adding AI narrative generation (future feature)

## Implementation Approach

Convert the plans page to a server/client hybrid pattern:
1. Server component fetches data and calculates initial projection
2. Client component manages ephemeral assumptions state
3. Slider changes trigger debounced POST to `/api/projections/calculate`
4. Response updates projection display in real-time

## Phase 1: Add Slider Component

### Overview
Install Radix UI Slider and create a styled Slider component matching the existing design system.

### Changes Required:

#### 1. Install Dependency
```bash
npm install @radix-ui/react-slider
```

#### 2. Create Slider Component
**File**: `src/components/ui/slider.tsx`

```tsx
'use client';

import * as React from 'react';
import * as SliderPrimitive from '@radix-ui/react-slider';
import { cn } from '@/lib/utils';

interface SliderProps
  extends React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root> {
  formatValue?: (value: number) => string;
  showValue?: boolean;
}

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  SliderProps
>(({ className, formatValue, showValue = true, ...props }, ref) => (
  <div className="relative flex items-center gap-4">
    <SliderPrimitive.Root
      ref={ref}
      className={cn(
        'relative flex w-full touch-none select-none items-center',
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-muted">
        <SliderPrimitive.Range className="absolute h-full bg-primary" />
      </SliderPrimitive.Track>
      <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
    </SliderPrimitive.Root>
    {showValue && props.value !== undefined && (
      <span className="min-w-[4rem] text-right text-sm font-medium tabular-nums">
        {formatValue ? formatValue(props.value[0]) : props.value[0]}
      </span>
    )}
  </div>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };
```

### Success Criteria:

#### Automated Verification:
- [x] Package installed: `npm ls @radix-ui/react-slider`
- [x] Type checking passes: `npm run typecheck`
- [x] Build succeeds: `npm run build`

#### Manual Verification:
- [ ] Slider component renders correctly in Storybook or test page
- [ ] Slider thumb is draggable and responds to keyboard input
- [ ] Value display updates as slider moves

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 2.

---

## Phase 2: Create AssumptionsPanel Component

### Overview
Build the assumptions panel UI with three sliders matching story requirements.

### Changes Required:

#### 1. Create AssumptionsPanel Component
**File**: `src/components/projections/AssumptionsPanel.tsx`

```tsx
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Slider } from '@/components/ui/slider';
import { RotateCcw } from 'lucide-react';
import { cn } from '@/lib/utils';

export interface Assumptions {
  expectedReturn: number;
  inflationRate: number;
  retirementAge: number;
}

interface AssumptionsPanelProps {
  assumptions: Assumptions;
  defaultAssumptions: Assumptions;
  currentAge: number;
  onChange: (assumptions: Assumptions) => void;
  onReset: () => void;
  disabled?: boolean;
}

export function AssumptionsPanel({
  assumptions,
  defaultAssumptions,
  currentAge,
  onChange,
  onReset,
  disabled = false,
}: AssumptionsPanelProps) {
  const hasChanges =
    assumptions.expectedReturn !== defaultAssumptions.expectedReturn ||
    assumptions.inflationRate !== defaultAssumptions.inflationRate ||
    assumptions.retirementAge !== defaultAssumptions.retirementAge;

  const formatPercent = (value: number) => `${(value * 100).toFixed(1)}%`;
  const formatAge = (value: number) => `Age ${value}`;

  const isModified = (key: keyof Assumptions) =>
    assumptions[key] !== defaultAssumptions[key];

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between pb-2">
        <CardTitle className="text-base font-medium">Assumptions</CardTitle>
        {hasChanges && (
          <Button
            variant="ghost"
            size="sm"
            onClick={onReset}
            disabled={disabled}
            className="h-8 px-2 text-muted-foreground"
          >
            <RotateCcw className="h-4 w-4 mr-1" />
            Reset
          </Button>
        )}
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Expected Return */}
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <label className="text-sm font-medium">
              Expected Return
              {isModified('expectedReturn') && (
                <span className="ml-2 text-xs text-muted-foreground">(modified)</span>
              )}
            </label>
          </div>
          <Slider
            value={[assumptions.expectedReturn]}
            min={0.01}
            max={0.10}
            step={0.005}
            disabled={disabled}
            formatValue={formatPercent}
            onValueChange={([value]) =>
              onChange({ ...assumptions, expectedReturn: value })
            }
          />
          <p className="text-xs text-muted-foreground">
            Default: {formatPercent(defaultAssumptions.expectedReturn)}
          </p>
        </div>

        {/* Inflation Rate */}
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <label className="text-sm font-medium">
              Inflation Rate
              {isModified('inflationRate') && (
                <span className="ml-2 text-xs text-muted-foreground">(modified)</span>
              )}
            </label>
          </div>
          <Slider
            value={[assumptions.inflationRate]}
            min={0.01}
            max={0.08}
            step={0.005}
            disabled={disabled}
            formatValue={formatPercent}
            onValueChange={([value]) =>
              onChange({ ...assumptions, inflationRate: value })
            }
          />
          <p className="text-xs text-muted-foreground">
            Default: {formatPercent(defaultAssumptions.inflationRate)}
          </p>
        </div>

        {/* Retirement Age */}
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <label className="text-sm font-medium">
              Retirement Age
              {isModified('retirementAge') && (
                <span className="ml-2 text-xs text-muted-foreground">(modified)</span>
              )}
            </label>
          </div>
          <Slider
            value={[assumptions.retirementAge]}
            min={currentAge + 1}
            max={80}
            step={1}
            disabled={disabled}
            formatValue={formatAge}
            onValueChange={([value]) =>
              onChange({ ...assumptions, retirementAge: value })
            }
          />
          <p className="text-xs text-muted-foreground">
            Default: {formatAge(defaultAssumptions.retirementAge)}
          </p>
        </div>
      </CardContent>
    </Card>
  );
}
```

#### 2. Export from Index
**File**: `src/components/projections/index.ts`
Add export:
```typescript
export { AssumptionsPanel, type Assumptions } from './AssumptionsPanel';
```

### Success Criteria:

#### Automated Verification:
- [x] Type checking passes: `npm run typecheck`
- [x] Build succeeds: `npm run build`
- [x] Lint passes: `npm run lint`

#### Manual Verification:
- [ ] Panel renders with three sliders
- [ ] Sliders move smoothly between min/max values
- [ ] Reset button appears only when values are modified
- [ ] Modified indicators show correctly

**Implementation Note**: After completing this phase, pause for manual verification before Phase 3.

---

## Phase 3: Convert Plans Page to Client/Server Hybrid

### Overview
Refactor the plans page to separate server data fetching from client-side state management.

### Changes Required:

#### 1. Create Plans Client Component
**File**: `src/app/plans/plans-client.tsx`

```tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
} from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { CheckCircle2, AlertTriangle, XCircle, Loader2 } from 'lucide-react';
import { ProjectionChart, ProjectionTable, AssumptionsPanel, type Assumptions } from '@/components/projections';
import { getRetirementStatus, type RetirementStatus } from '@/lib/projections';
import type { ProjectionResult } from '@/lib/projections/types';
import { cn } from '@/lib/utils';

interface PlansClientProps {
  initialProjection: ProjectionResult;
  currentAge: number;
  defaultAssumptions: Assumptions;
  inflationRate: number;
}

export function PlansClient({
  initialProjection,
  currentAge,
  defaultAssumptions,
  inflationRate,
}: PlansClientProps) {
  const [assumptions, setAssumptions] = useState<Assumptions>(defaultAssumptions);
  const [projection, setProjection] = useState<ProjectionResult>(initialProjection);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Debounced recalculation
  useEffect(() => {
    // Skip if assumptions match defaults (initial state)
    const hasChanges =
      assumptions.expectedReturn !== defaultAssumptions.expectedReturn ||
      assumptions.inflationRate !== defaultAssumptions.inflationRate ||
      assumptions.retirementAge !== defaultAssumptions.retirementAge;

    if (!hasChanges) {
      setProjection(initialProjection);
      return;
    }

    const controller = new AbortController();
    const timer = setTimeout(async () => {
      setIsLoading(true);
      setError(null);

      try {
        const response = await fetch('/api/projections/calculate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            expectedReturn: assumptions.expectedReturn,
            inflationRate: assumptions.inflationRate,
            // Note: retirementAge is not supported by API - will need backend update
          }),
          signal: controller.signal,
        });

        if (!response.ok) {
          throw new Error('Failed to calculate projection');
        }

        const data = await response.json();
        setProjection(data.projection);
      } catch (err) {
        if (err instanceof Error && err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setIsLoading(false);
      }
    }, 300); // 300ms debounce

    return () => {
      clearTimeout(timer);
      controller.abort();
    };
  }, [assumptions, defaultAssumptions, initialProjection]);

  const handleReset = useCallback(() => {
    setAssumptions(defaultAssumptions);
  }, [defaultAssumptions]);

  // Calculate status from current projection
  const statusResult = getRetirementStatus(projection.summary, currentAge);

  // Format helpers
  const formatCurrency = (value: number) => {
    if (value >= 1_000_000) return `$${(value / 1_000_000).toFixed(1)}M`;
    if (value >= 1_000) return `$${Math.round(value / 1_000)}K`;
    return `$${Math.round(value)}`;
  };

  const StatusIcon = ({ status }: { status: RetirementStatus }) => {
    switch (status) {
      case 'on-track':
        return <CheckCircle2 className="h-6 w-6" />;
      case 'needs-adjustment':
        return <AlertTriangle className="h-6 w-6" />;
      case 'at-risk':
        return <XCircle className="h-6 w-6" />;
    }
  };

  const shortfallAge =
    projection.summary.yearsUntilDepletion !== null
      ? currentAge + projection.summary.yearsUntilDepletion
      : undefined;

  return (
    <div className="space-y-6">
      {/* Header */}
      <div>
        <h1 className="text-2xl font-bold tracking-tight text-foreground">
          Your Retirement Projection
        </h1>
        <p className="text-muted-foreground">
          Based on your financial information, here&apos;s where you stand.
        </p>
      </div>

      {/* Status Badge */}
      <div className="flex items-center gap-4">
        <div
          className={cn(
            'inline-flex items-center gap-2 rounded-full px-4 py-2 text-lg font-semibold',
            statusResult.status === 'on-track' && 'bg-success/10 text-success',
            statusResult.status === 'needs-adjustment' && 'bg-warning/10 text-warning',
            statusResult.status === 'at-risk' && 'bg-destructive/10 text-destructive'
          )}
        >
          <StatusIcon status={statusResult.status} />
          {statusResult.label}
        </div>
        {isLoading && (
          <Loader2 className="h-5 w-5 animate-spin text-muted-foreground" />
        )}
      </div>

      {/* Error Alert */}
      {error && (
        <Alert variant="destructive">
          <AlertTitle>Calculation Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {/* Main Content Grid */}
      <div className="grid gap-6 lg:grid-cols-[1fr_300px]">
        {/* Left Column: Chart & Metrics */}
        <div className="space-y-6">
          {/* Snapshot Cards */}
          <div className="grid gap-4 grid-cols-2 lg:grid-cols-4">
            <Card>
              <CardHeader className="pb-2">
                <CardDescription>At Retirement (Age {assumptions.retirementAge})</CardDescription>
              </CardHeader>
              <CardContent>
                <p className="text-2xl font-bold text-foreground">
                  {formatCurrency(projection.summary.projectedRetirementBalance)}
                </p>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-2">
                <CardDescription>Retirement Age</CardDescription>
              </CardHeader>
              <CardContent>
                <p className="text-2xl font-bold text-foreground">
                  {assumptions.retirementAge}
                </p>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-2">
                <CardDescription>Funds Last Until</CardDescription>
              </CardHeader>
              <CardContent>
                {projection.summary.yearsUntilDepletion === null ? (
                  <p className="text-2xl font-bold text-success">Age 90+</p>
                ) : (
                  <p className="text-2xl font-bold text-destructive">
                    Age {currentAge + projection.summary.yearsUntilDepletion}
                  </p>
                )}
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-2">
                <CardDescription>Expected Return</CardDescription>
              </CardHeader>
              <CardContent>
                <p className="text-2xl font-bold text-foreground">
                  {(assumptions.expectedReturn * 100).toFixed(1)}%
                </p>
              </CardContent>
            </Card>
          </div>

          {/* Chart */}
          <div>
            <h2 className="text-lg font-semibold mb-2">Assets Over Time</h2>
            <p className="text-sm text-muted-foreground mb-4">
              Your projected balance from age {currentAge} to 90
            </p>
            <ProjectionChart
              records={projection.records}
              retirementAge={assumptions.retirementAge}
              currentAge={currentAge}
              inflationRate={assumptions.inflationRate}
              shortfallAge={shortfallAge}
            />
          </div>

          {/* Table */}
          <ProjectionTable
            records={projection.records}
            retirementAge={assumptions.retirementAge}
          />
        </div>

        {/* Right Column: Assumptions Panel */}
        <div className="lg:sticky lg:top-6 lg:self-start">
          <AssumptionsPanel
            assumptions={assumptions}
            defaultAssumptions={defaultAssumptions}
            currentAge={currentAge}
            onChange={setAssumptions}
            onReset={handleReset}
            disabled={isLoading}
          />
        </div>
      </div>
    </div>
  );
}
```

#### 2. Update Server Page Component
**File**: `src/app/plans/page.tsx`

Refactor to pass initial data to client component. The server component handles data fetching and initial projection calculation, then passes serializable data to the client.

Key changes:
- Keep all data fetching and initial projection in server component
- Create `defaultAssumptions` object from profile data
- Pass `initialProjection`, `currentAge`, `defaultAssumptions`, `inflationRate` to `PlansClient`
- Replace the entire JSX return with `<PlansClient ... />`

### Success Criteria:

#### Automated Verification:
- [x] Type checking passes: `npm run typecheck`
- [x] Build succeeds: `npm run build`
- [x] Lint passes: `npm run lint`

#### Manual Verification:
- [ ] Page loads with same initial appearance as before
- [ ] Assumptions panel appears on the right side (desktop) or below (mobile)
- [ ] Adjusting sliders triggers loading state
- [ ] Chart updates after API response

**Implementation Note**: Pause here for manual verification before Phase 4.

---

## Phase 4: Add Retirement Age Override to API

### Overview
The current API doesn't support `retirementAge` as an override parameter. Add this support.

### Changes Required:

#### 1. Update Validation Schema
**File**: `src/lib/validation/projections.ts`

Add retirement age to schema:
```typescript
// Add after socialSecurityAge validation
retirementAge: z
  .number()
  .int()
  .min(30, 'Retirement age must be at least 30')
  .max(80, 'Retirement age cannot exceed 80')
  .optional(),
```

#### 2. Update API Route
**File**: `src/app/api/projections/calculate/route.ts`

In `calculateProjection` function, update line 97:
```typescript
retirementAge: (overrides.retirementAge as number) ?? snapshot.targetRetirementAge,
```

### Success Criteria:

#### Automated Verification:
- [x] Type checking passes: `npm run typecheck`
- [x] API tests pass: `npm test -- --run src/app/api/projections`
- [x] Build succeeds: `npm run build`

#### Manual Verification:
- [ ] POST to `/api/projections/calculate` with `{ "retirementAge": 65 }` returns different results
- [ ] Retirement age slider on plans page updates projections correctly

**Implementation Note**: Pause here for manual verification before Phase 5.

---

## Phase 5: Mobile Optimization

### Overview
Ensure the assumptions panel works well on mobile devices with a collapsible drawer pattern.

### Changes Required:

#### 1. Update PlansClient for Mobile
**File**: `src/app/plans/plans-client.tsx`

Add collapsible behavior on mobile:
- Use `Collapsible` component from `src/components/ui/collapsible.tsx`
- On mobile (< lg breakpoint), panel starts collapsed
- Sticky panel on desktop, collapsible on mobile

#### 2. Add Mobile Detection Hook (if needed)
Use CSS media queries via Tailwind classes rather than JavaScript detection:
- Desktop: Side panel, always visible
- Mobile: Collapsible panel above the chart

### Success Criteria:

#### Automated Verification:
- [ ] Type checking passes: `npm run typecheck`
- [ ] Build succeeds: `npm run build`

#### Manual Verification:
- [ ] On mobile viewport, assumptions panel collapses/expands
- [ ] Chart remains visible when panel is expanded
- [ ] Sliders are usable on touch devices
- [ ] Performance remains acceptable (no jank during animations)

---

## Testing Strategy

### Unit Tests

#### Slider Component
- [ ] Renders with correct min/max/step values
- [ ] Calls onValueChange when dragged
- [ ] Formats value correctly with formatValue prop
- [ ] Respects disabled state

#### AssumptionsPanel Component
- [ ] Renders three sliders with correct labels
- [ ] Reset button shows only when values differ from defaults
- [ ] Calls onChange with updated assumptions object
- [ ] Shows "(modified)" indicator for changed values

### Integration Tests

#### Plans Page Flow
- [ ] Initial load shows default assumptions
- [ ] Changing slider triggers API call
- [ ] API response updates chart and metrics
- [ ] Reset returns to initial state
- [ ] Navigation away and back resets assumptions

### Manual Testing Steps
1. Load plans page, verify initial projection displays
2. Move expected return slider to 4%, verify chart updates within 2 seconds
3. Move inflation slider to 5%, verify chart updates
4. Move retirement age slider, verify chart updates
5. Click Reset, verify all values return to defaults
6. Navigate to profile page and back, verify assumptions are reset
7. Test on mobile viewport, verify collapsible panel works
8. Test with slow network (DevTools throttling), verify loading states appear

## Performance Considerations

- **Debounce**: 300ms delay before API call to prevent excessive requests during slider drag
- **AbortController**: Cancel in-flight requests when new changes come in
- **Optimistic UI**: Show loading spinner without blocking UI interactions
- **API Performance**: Existing projection engine runs in <500ms, well within 2 second requirement

## Migration Notes

No database migrations required. All changes are UI/client-side with one optional API schema addition.

## References

- Original Story Scope: [story-3-scope.md](thoughts/personal/tickets/epic-3/projection-modeling/story-3-scope.md)
- Research Document: [2025-12-25-story-2.4-adjust-assumptions-research.md](thoughts/shared/research/2025-12-25-story-2.4-adjust-assumptions-research.md)
- Projection Engine: [engine.ts](src/lib/projections/engine.ts)
- API Route: [route.ts](src/app/api/projections/calculate/route.ts)
- Validation Schema: [projections.ts](src/lib/validation/projections.ts)
