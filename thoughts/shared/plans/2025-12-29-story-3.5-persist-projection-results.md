# Story 3.5 — Persist Projection Results Implementation Plan

## Overview

Implement persistence for projection results so they can be stored linked to a plan ID, re-rendered without recalculation, and used as input for future AI narrative generation. This involves creating a new `projection_results` database table, API endpoints for saving/retrieving projections, and staleness detection logic.

## Current State Analysis

### What Exists
- **Projection Engine**: Complete calculation engine at [engine.ts](src/lib/projections/engine.ts) that generates `ProjectionResult` with `records[]` and `summary`
- **API Endpoint**: `/api/projections/calculate` returns projection results but does NOT persist them
- **Database Patterns**: Drizzle ORM with PostgreSQL/Supabase, JSONB columns with `.$type<T>()`, Row-Level Security
- **Plans Table**: Exists at [plans.ts](src/db/schema/plans.ts) with `userId` FK and cascade delete

### What's Missing
- `projection_results` table to store projection outputs
- API endpoints to save and retrieve stored projections
- Staleness detection to indicate when recalculation is needed
- Integration with plans page to use stored projections

### Key Discoveries
- One-to-one relationship: Each plan has exactly one stored projection (upsert pattern)
- JSONB columns use explicit TypeScript types via `.$type<T>()`
- RLS policies follow `auth.uid() = user_id` pattern
- `SecureQueryBuilder` class at [secure-query.ts](src/db/secure-query.ts) provides user-scoped operations

## Desired End State

After implementation:
1. Projections are automatically saved when calculated via API
2. Plans page loads stored projections without recalculation
3. UI indicates when a projection is stale (financial data changed since calculation)
4. Stored projections include inputs, assumptions, and full records for AI narrative use

### Verification
- Database migration applies successfully
- Projections persist across page refreshes
- Staleness indicator appears when financial snapshot is modified
- All existing tests continue to pass

## What We're NOT Doing

- **AI Narrative Generation**: Deferred to Story 3.6; we're only storing data in a format ready for AI consumption
- **Multiple Projections per Plan**: Using one-to-one with upsert; no history tracking
- **Scenario Comparison**: Future feature; not in scope
- **Projection Narratives Table**: Deferred; storing data structure to support it later
- **Frontend Integration**: UI changes (loading stored projections, staleness indicator) deferred to separate story

## Design Decisions

- **Auto-save**: Projections auto-save when calculated with a `planId` parameter
- **Staleness Detection**: Field-level comparison of stored vs current inputs (not timestamp-based)

---

## Phase 1: Database Schema

### Overview
Create the `projection_results` table schema with proper foreign keys, JSONB columns, and TypeScript types.

### Changes Required

#### 1. Create Type Definitions for Stored Assumptions
**File**: [types.ts](src/lib/projections/types.ts)
**Changes**: Add `ProjectionAssumptions` interface at the end of the file

```typescript
/**
 * Stored assumptions for a projection (human-readable snapshot)
 */
export interface ProjectionAssumptions {
  expectedReturn: number;
  inflationRate: number;
  healthcareInflationRate: number;
  contributionGrowthRate: number;
  retirementAge: number;
  maxAge: number;
}
```

#### 2. Create Projection Results Schema
**File**: `src/db/schema/projection-results.ts` (new file)
**Changes**: Create new table schema

```typescript
import { pgTable, uuid, jsonb, integer, timestamp } from 'drizzle-orm/pg-core';
import { plans } from './plans';
import { userProfile } from './user-profile';
import type {
  ProjectionInput,
  ProjectionAssumptions,
  ProjectionRecord,
  ProjectionSummary,
} from '@/lib/projections/types';

export const projectionResults = pgTable('projection_results', {
  id: uuid('id').primaryKey().defaultRandom(),
  planId: uuid('plan_id')
    .notNull()
    .unique() // Enforces one-to-one relationship
    .references(() => plans.id, { onDelete: 'cascade' }),
  userId: uuid('user_id')
    .notNull()
    .references(() => userProfile.id, { onDelete: 'cascade' }),

  // Stored inputs (for re-rendering and staleness detection)
  inputs: jsonb('inputs').notNull().$type<ProjectionInput>(),

  // Stored assumptions (human-readable snapshot for AI narrative)
  assumptions: jsonb('assumptions').notNull().$type<ProjectionAssumptions>(),

  // Projection results
  records: jsonb('records').notNull().$type<ProjectionRecord[]>(),
  summary: jsonb('summary').notNull().$type<ProjectionSummary>(),

  // Metadata
  calculationTimeMs: integer('calculation_time_ms'),

  // Timestamps
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

// Row-Level Security Policy (applied via migration SQL)
// CREATE POLICY "Users can only access their own projection results"
//   ON projection_results FOR ALL
//   USING (auth.uid() = user_id);
```

#### 3. Export from Schema Index
**File**: [index.ts](src/db/schema/index.ts)
**Changes**: Add export for new schema

```typescript
export * from './user-profile';
export * from './financial-snapshot';
export * from './plans';
export * from './projection-results';
```

#### 4. Generate and Customize Migration
**Command**: `npm run db:generate`

After generation, edit the migration file to add:
- RLS enablement
- RLS policy
- Index on `user_id`
- Index on `plan_id`
- `updated_at` trigger

Add these statements to the end of the generated migration:

```sql
--> statement-breakpoint
-- Enable Row-Level Security
ALTER TABLE "projection_results" ENABLE ROW LEVEL SECURITY;--> statement-breakpoint

-- RLS Policy: Users can only access their own projection results
CREATE POLICY "Users can only access their own projection results"
  ON "projection_results"
  FOR ALL
  USING (auth.uid() = user_id);--> statement-breakpoint

-- Create indexes for performance
CREATE INDEX "idx_projection_results_user_id" ON "projection_results"(user_id);--> statement-breakpoint
CREATE INDEX "idx_projection_results_plan_id" ON "projection_results"(plan_id);--> statement-breakpoint

-- Apply updated_at trigger
CREATE TRIGGER update_projection_results_updated_at
  BEFORE UPDATE ON "projection_results"
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

### Success Criteria

#### Automated Verification:
- [x] `npm run db:generate` completes without errors
- [x] Migration file is created in `src/db/migrations/`
- [x] `npm run typecheck` passes
- [x] `npm run lint` passes

#### Manual Verification:
- [x] Review generated migration SQL for correctness
- [x] Verify JSONB columns and foreign keys are properly defined

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 2.

---

## Phase 2: SecureQueryBuilder Methods

### Overview
Add methods to `SecureQueryBuilder` for saving and retrieving projection results with proper user scoping.

### Changes Required

#### 1. Update SecureQueryBuilder
**File**: [secure-query.ts](src/db/secure-query.ts)
**Changes**: Add projection result methods

First, update imports at the top of the file:

```typescript
import { eq, and } from 'drizzle-orm';
import { db } from './client';
import { userProfile, financialSnapshot, plans, projectionResults } from './schema';
```

Then add these methods to the `SecureQueryBuilder` class (before the closing brace):

```typescript
  // Projection Results queries
  async getProjectionForPlan(planId: string) {
    const [result] = await db
      .select()
      .from(projectionResults)
      .where(and(
        eq(projectionResults.planId, planId),
        eq(projectionResults.userId, this.userId)
      ));
    return result ?? null;
  }

  async saveProjectionResult(
    planId: string,
    data: {
      inputs: typeof projectionResults.$inferInsert['inputs'];
      assumptions: typeof projectionResults.$inferInsert['assumptions'];
      records: typeof projectionResults.$inferInsert['records'];
      summary: typeof projectionResults.$inferInsert['summary'];
      calculationTimeMs?: number;
    }
  ) {
    const [result] = await db
      .insert(projectionResults)
      .values({
        planId,
        userId: this.userId,
        ...data,
      })
      .onConflictDoUpdate({
        target: projectionResults.planId,
        set: {
          inputs: data.inputs,
          assumptions: data.assumptions,
          records: data.records,
          summary: data.summary,
          calculationTimeMs: data.calculationTimeMs,
          updatedAt: new Date(),
        },
      })
      .returning();

    return result;
  }

  async deleteProjectionForPlan(planId: string) {
    await db
      .delete(projectionResults)
      .where(and(
        eq(projectionResults.planId, planId),
        eq(projectionResults.userId, this.userId)
      ));
  }
```

### Success Criteria

#### Automated Verification:
- [x] `npm run typecheck` passes
- [x] `npm run lint` passes

#### Manual Verification:
- [x] Code review confirms proper user scoping in all methods
- [x] Upsert pattern correctly updates existing records

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 3.

---

## Phase 3: API Endpoints

### Overview
Create API endpoints to save projections and retrieve stored projections for a plan.

### Changes Required

#### 1. Create Save Projection Endpoint
**File**: `src/app/api/projections/save/route.ts` (new file)
**Changes**: POST endpoint to save projection result

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getServerUser } from '@/lib/auth/server';
import { createSecureQuery } from '@/db/secure-query';
import type {
  ProjectionInput,
  ProjectionAssumptions,
  ProjectionRecord,
  ProjectionSummary,
} from '@/lib/projections/types';

const saveProjectionSchema = z.object({
  planId: z.string().uuid(),
  inputs: z.object({}).passthrough() as z.ZodType<ProjectionInput>,
  assumptions: z.object({
    expectedReturn: z.number(),
    inflationRate: z.number(),
    healthcareInflationRate: z.number(),
    contributionGrowthRate: z.number(),
    retirementAge: z.number(),
    maxAge: z.number(),
  }) as z.ZodType<ProjectionAssumptions>,
  records: z.array(z.object({}).passthrough()) as z.ZodType<ProjectionRecord[]>,
  summary: z.object({
    startingBalance: z.number(),
    endingBalance: z.number(),
    totalContributions: z.number(),
    totalWithdrawals: z.number(),
    yearsUntilDepletion: z.number().nullable(),
    projectedRetirementBalance: z.number(),
  }) as z.ZodType<ProjectionSummary>,
  calculationTimeMs: z.number().optional(),
});

export async function POST(request: NextRequest) {
  const user = await getServerUser();
  if (!user) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  let body: unknown;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ message: 'Invalid JSON' }, { status: 400 });
  }

  const parseResult = saveProjectionSchema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json(
      { message: 'Invalid request', errors: parseResult.error.flatten() },
      { status: 400 }
    );
  }

  const { planId, inputs, assumptions, records, summary, calculationTimeMs } = parseResult.data;

  const secureQuery = createSecureQuery(user.id);

  // Verify user owns the plan
  const plan = await secureQuery.getPlanById(planId);
  if (!plan) {
    return NextResponse.json(
      { message: 'Plan not found or access denied' },
      { status: 404 }
    );
  }

  const result = await secureQuery.saveProjectionResult(planId, {
    inputs,
    assumptions,
    records,
    summary,
    calculationTimeMs,
  });

  return NextResponse.json({ projectionResult: result }, { status: 200 });
}
```

#### 2. Create Get Projection Endpoint
**File**: `src/app/api/projections/[planId]/route.ts` (new file)
**Changes**: GET endpoint to retrieve stored projection

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getServerUser } from '@/lib/auth/server';
import { createSecureQuery } from '@/db/secure-query';

interface RouteParams {
  params: Promise<{ planId: string }>;
}

export async function GET(request: NextRequest, { params }: RouteParams) {
  const user = await getServerUser();
  if (!user) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { planId } = await params;

  if (!planId) {
    return NextResponse.json({ message: 'Plan ID is required' }, { status: 400 });
  }

  const secureQuery = createSecureQuery(user.id);

  // Verify user owns the plan
  const plan = await secureQuery.getPlanById(planId);
  if (!plan) {
    return NextResponse.json(
      { message: 'Plan not found or access denied' },
      { status: 404 }
    );
  }

  const projectionResult = await secureQuery.getProjectionForPlan(planId);

  if (!projectionResult) {
    return NextResponse.json(
      { message: 'No projection found for this plan' },
      { status: 404 }
    );
  }

  return NextResponse.json({ projectionResult }, { status: 200 });
}
```

#### 3. Update Calculate Endpoint to Auto-Save
**File**: [route.ts](src/app/api/projections/calculate/route.ts)
**Changes**: Add auto-save after calculation

Add import at the top:
```typescript
import { createSecureQuery } from '@/db/secure-query';
```

Modify the `calculateProjection` function signature to accept `planId` as optional parameter:
```typescript
async function calculateProjection(
  userId: string,
  overrides: Record<string, unknown> = {},
  planId?: string
)
```

After calculating the projection (around line 171), add save logic:
```typescript
  // Save projection if planId provided
  if (planId) {
    const secureQuery = createSecureQuery(userId);

    const assumptions: ProjectionAssumptions = {
      expectedReturn: projectionInput.expectedReturn,
      inflationRate: projectionInput.inflationRate,
      healthcareInflationRate: projectionInput.healthcareInflationRate,
      contributionGrowthRate: projectionInput.contributionGrowthRate,
      retirementAge: projectionInput.retirementAge,
      maxAge: projectionInput.maxAge,
    };

    await secureQuery.saveProjectionResult(planId, {
      inputs: projectionInput,
      assumptions,
      records: projectionResult.records,
      summary: projectionResult.summary,
      calculationTimeMs: calculationTime,
    });
  }
```

Add import for the type:
```typescript
import type { ProjectionAssumptions } from '@/lib/projections/types';
```

Update the POST handler to extract `planId` from request body and pass it:
```typescript
export async function POST(request: NextRequest) {
  // ... existing auth check ...

  const body = await request.json();
  const { planId, ...overrides } = body;

  // ... existing validation ...

  return calculateProjection(user.id, overrides, planId);
}
```

### Success Criteria

#### Automated Verification:
- [x] `npm run typecheck` passes
- [x] `npm run lint` passes
- [x] `npm run build` passes

#### Manual Verification:
- [x] POST `/api/projections/save` successfully saves a projection
- [x] GET `/api/projections/[planId]` retrieves the saved projection
- [x] POST `/api/projections/calculate` with `planId` auto-saves the result
- [x] Unauthorized access returns 401
- [x] Accessing another user's plan returns 404

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 4.

---

## Phase 4: Staleness Detection

### Overview
Implement field-level comparison to detect when stored projection inputs differ from current financial snapshot data.

### Changes Required

#### 1. Create Staleness Detection Utility
**File**: `src/lib/projections/staleness.ts` (new file)
**Changes**: Create staleness detection function

```typescript
import type { ProjectionInput, BalanceByType, IncomeStream } from './types';

export interface StalenessResult {
  isStale: boolean;
  changedFields: string[];
  changes: Record<string, { previous: unknown; current: unknown }>;
}

/**
 * Check if stored projection inputs differ from current inputs.
 * Returns details about what changed for UI display and AI narrative.
 */
export function checkProjectionStaleness(
  storedInputs: ProjectionInput,
  currentInputs: ProjectionInput
): StalenessResult {
  const changedFields: string[] = [];
  const changes: Record<string, { previous: unknown; current: unknown }> = {};

  // Check primitive fields that affect projection outcomes
  const fieldsToCheck: (keyof ProjectionInput)[] = [
    'currentAge',
    'retirementAge',
    'maxAge',
    'annualContribution',
    'expectedReturn',
    'inflationRate',
    'healthcareInflationRate',
    'annualExpenses',
    'annualHealthcareCosts',
    'annualDebtPayments',
    'contributionGrowthRate',
  ];

  for (const field of fieldsToCheck) {
    const storedValue = storedInputs[field];
    const currentValue = currentInputs[field];

    if (storedValue !== currentValue) {
      changedFields.push(field);
      changes[field] = {
        previous: storedValue,
        current: currentValue,
      };
    }
  }

  // Deep compare balances
  if (!deepEqualBalances(storedInputs.balancesByType, currentInputs.balancesByType)) {
    changedFields.push('balancesByType');
    changes['balancesByType'] = {
      previous: storedInputs.balancesByType,
      current: currentInputs.balancesByType,
    };
  }

  // Deep compare contribution allocation
  if (!deepEqualBalances(storedInputs.contributionAllocation, currentInputs.contributionAllocation)) {
    changedFields.push('contributionAllocation');
    changes['contributionAllocation'] = {
      previous: storedInputs.contributionAllocation,
      current: currentInputs.contributionAllocation,
    };
  }

  // Deep compare income streams
  if (!deepEqualIncomeStreams(storedInputs.incomeStreams, currentInputs.incomeStreams)) {
    changedFields.push('incomeStreams');
    changes['incomeStreams'] = {
      previous: storedInputs.incomeStreams,
      current: currentInputs.incomeStreams,
    };
  }

  return {
    isStale: changedFields.length > 0,
    changedFields,
    changes,
  };
}

function deepEqualBalances(a: BalanceByType, b: BalanceByType): boolean {
  return (
    a.taxDeferred === b.taxDeferred &&
    a.taxFree === b.taxFree &&
    a.taxable === b.taxable
  );
}

function deepEqualIncomeStreams(a: IncomeStream[], b: IncomeStream[]): boolean {
  if (a.length !== b.length) return false;

  // Sort by ID for consistent comparison
  const sortedA = [...a].sort((x, y) => x.id.localeCompare(y.id));
  const sortedB = [...b].sort((x, y) => x.id.localeCompare(y.id));

  return JSON.stringify(sortedA) === JSON.stringify(sortedB);
}
```

#### 2. Create Staleness Check API Endpoint
**File**: `src/app/api/projections/[planId]/staleness/route.ts` (new file)
**Changes**: GET endpoint to check if projection is stale

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getServerUser } from '@/lib/auth/server';
import { createSecureQuery } from '@/db/secure-query';
import { checkProjectionStaleness } from '@/lib/projections/staleness';
import { buildProjectionInputFromSnapshot } from '@/lib/projections/input-builder';

interface RouteParams {
  params: Promise<{ planId: string }>;
}

export async function GET(request: NextRequest, { params }: RouteParams) {
  const user = await getServerUser();
  if (!user) {
    return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
  }

  const { planId } = await params;

  const secureQuery = createSecureQuery(user.id);

  // Verify user owns the plan
  const plan = await secureQuery.getPlanById(planId);
  if (!plan) {
    return NextResponse.json(
      { message: 'Plan not found or access denied' },
      { status: 404 }
    );
  }

  // Get stored projection
  const projectionResult = await secureQuery.getProjectionForPlan(planId);
  if (!projectionResult) {
    return NextResponse.json(
      { message: 'No projection found for this plan', isStale: true },
      { status: 200 }
    );
  }

  // Get current snapshot and build current inputs
  const snapshot = await secureQuery.getFinancialSnapshot();
  if (!snapshot) {
    return NextResponse.json(
      { message: 'No financial snapshot found' },
      { status: 404 }
    );
  }

  const currentInputs = buildProjectionInputFromSnapshot(snapshot, {});
  const staleness = checkProjectionStaleness(projectionResult.inputs, currentInputs);

  return NextResponse.json({
    ...staleness,
    lastCalculated: projectionResult.updatedAt,
  });
}
```

#### 3. Extract Input Builder Function
**File**: `src/lib/projections/input-builder.ts` (new file)
**Changes**: Extract projection input building logic from API route

This requires refactoring the input-building logic from [route.ts](src/app/api/projections/calculate/route.ts) into a reusable function. The function should accept a financial snapshot and optional overrides, returning a `ProjectionInput`.

```typescript
import type { ProjectionInput, BalanceByType, IncomeStream, TaxCategory } from './types';
import { ACCOUNT_TAX_CATEGORY } from './types';
import type { financialSnapshot } from '@/db/schema/financial-snapshot';
import {
  DEFAULT_MAX_AGE,
  DEFAULT_INFLATION_RATE,
  DEFAULT_HEALTHCARE_INFLATION_RATE,
  DEFAULT_CONTRIBUTION_GROWTH_RATE,
  DEFAULT_CONTRIBUTION_ALLOCATION,
  estimateReturnByRisk,
  deriveAnnualExpenses,
  estimateAnnualDebtPayments,
  estimateHealthcareCosts,
} from './assumptions';

type FinancialSnapshotRow = typeof financialSnapshot.$inferSelect;

export interface ProjectionOverrides {
  expectedReturn?: number;
  inflationRate?: number;
  maxAge?: number;
  contributionGrowthRate?: number;
  retirementAge?: number;
  incomeStreams?: IncomeStream[];
  annualHealthcareCosts?: number;
  healthcareInflationRate?: number;
  contributionAllocation?: BalanceByType;
}

export function buildProjectionInputFromSnapshot(
  snapshot: FinancialSnapshotRow,
  overrides: ProjectionOverrides
): ProjectionInput {
  const currentYear = new Date().getFullYear();
  const currentAge = currentYear - snapshot.birthYear;
  const riskTolerance = snapshot.riskTolerance as 'Conservative' | 'Moderate' | 'Aggressive';

  // Aggregate balances by tax category
  const balancesByType: BalanceByType = {
    taxDeferred: 0,
    taxFree: 0,
    taxable: 0,
  };

  const accounts = snapshot.investmentAccounts ?? [];
  for (const account of accounts) {
    const category: TaxCategory = ACCOUNT_TAX_CATEGORY[account.type as keyof typeof ACCOUNT_TAX_CATEGORY] ?? 'taxable';
    balancesByType[category] += account.balance;
  }

  // Calculate annual contribution
  const annualContribution = accounts.reduce(
    (sum, acc) => sum + (acc.monthlyContribution ?? 0) * 12,
    0
  );

  // Calculate annual expenses
  let annualExpenses: number;
  const incomeExpenses = snapshot.incomeExpenses;
  if (incomeExpenses?.monthlyEssential != null || incomeExpenses?.monthlyDiscretionary != null) {
    annualExpenses =
      ((incomeExpenses.monthlyEssential ?? 0) + (incomeExpenses.monthlyDiscretionary ?? 0)) * 12;
  } else {
    annualExpenses = deriveAnnualExpenses(
      Number(snapshot.annualIncome),
      Number(snapshot.savingsRate)
    );
  }

  // Calculate debt payments
  const annualDebtPayments = estimateAnnualDebtPayments(snapshot.debts ?? []);

  // Determine retirement age
  const retirementAge = overrides.retirementAge ?? snapshot.targetRetirementAge;

  // Determine healthcare costs
  const annualHealthcareCosts =
    overrides.annualHealthcareCosts ?? estimateHealthcareCosts(retirementAge);

  // Build income streams
  const incomeStreams = overrides.incomeStreams ?? snapshot.incomeStreams ?? [];

  return {
    currentAge,
    retirementAge,
    maxAge: overrides.maxAge ?? DEFAULT_MAX_AGE,
    balancesByType,
    annualContribution,
    contributionAllocation: overrides.contributionAllocation ?? DEFAULT_CONTRIBUTION_ALLOCATION,
    expectedReturn: overrides.expectedReturn ?? estimateReturnByRisk(riskTolerance),
    inflationRate: overrides.inflationRate ?? DEFAULT_INFLATION_RATE,
    contributionGrowthRate: overrides.contributionGrowthRate ?? DEFAULT_CONTRIBUTION_GROWTH_RATE,
    annualExpenses,
    annualHealthcareCosts,
    healthcareInflationRate: overrides.healthcareInflationRate ?? DEFAULT_HEALTHCARE_INFLATION_RATE,
    incomeStreams,
    annualDebtPayments,
  };
}
```

### Success Criteria

#### Automated Verification:
- [x] `npm run typecheck` passes
- [x] `npm run lint` passes
- [x] `npm run build` passes

#### Manual Verification:
- [x] GET `/api/projections/[planId]/staleness` returns `isStale: false` for fresh projection
- [x] After modifying financial snapshot, staleness check returns `isStale: true`
- [x] `changedFields` array correctly identifies what changed

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 5.

---

## Phase 5: Database Migration & Deployment

### Overview
Apply the database migration and verify the complete implementation works end-to-end.

### Changes Required

#### 1. Push Migration to Database
**Command**: `npx drizzle-kit push`

This applies the generated migration to the Supabase database.

#### 2. Verify RLS Policies
Connect to Supabase SQL Editor and run:

```sql
-- Verify RLS is enabled
SELECT tablename, rowsecurity
FROM pg_tables
WHERE schemaname = 'public' AND tablename = 'projection_results';

-- Verify policy exists
SELECT polname, polcmd
FROM pg_policies
WHERE tablename = 'projection_results';
```

### Success Criteria

#### Automated Verification:
- [x] `npx drizzle-kit push` completes successfully
- [x] All existing tests pass: `npm test -- --run`
- [x] Build succeeds: `npm run build`

#### Manual Verification:
- [x] Table `projection_results` exists in Supabase
- [x] RLS is enabled on the table
- [x] RLS policy exists and matches expected pattern
- [x] Complete flow works: calculate → save → retrieve → staleness check

**Implementation Note**: After completing this phase and all verification passes, the implementation is complete.

---

## Testing Strategy

### Unit Tests
- `src/lib/projections/__tests__/staleness.test.ts`: Test staleness detection with various input differences
- `src/lib/projections/__tests__/input-builder.test.ts`: Test input building from snapshot

### Integration Tests
- API endpoint tests for save/retrieve/staleness check
- Verify upsert behavior (second save updates, doesn't duplicate)

### Manual Testing Steps
1. Use API client (curl/Postman) to call `POST /api/projections/calculate` with `planId`
2. Verify projection is saved via `GET /api/projections/[planId]`
3. Modify financial snapshot via profile API
4. Call `GET /api/projections/[planId]/staleness` - should return `isStale: true`
5. Recalculate with same `planId` - staleness should clear

---

## Performance Considerations

1. **JSONB Indexing**: The `records` array can be large (40+ years of data). Consider GIN index on `summary` for future AI queries.
2. **Upsert Pattern**: Uses `onConflictDoUpdate` for efficient single-query save/update.
3. **Lazy Loading**: Staleness check doesn't load full records array, only compares inputs.

---

## References

- Original ticket: [story-5-scope.md](thoughts/personal/tickets/epic-3/projection-modeling/story-5-scope.md)
- Research document: [2025-12-29-story-3.5-persist-projection-results.md](thoughts/shared/research/2025-12-29-story-3.5-persist-projection-results.md)
- Existing projection engine: [engine.ts](src/lib/projections/engine.ts)
- Database patterns: [financial-snapshot.ts](src/db/schema/financial-snapshot.ts)
- Secure query builder: [secure-query.ts](src/db/secure-query.ts)
