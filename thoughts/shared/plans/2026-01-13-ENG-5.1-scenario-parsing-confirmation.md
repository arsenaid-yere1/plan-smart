# Story 5.1: Natural-Language Scenario Parsing with Confirmation

## Overview

Implement a conversational "what-if" interface that allows users to ask scenario questions in plain English (e.g., "What if I retire at 65 instead of 60?"). The AI parses the intent, confirms parameters with the user, and only runs the projection after explicit approval.

## Current State Analysis

### What Exists
- **Override mechanism**: `ProjectionOverrides` interface at [input-builder.ts:20-30](src/lib/projections/input-builder.ts#L20-L30) supports all scenario parameters
- **AI parsing pattern**: Smart-intake at [smart-intake.tsx](src/components/onboarding/smart-intake.tsx) demonstrates parse-then-confirm flow with confidence scores
- **OpenAI integration**: gpt-4o-mini with JSON response format at [parse-financial-nl/route.ts](src/app/api/parse-financial-nl/route.ts)
- **Projection calculation**: POST `/api/projections/calculate` accepts overrides at [route.ts:302-335](src/app/api/projections/calculate/route.ts#L302-L335)
- **Plans page state**: Debounced recalculation via `setAssumptions` at [plans-client.tsx:44-110](src/app/plans/plans-client.tsx#L44-L110)

### Key Discoveries
- The projection engine is **stateless** - can run with any valid input without side effects
- Override validation uses **Zod schemas** at [projections.ts:33-105](src/lib/validation/projections.ts#L33-L105)
- Confidence color pattern exists at [smart-intake.tsx:158-162](src/components/onboarding/smart-intake.tsx#L158-L162)

## Desired End State

Users can type natural language scenario questions (e.g., "What if I retire at 65?", "What if I get 8% returns?") into a text input on the plans page. The system:
1. Parses the question into structured overrides using AI
2. Shows a confirmation dialog with parsed parameters and confidence scores
3. Waits for explicit user approval before running the projection
4. Applies the scenario to the existing projection view upon confirmation

### Verification
- User can enter "What if I retire at 65?" and see a confirmation showing `retirementAge: 65`
- User can enter "What if I get 7% returns and retire at 62?" and see both parameters parsed
- Projection only runs after clicking "Apply Scenario"
- User can cancel and modify parameters manually
- Low-confidence extractions show yellow/red indicators

## What We're NOT Doing

- **Scenario persistence** - Scenarios are transient (session only)
- **Named scenarios** - No saving/recalling scenarios by name
- **Scenario comparison** - No side-by-side charts (future story)
- **Database schema changes** - No new tables or columns
- **Conversation history** - Each query is independent (no context)

## Implementation Approach

Reuse the smart-intake AI parsing pattern with a new endpoint and UI component. The flow:
1. User enters text → POST to `/api/scenarios/parse`
2. AI extracts `ProjectionOverrides` with confidence scores
3. Show confirmation dialog with parsed fields
4. On confirm → call existing `setAssumptions()` to trigger recalculation

---

## Phase 1: Scenario Parsing API

### Overview
Create an API endpoint that parses natural language scenario questions into structured `ProjectionOverrides`.

### Changes Required

#### 1. Scenario Parsing Types
**File**: `src/lib/scenarios/types.ts` (new file)

```typescript
import type { ProjectionOverrides } from '@/lib/projections/input-builder';

export interface ParsedScenarioField {
  key: keyof ProjectionOverrides;
  label: string;
  value: number | string;
  displayValue: string;
  confidence: number;
}

export interface ParsedScenario {
  overrides: Partial<ProjectionOverrides>;
  fields: ParsedScenarioField[];
  confidence: {
    overall: number;
    fields: Record<string, number>;
  };
  originalQuery: string;
}

export interface ScenarioParseResponse {
  success: boolean;
  data?: ParsedScenario;
  error?: string;
}
```

#### 2. Scenario Parsing Prompt
**File**: `src/lib/ai/prompts/scenario-parse.ts` (new file)

```typescript
export const SCENARIO_PARSE_PROMPT = `You are a financial scenario parser. Extract retirement projection parameters from natural language "what if" questions.

The user has an existing retirement projection. They want to explore scenarios by adjusting parameters. Extract ONLY the parameters they mention.

Return a JSON object with this structure:
{
  "overrides": {
    "expectedReturn": number | null,       // 0.04-0.15 (4%-15%), null if not mentioned
    "inflationRate": number | null,        // 0.01-0.10 (1%-10%), null if not mentioned
    "retirementAge": number | null,        // 30-80, null if not mentioned
    "maxAge": number | null,               // 50-120 (life expectancy), null if not mentioned
    "contributionGrowthRate": number | null, // 0-0.10 (0%-10%), null if not mentioned
    "annualHealthcareCosts": number | null,  // 0-100000, null if not mentioned
    "healthcareInflationRate": number | null // 0-0.15 (0%-15%), null if not mentioned
  },
  "confidence": {
    "overall": number,    // 0-1 overall extraction confidence
    "fields": {           // Per-field confidence scores
      "expectedReturn": number,
      "retirementAge": number
      // ... only include fields that were extracted
    }
  }
}

Rules:
- Convert percentages to decimals (e.g., "7%" → 0.07)
- "retire at 65" → retirementAge: 65
- "7% returns" or "7% growth" → expectedReturn: 0.07
- "live to 90" or "life expectancy of 90" → maxAge: 90
- "3% inflation" → inflationRate: 0.03
- Only extract parameters explicitly mentioned or strongly implied
- Set confidence low (0.5-0.7) for inferred values, high (0.8-1.0) for explicit values
- Set null for any parameter not mentioned
- If the query doesn't contain any recognizable scenario parameters, return empty overrides with overall confidence 0.3`;
```

#### 3. Scenario Parse API Route
**File**: `src/app/api/scenarios/parse/route.ts` (new file)

```typescript
import { NextResponse } from 'next/server';
import OpenAI from 'openai';
import { getServerUser } from '@/lib/auth/server';
import { SCENARIO_PARSE_PROMPT } from '@/lib/ai/prompts/scenario-parse';
import type { ParsedScenario, ParsedScenarioField } from '@/lib/scenarios/types';

const FIELD_LABELS: Record<string, string> = {
  expectedReturn: 'Expected Return',
  inflationRate: 'Inflation Rate',
  retirementAge: 'Retirement Age',
  maxAge: 'Life Expectancy',
  contributionGrowthRate: 'Contribution Growth Rate',
  annualHealthcareCosts: 'Annual Healthcare Costs',
  healthcareInflationRate: 'Healthcare Inflation Rate',
};

function formatDisplayValue(key: string, value: number): string {
  switch (key) {
    case 'expectedReturn':
    case 'inflationRate':
    case 'contributionGrowthRate':
    case 'healthcareInflationRate':
      return `${(value * 100).toFixed(1)}%`;
    case 'retirementAge':
    case 'maxAge':
      return `Age ${value}`;
    case 'annualHealthcareCosts':
      return `$${value.toLocaleString()}/year`;
    default:
      return String(value);
  }
}

export async function POST(request: Request) {
  try {
    const user = await getServerUser();
    if (!user) {
      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
    }

    const { query } = await request.json();
    if (!query || typeof query !== 'string' || query.trim().length === 0) {
      return NextResponse.json(
        { success: false, error: 'Query is required' },
        { status: 400 }
      );
    }

    if (!process.env.OPENAI_API_KEY) {
      return NextResponse.json(
        { success: false, error: 'OpenAI API key not configured' },
        { status: 500 }
      );
    }

    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        { role: 'system', content: SCENARIO_PARSE_PROMPT },
        { role: 'user', content: query },
      ],
      response_format: { type: 'json_object' },
      temperature: 0.1,
    });

    const content = completion.choices[0]?.message?.content;
    if (!content) {
      return NextResponse.json(
        { success: false, error: 'Failed to parse response' },
        { status: 500 }
      );
    }

    const parsed = JSON.parse(content);

    // Filter out null values from overrides
    const overrides: Record<string, number> = {};
    const fields: ParsedScenarioField[] = [];

    for (const [key, value] of Object.entries(parsed.overrides || {})) {
      if (value !== null && value !== undefined) {
        overrides[key] = value as number;
        fields.push({
          key: key as keyof typeof FIELD_LABELS,
          label: FIELD_LABELS[key] || key,
          value: value as number,
          displayValue: formatDisplayValue(key, value as number),
          confidence: parsed.confidence?.fields?.[key] ?? parsed.confidence?.overall ?? 0.8,
        });
      }
    }

    const scenario: ParsedScenario = {
      overrides,
      fields,
      confidence: {
        overall: parsed.confidence?.overall ?? 0.8,
        fields: parsed.confidence?.fields ?? {},
      },
      originalQuery: query,
    };

    return NextResponse.json({ success: true, data: scenario });
  } catch (error) {
    console.error('Scenario parse error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to parse scenario' },
      { status: 500 }
    );
  }
}
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Linting passes: `npm run lint`
- [x] New files exist: `src/lib/scenarios/types.ts`, `src/lib/ai/prompts/scenario-parse.ts`, `src/app/api/scenarios/parse/route.ts`

#### Manual Verification:
- [x] API returns 401 for unauthenticated requests
- [x] API returns 400 for empty query
- [x] "What if I retire at 65?" returns `{ overrides: { retirementAge: 65 }, ... }`
- [x] "What if I get 7% returns?" returns `{ overrides: { expectedReturn: 0.07 }, ... }`
- [x] "Random text" returns low confidence and empty overrides

**Implementation Note**: After completing this phase and all automated verification passes, pause for manual confirmation before proceeding to Phase 2.

---

## Phase 2: Scenario Confirmation Dialog

### Overview
Create a confirmation dialog component that displays parsed scenario parameters with confidence scores and allows users to approve, modify, or cancel.

### Changes Required

#### 1. Confirmation Dialog Component
**File**: `src/components/scenarios/ScenarioConfirmation.tsx` (new file)

```typescript
'use client';

import { useState } from 'react';
import { Check, AlertTriangle, X, Edit2, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import type { ParsedScenario, ParsedScenarioField } from '@/lib/scenarios/types';

interface ScenarioConfirmationProps {
  scenario: ParsedScenario;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: (overrides: Record<string, number>) => void;
  onCancel: () => void;
  isApplying?: boolean;
}

function getConfidenceColor(confidence: number): string {
  if (confidence >= 0.8) return 'text-green-600 dark:text-green-400';
  if (confidence >= 0.5) return 'text-yellow-600 dark:text-yellow-400';
  return 'text-red-600 dark:text-red-400';
}

function getConfidenceIcon(confidence: number) {
  if (confidence >= 0.8) return <Check className="h-4 w-4 text-green-600" />;
  if (confidence >= 0.5) return <AlertTriangle className="h-4 w-4 text-yellow-600" />;
  return <X className="h-4 w-4 text-red-600" />;
}

export function ScenarioConfirmation({
  scenario,
  open,
  onOpenChange,
  onConfirm,
  onCancel,
  isApplying = false,
}: ScenarioConfirmationProps) {
  const [editingField, setEditingField] = useState<string | null>(null);
  const [editedOverrides, setEditedOverrides] = useState<Record<string, number>>(
    { ...scenario.overrides }
  );

  const handleFieldEdit = (key: string, value: string) => {
    const numValue = parseFloat(value);
    if (!isNaN(numValue)) {
      setEditedOverrides((prev) => ({ ...prev, [key]: numValue }));
    }
  };

  const handleConfirm = () => {
    onConfirm(editedOverrides);
  };

  const hasEdits = JSON.stringify(editedOverrides) !== JSON.stringify(scenario.overrides);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>Confirm Scenario</DialogTitle>
          <DialogDescription>
            I understood your question as: &ldquo;{scenario.originalQuery}&rdquo;
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-3 py-4">
          <p className="text-sm text-muted-foreground">
            I&apos;ll adjust these parameters:
          </p>

          <div className="space-y-2 rounded-lg border p-3">
            {scenario.fields.map((field) => (
              <div
                key={field.key}
                className="flex items-center justify-between gap-2"
              >
                <div className="flex items-center gap-2">
                  {getConfidenceIcon(field.confidence)}
                  <span className="font-medium">{field.label}:</span>
                </div>

                {editingField === field.key ? (
                  <Input
                    type="text"
                    className="h-7 w-24 text-right"
                    defaultValue={
                      field.key.includes('Rate') || field.key === 'expectedReturn'
                        ? (editedOverrides[field.key] * 100).toFixed(1)
                        : editedOverrides[field.key]
                    }
                    onBlur={(e) => {
                      let value = parseFloat(e.target.value);
                      if (field.key.includes('Rate') || field.key === 'expectedReturn') {
                        value = value / 100;
                      }
                      handleFieldEdit(field.key, String(value));
                      setEditingField(null);
                    }}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter') {
                        e.currentTarget.blur();
                      }
                    }}
                    autoFocus
                  />
                ) : (
                  <button
                    type="button"
                    onClick={() => setEditingField(field.key)}
                    className="flex items-center gap-1 rounded px-2 py-0.5 hover:bg-muted"
                  >
                    <span>{field.displayValue}</span>
                    <Edit2 className="h-3 w-3 text-muted-foreground" />
                  </button>
                )}

                <span className={`text-xs ${getConfidenceColor(field.confidence)}`}>
                  {Math.round(field.confidence * 100)}%
                </span>
              </div>
            ))}
          </div>

          {scenario.fields.some((f) => f.confidence < 0.8) && (
            <p className="text-xs text-muted-foreground">
              Lower confidence values may need manual adjustment. Click a value to edit.
            </p>
          )}
        </div>

        <DialogFooter className="gap-2 sm:gap-0">
          <Button variant="ghost" onClick={onCancel} disabled={isApplying}>
            Cancel
          </Button>
          <Button onClick={handleConfirm} disabled={isApplying}>
            {isApplying ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Applying...
              </>
            ) : (
              'Apply Scenario'
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

#### 2. Export from components
**File**: `src/components/scenarios/index.ts` (new file)

```typescript
export { ScenarioConfirmation } from './ScenarioConfirmation';
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Linting passes: `npm run lint`
- [x] New component exists: `src/components/scenarios/ScenarioConfirmation.tsx`

#### Manual Verification:
- [x] Dialog displays parsed parameters with confidence colors
- [x] Green check for high confidence (≥80%)
- [x] Yellow warning for medium confidence (50-79%)
- [x] Red X for low confidence (<50%)
- [x] Clicking a value enables inline editing
- [x] Cancel button closes dialog
- [x] Apply Scenario button triggers onConfirm callback

**Implementation Note**: After completing this phase and all automated verification passes, pause for manual confirmation before proceeding to Phase 3.

---

## Phase 3: Scenario Input Component

### Overview
Create the main scenario input component that ties together the text input, API call, and confirmation dialog.

### Changes Required

#### 1. Scenario Input Component
**File**: `src/components/scenarios/ScenarioInput.tsx` (new file)

```typescript
'use client';

import { useState, useCallback } from 'react';
import { Sparkles, Loader2, MessageSquare } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { ScenarioConfirmation } from './ScenarioConfirmation';
import type { ParsedScenario } from '@/lib/scenarios/types';
import type { Assumptions } from '@/components/projections/AssumptionsPanel';

interface ScenarioInputProps {
  currentAssumptions: Assumptions;
  onApply: (assumptions: Assumptions) => void;
  disabled?: boolean;
}

export function ScenarioInput({
  currentAssumptions,
  onApply,
  disabled = false,
}: ScenarioInputProps) {
  const [query, setQuery] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [parsedScenario, setParsedScenario] = useState<ParsedScenario | null>(null);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [isApplying, setIsApplying] = useState(false);

  const handleParse = useCallback(async () => {
    if (!query.trim()) return;

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/scenarios/parse', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query }),
      });

      const result = await response.json();

      if (!response.ok) {
        setError(result.error || 'Failed to parse scenario');
        return;
      }

      if (!result.data?.fields?.length) {
        setError('I couldn\'t identify any scenario parameters. Try something like "What if I retire at 65?"');
        return;
      }

      setParsedScenario(result.data);
      setShowConfirmation(true);
    } catch (err) {
      setError('Failed to connect. Please try again.');
    } finally {
      setIsLoading(false);
    }
  }, [query]);

  const handleConfirm = useCallback(
    (overrides: Record<string, number>) => {
      setIsApplying(true);

      // Map overrides to Assumptions format
      const newAssumptions: Assumptions = {
        expectedReturn: overrides.expectedReturn ?? currentAssumptions.expectedReturn,
        inflationRate: overrides.inflationRate ?? currentAssumptions.inflationRate,
        retirementAge: overrides.retirementAge ?? currentAssumptions.retirementAge,
      };

      // Call the parent's apply function
      onApply(newAssumptions);

      // Clean up
      setIsApplying(false);
      setShowConfirmation(false);
      setParsedScenario(null);
      setQuery('');
    },
    [currentAssumptions, onApply]
  );

  const handleCancel = useCallback(() => {
    setShowConfirmation(false);
    setParsedScenario(null);
  }, []);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleParse();
    }
  };

  return (
    <div className="space-y-3">
      <div className="flex items-center gap-2">
        <MessageSquare className="h-5 w-5 text-muted-foreground" />
        <span className="text-sm font-medium">Ask a &quot;What If&quot; Question</span>
      </div>

      <div className="flex gap-2">
        <Input
          placeholder='Try: "What if I retire at 65?" or "What if I get 7% returns?"'
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          onKeyDown={handleKeyDown}
          disabled={disabled || isLoading}
          className="flex-1"
        />
        <Button
          onClick={handleParse}
          disabled={disabled || isLoading || !query.trim()}
          size="default"
        >
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Parsing...
            </>
          ) : (
            <>
              <Sparkles className="mr-2 h-4 w-4" />
              Analyze
            </>
          )}
        </Button>
      </div>

      {error && (
        <p className="text-sm text-red-600 dark:text-red-400">{error}</p>
      )}

      {parsedScenario && (
        <ScenarioConfirmation
          scenario={parsedScenario}
          open={showConfirmation}
          onOpenChange={setShowConfirmation}
          onConfirm={handleConfirm}
          onCancel={handleCancel}
          isApplying={isApplying}
        />
      )}
    </div>
  );
}
```

#### 2. Update exports
**File**: `src/components/scenarios/index.ts`

```typescript
export { ScenarioConfirmation } from './ScenarioConfirmation';
export { ScenarioInput } from './ScenarioInput';
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Linting passes: `npm run lint`
- [x] New component exists: `src/components/scenarios/ScenarioInput.tsx`

#### Manual Verification:
- [x] Text input accepts natural language queries
- [x] Enter key triggers analysis
- [x] Loading state shows while parsing
- [x] Error message displays for failed parses
- [x] Confirmation dialog opens on successful parse
- [x] Apply triggers onApply callback with new assumptions
- [x] Cancel clears the parsed scenario
- [x] Input clears after successful apply

**Implementation Note**: After completing this phase and all automated verification passes, pause for manual confirmation before proceeding to Phase 4.

---

## Phase 4: Plans Page Integration

### Overview
Integrate the ScenarioInput component into the plans page, positioned above the main content grid.

### Changes Required

#### 1. Update PlansClient Component
**File**: `src/app/plans/plans-client.tsx`

**Add import** (after line 12):
```typescript
import { ScenarioInput } from '@/components/scenarios';
```

**Add scenario section** (insert after the inputWarnings alert block, before the mobile assumptions panel around line 205):

```typescript
      {/* Scenario Input Section */}
      <div className="rounded-lg border bg-card p-4 shadow-sm">
        <ScenarioInput
          currentAssumptions={assumptions}
          onApply={setAssumptions}
          disabled={isLoading}
        />
      </div>
```

The full context around line 205 should look like:

```typescript
      {/* Input Warnings */}
      {inputWarnings.length > 0 && !validationError && (
        <div className="space-y-2">
          {/* ... existing warnings code ... */}
        </div>
      )}

      {/* Scenario Input Section */}
      <div className="rounded-lg border bg-card p-4 shadow-sm">
        <ScenarioInput
          currentAssumptions={assumptions}
          onApply={setAssumptions}
          disabled={isLoading}
        />
      </div>

      {/* Mobile Assumptions Panel - Collapsible */}
      <div className="lg:hidden">
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Linting passes: `npm run lint`
- [x] Application builds successfully: `npm run build`

#### Manual Verification:
- [x] ScenarioInput appears on plans page above the grid
- [x] Typing "What if I retire at 65?" and clicking Analyze opens confirmation
- [x] Clicking "Apply Scenario" updates the projection
- [x] The chart and metrics reflect the new retirement age
- [x] The assumptions panel on the right shows the updated value
- [x] The scenario input is disabled while projection is loading
- [x] Works correctly on mobile view

**Implementation Note**: After completing this phase and all verification passes, the story is complete.

**STATUS**: ✅ **COMPLETE** - All phases implemented and verified successfully.

---

## Testing Strategy

### Unit Tests

**File**: `src/app/api/scenarios/parse/route.test.ts` (new file)

Test cases:
- Returns 401 for unauthenticated requests
- Returns 400 for empty query
- Returns 400 for non-string query
- Returns parsed overrides for valid scenario queries
- Returns low confidence for ambiguous queries
- Handles OpenAI API errors gracefully

### Integration Tests

Manual end-to-end scenarios:
1. **Happy path**: Enter "What if I retire at 65?" → Confirm → See projection update
2. **Multiple parameters**: "What if I retire at 62 with 7% returns?" → Both values parsed
3. **Edit before apply**: Parse → Edit a value → Apply → Correct value used
4. **Cancel flow**: Parse → Cancel → No changes to projection
5. **Invalid query**: "Hello world" → Error message displayed
6. **Network error**: Disconnect → Graceful error handling

### Manual Testing Steps

1. Navigate to `/plans` page
2. Verify ScenarioInput component is visible
3. Enter "What if I retire at 65?" in the input
4. Click "Analyze" or press Enter
5. Verify confirmation dialog shows `Retirement Age: Age 65` with high confidence
6. Click "Apply Scenario"
7. Verify:
   - Projection chart updates
   - Summary metrics change
   - Assumptions panel shows new retirement age
8. Try "What if I get 8% returns and retire at 60?"
9. Verify both parameters are parsed
10. Try editing a value in the confirmation dialog
11. Apply and verify the edited value is used

## Performance Considerations

- **OpenAI API latency**: gpt-4o-mini is fast (~500ms), but show loading state
- **Debouncing not needed**: Single submit action, not continuous typing
- **No caching**: Each query is unique, caching would have low hit rate

## Migration Notes

No database migrations required. All state is transient.

## References

- Original ticket: `thoughts/personal/tickets/epic-5/story-1-scope.md`
- Research document: `thoughts/shared/research/2026-01-13-ENG-5.1-scenario-projection-system.md`
- Smart-intake pattern: `src/components/onboarding/smart-intake.tsx:152-256`
- Projection override validation: `src/lib/validation/projections.ts:33-105`
- Plans page state management: `src/app/plans/plans-client.tsx:44-110`
