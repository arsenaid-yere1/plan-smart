# Delta-Based Explanation Implementation Plan

## Overview

Implement Story 5.2: Delta-Based Explanation for what-if scenarios. When a user applies a scenario (e.g., "What if I retire at 65?"), the system will generate an AI-powered explanation that describes what changed compared to their base plan, using quantified deltas rather than rewriting the full plan.

## Current State Analysis

### Existing Infrastructure

1. **Scenario Flow** ([ScenarioInput.tsx](src/components/scenarios/ScenarioInput.tsx)):
   - User enters natural language query
   - Query parsed via `/api/scenarios/parse`
   - Confirmation dialog shows parsed fields
   - On confirm, `onApply(newAssumptions)` updates parent state
   - **Gap**: No explanation of what changed after applying

2. **PlansClient State** ([plans-client.tsx:36-37](src/app/plans/plans-client.tsx#L36-L37)):
   - `assumptions`: Current active assumptions
   - `projection`: Current projection result
   - `initialProjection`: Server-rendered baseline (prop)
   - **Gap**: Base projection is lost when scenario is applied

3. **Delta Computation** ([staleness.ts:13-80](src/lib/projections/staleness.ts#L13-L80)):
   - `checkProjectionStaleness()` compares two `ProjectionInput` objects
   - Returns `{ changedFields, changes: { field: { previous, current } } }`
   - **Can be repurposed** for scenario comparison

4. **AI Infrastructure** ([plan-summary/route.ts](src/app/api/ai/plan-summary/route.ts)):
   - Uses OpenAI `gpt-4o-mini` with JSON response format
   - Retry logic with banned phrase validation
   - Temperature 0 for deterministic output
   - **Pattern to follow** for new endpoint

### Key Constraints

- Scenarios are ephemeral (not persisted to database)
- Explanation should be generated automatically after confirmation
- Base plan must remain untouched (display only, no modification suggestions)
- Must use quantified deltas ("Compared to your base plan...")

## Desired End State

After this implementation:

1. User enters a what-if scenario query
2. User confirms parsed fields in the dialog
3. System displays the scenario projection alongside the base projection
4. AI-generated explanation appears, describing:
   - What assumptions changed
   - How key metrics changed (retirement balance, fund depletion age)
   - Cause-and-effect relationships
5. User can dismiss the scenario to return to base plan

### Verification Criteria

- Explanation always starts with "Compared to your base plan..."
- Deltas are quantified (e.g., "+$127K", "-3 years")
- No prescriptive language (e.g., "you should", "you need to")
- Base projection metrics remain visible for comparison
- Reset returns to original base state

## What We're NOT Doing

- Persisting scenarios or explanations to database
- Allowing multiple stacked scenarios (one at a time only)
- Caching explanations (always generate fresh since scenarios are ephemeral)
- Side-by-side chart comparison (future enhancement)
- Modifying the base plan based on scenario results

## Implementation Approach

Use the recommended **client-side comparison** approach from the research document:
1. When scenario is confirmed, save base projection in state
2. Calculate scenario projection (existing flow)
3. Call new `/api/scenarios/explain` with both projections
4. Display explanation component below scenario input

This approach is simpler than server-side comparison and follows existing patterns.

---

## Phase 1: Create Delta Explanation Prompt & Types

### Overview
Create the AI prompt template and TypeScript types for delta-based explanations.

### Changes Required:

#### 1. Scenario Explanation Prompt
**File**: `src/lib/ai/prompts/scenario-explain.ts` (new file)

```typescript
/**
 * Banned phrases specific to scenario explanations.
 * These prevent the AI from suggesting changes to the base plan.
 */
export const SCENARIO_BANNED_PHRASES = [
  'you should',
  'you need to',
  'you must',
  'you have to',
  'consider changing',
  'i recommend',
  'i suggest',
  'update your plan',
  'modify your',
  'change your',
  'adjust your plan',
  'rewrite',
];

/**
 * System prompt for generating scenario delta explanations.
 */
export const SCENARIO_EXPLAIN_SYSTEM_PROMPT = `You are a financial planning assistant explaining how a "what-if" scenario affects a retirement projection.

Your task is to compare the scenario projection to the base plan and explain what changed and why.

STRICT RULES:
1. ALWAYS start with "Compared to your base plan..."
2. Use QUANTIFIED deltas with exact numbers:
   - For money: "+$50,000" or "-$127K" or "+$1.2M"
   - For years: "+3 years" or "-5 years"
   - For percentages: "+2%" or "-1.5%"
3. Explain CAUSE and EFFECT relationships
4. Keep the explanation under 150 words
5. NEVER suggest modifying the base plan
6. NEVER use prescriptive language like "you should" or "you need to"
7. Be factual and neutral in tone

OUTPUT FORMAT (JSON):
{
  "explanation": "Your 2-4 sentence explanation starting with 'Compared to your base plan...'",
  "keyChanges": [
    { "metric": "Retirement Balance", "delta": "+$127K", "direction": "positive" },
    { "metric": "Fund Depletion", "delta": "Never depletes", "direction": "positive" }
  ]
}

The "direction" field indicates whether the change is beneficial:
- "positive": The change is favorable (more money, funds last longer)
- "negative": The change is unfavorable (less money, funds deplete sooner)
- "neutral": The change is neither clearly good nor bad`;

/**
 * Builds the user message with base and scenario data for the AI.
 */
export function buildScenarioExplainUserMessage(
  baseMetrics: {
    retirementBalance: number;
    yearsUntilDepletion: number | null;
    retirementAge: number;
  },
  scenarioMetrics: {
    retirementBalance: number;
    yearsUntilDepletion: number | null;
    retirementAge: number;
  },
  changedFields: Array<{
    field: string;
    previous: unknown;
    current: unknown;
  }>
): string {
  const formatDepletion = (years: number | null) =>
    years === null ? 'Never (funds last through age 90+)' : `${years} years after retirement`;

  const fieldsDescription = changedFields
    .map((f) => `- ${f.field}: ${f.previous} â†’ ${f.current}`)
    .join('\n');

  return `BASE PLAN:
- Retirement Balance: $${baseMetrics.retirementBalance.toLocaleString()}
- Fund Depletion: ${formatDepletion(baseMetrics.yearsUntilDepletion)}
- Retirement Age: ${baseMetrics.retirementAge}

SCENARIO (What-If):
- Retirement Balance: $${scenarioMetrics.retirementBalance.toLocaleString()}
- Fund Depletion: ${formatDepletion(scenarioMetrics.yearsUntilDepletion)}
- Retirement Age: ${scenarioMetrics.retirementAge}

ASSUMPTIONS CHANGED:
${fieldsDescription}

Generate the comparison explanation.`;
}
```

#### 2. Scenario Types Extension
**File**: `src/lib/scenarios/types.ts`
**Changes**: Add new types for delta explanation

```typescript
// Add after existing types (line 25)

/**
 * Direction indicator for a metric change
 */
export type DeltaDirection = 'positive' | 'negative' | 'neutral';

/**
 * A single key change in the scenario comparison
 */
export interface KeyChange {
  metric: string;
  delta: string;
  direction: DeltaDirection;
}

/**
 * AI-generated explanation response
 */
export interface ScenarioExplanationResponse {
  explanation: string;
  keyChanges: KeyChange[];
}

/**
 * Full response from the explain API
 */
export interface ScenarioExplainApiResponse {
  success: boolean;
  data?: ScenarioExplanationResponse;
  error?: string;
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Linting passes: `npm run lint`
- [x] New files exist at expected paths

#### Manual Verification:
- [ ] Prompt text reads naturally and follows the rules
- [ ] Types cover all necessary fields

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 2.

---

## Phase 2: Create Explain API Endpoint

### Overview
Create the API endpoint that receives base and scenario projections, computes deltas, and generates the AI explanation.

### Changes Required:

#### 1. Explain API Route
**File**: `src/app/api/scenarios/explain/route.ts` (new file)

```typescript
import { NextResponse } from 'next/server';
import OpenAI from 'openai';
import { getServerUser } from '@/lib/auth/session';
import {
  SCENARIO_EXPLAIN_SYSTEM_PROMPT,
  SCENARIO_BANNED_PHRASES,
  buildScenarioExplainUserMessage,
} from '@/lib/ai/prompts/scenario-explain';
import type { ScenarioExplanationResponse } from '@/lib/scenarios/types';

interface ExplainRequestBody {
  baseProjection: {
    retirementBalance: number;
    yearsUntilDepletion: number | null;
    retirementAge: number;
  };
  scenarioProjection: {
    retirementBalance: number;
    yearsUntilDepletion: number | null;
    retirementAge: number;
  };
  changedFields: Array<{
    field: string;
    previous: unknown;
    current: unknown;
  }>;
}

/**
 * Validate response against banned phrases
 */
function validateExplanation(explanation: string): { valid: boolean; violations: string[] } {
  const lowerText = explanation.toLowerCase();
  const violations: string[] = [];

  for (const phrase of SCENARIO_BANNED_PHRASES) {
    if (lowerText.includes(phrase.toLowerCase())) {
      violations.push(phrase);
    }
  }

  return {
    valid: violations.length === 0,
    violations,
  };
}

export async function POST(request: Request) {
  try {
    // 1. Authenticate
    const user = await getServerUser();
    if (!user) {
      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
    }

    // 2. Parse and validate request body
    const body: ExplainRequestBody = await request.json();

    if (!body.baseProjection || !body.scenarioProjection || !body.changedFields) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // 3. Build the user message
    const userMessage = buildScenarioExplainUserMessage(
      body.baseProjection,
      body.scenarioProjection,
      body.changedFields
    );

    // 4. Call OpenAI with retry logic
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    const MAX_RETRIES = 2;
    let result: ScenarioExplanationResponse | null = null;
    let attempts = 0;

    while (attempts <= MAX_RETRIES && !result) {
      attempts++;

      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: SCENARIO_EXPLAIN_SYSTEM_PROMPT },
          { role: 'user', content: userMessage },
        ],
        response_format: { type: 'json_object' },
        temperature: 0,
        max_tokens: 512,
      });

      const content = completion.choices[0]?.message?.content;
      if (!content) {
        console.warn('Empty response from OpenAI on attempt', attempts);
        continue;
      }

      try {
        const parsed = JSON.parse(content) as ScenarioExplanationResponse;

        // Validate structure
        if (!parsed.explanation || !Array.isArray(parsed.keyChanges)) {
          console.warn('Invalid response structure on attempt', attempts);
          continue;
        }

        // Validate against banned phrases
        const validation = validateExplanation(parsed.explanation);
        if (!validation.valid) {
          console.warn('Banned phrases detected on attempt', attempts, validation.violations);
          continue;
        }

        // Validate explanation starts correctly
        if (!parsed.explanation.toLowerCase().startsWith('compared to your base plan')) {
          console.warn('Explanation does not start with required phrase on attempt', attempts);
          continue;
        }

        result = parsed;
      } catch (parseError) {
        console.warn('JSON parse error on attempt', attempts, parseError);
        continue;
      }
    }

    if (!result) {
      return NextResponse.json(
        { success: false, error: 'Failed to generate valid explanation after retries' },
        { status: 500 }
      );
    }

    // 5. Return success response
    return NextResponse.json({
      success: true,
      data: result,
    });
  } catch (error) {
    console.error('Scenario explain error:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Linting passes: `npm run lint`
- [x] API route file exists at `src/app/api/scenarios/explain/route.ts`

#### Manual Verification:
- [ ] API returns 401 when not authenticated
- [ ] API returns 400 for missing fields
- [ ] API returns valid explanation for valid input (test via curl or Postman)
- [ ] Explanation always starts with "Compared to your base plan..."

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 3.

---

## Phase 3: Create Explanation UI Component

### Overview
Create a React component to display the AI-generated scenario explanation with visual delta indicators.

### Changes Required:

#### 1. ScenarioExplanation Component
**File**: `src/components/scenarios/ScenarioExplanation.tsx` (new file)

```typescript
'use client';

import { TrendingUp, TrendingDown, Minus, X, RotateCcw } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import type { ScenarioExplanationResponse, DeltaDirection } from '@/lib/scenarios/types';
import { cn } from '@/lib/utils';

interface ScenarioExplanationProps {
  explanation: ScenarioExplanationResponse;
  onReset: () => void;
  isLoading?: boolean;
}

function DirectionIcon({ direction }: { direction: DeltaDirection }) {
  switch (direction) {
    case 'positive':
      return <TrendingUp className="h-4 w-4 text-success" />;
    case 'negative':
      return <TrendingDown className="h-4 w-4 text-destructive" />;
    case 'neutral':
      return <Minus className="h-4 w-4 text-muted-foreground" />;
  }
}

export function ScenarioExplanation({
  explanation,
  onReset,
  isLoading = false,
}: ScenarioExplanationProps) {
  return (
    <Card className="border-primary/20 bg-primary/5">
      <CardHeader className="pb-3">
        <div className="flex items-center justify-between">
          <CardTitle className="text-base font-medium flex items-center gap-2">
            <span className="text-primary">Scenario Active</span>
          </CardTitle>
          <Button
            variant="ghost"
            size="sm"
            onClick={onReset}
            disabled={isLoading}
            className="h-8 px-2 text-muted-foreground hover:text-foreground"
          >
            <RotateCcw className="h-4 w-4 mr-1" />
            Reset to Base
          </Button>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* AI Explanation */}
        <p className="text-sm text-foreground leading-relaxed">
          {explanation.explanation}
        </p>

        {/* Key Changes */}
        {explanation.keyChanges.length > 0 && (
          <div className="flex flex-wrap gap-2">
            {explanation.keyChanges.map((change, index) => (
              <div
                key={index}
                className={cn(
                  'inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full text-sm font-medium',
                  change.direction === 'positive' && 'bg-success/10 text-success',
                  change.direction === 'negative' && 'bg-destructive/10 text-destructive',
                  change.direction === 'neutral' && 'bg-muted text-muted-foreground'
                )}
              >
                <DirectionIcon direction={change.direction} />
                <span>{change.metric}:</span>
                <span className="font-semibold">{change.delta}</span>
              </div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```

#### 2. Update Scenarios Index Export
**File**: `src/components/scenarios/index.ts`
**Changes**: Add export for new component

```typescript
export { ScenarioInput } from './ScenarioInput';
export { ScenarioConfirmation } from './ScenarioConfirmation';
export { ScenarioExplanation } from './ScenarioExplanation';
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Linting passes: `npm run lint`
- [x] Component file exists at `src/components/scenarios/ScenarioExplanation.tsx`

#### Manual Verification:
- [ ] Component renders explanation text correctly
- [ ] Key changes display with correct colors (green/red/gray)
- [ ] Reset button is visible and styled appropriately
- [ ] Component is responsive on mobile

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 4.

---

## Phase 4: Integrate into PlansClient

### Overview
Modify PlansClient to track scenario state, preserve base projection, fetch explanations, and display the explanation component.

### Changes Required:

#### 1. PlansClient State Updates
**File**: `src/app/plans/plans-client.tsx`

**Add imports** (around line 13):
```typescript
import { ScenarioInput, ScenarioExplanation } from '@/components/scenarios';
import type { ScenarioExplanationResponse } from '@/lib/scenarios/types';
```

**Add new state variables** (after line 42):
```typescript
// Scenario state
const [isScenarioActive, setIsScenarioActive] = useState(false);
const [baseProjection, setBaseProjection] = useState<ProjectionResult | null>(null);
const [baseAssumptions, setBaseAssumptions] = useState<Assumptions | null>(null);
const [scenarioExplanation, setScenarioExplanation] = useState<ScenarioExplanationResponse | null>(null);
const [isExplanationLoading, setIsExplanationLoading] = useState(false);
```

**Add scenario apply handler** (after handleReset, around line 116):
```typescript
const handleScenarioApply = useCallback(
  async (newAssumptions: Assumptions) => {
    // 1. Save base state before applying scenario
    if (!isScenarioActive) {
      setBaseProjection(projection);
      setBaseAssumptions(assumptions);
    }

    // 2. Apply the new assumptions (triggers recalculation via useEffect)
    setAssumptions(newAssumptions);
    setIsScenarioActive(true);

    // Note: Explanation will be fetched after projection recalculates
  },
  [isScenarioActive, projection, assumptions]
);
```

**Add effect to fetch explanation after scenario projection calculates** (after the recalculation effect, around line 112):
```typescript
// Fetch scenario explanation when scenario projection is ready
useEffect(() => {
  if (!isScenarioActive || !baseProjection || !baseAssumptions || isLoading) {
    return;
  }

  const fetchExplanation = async () => {
    setIsExplanationLoading(true);

    try {
      // Build changed fields array
      const changedFields: Array<{ field: string; previous: unknown; current: unknown }> = [];

      if (baseAssumptions.expectedReturn !== assumptions.expectedReturn) {
        changedFields.push({
          field: 'Expected Return',
          previous: `${(baseAssumptions.expectedReturn * 100).toFixed(1)}%`,
          current: `${(assumptions.expectedReturn * 100).toFixed(1)}%`,
        });
      }
      if (baseAssumptions.inflationRate !== assumptions.inflationRate) {
        changedFields.push({
          field: 'Inflation Rate',
          previous: `${(baseAssumptions.inflationRate * 100).toFixed(1)}%`,
          current: `${(assumptions.inflationRate * 100).toFixed(1)}%`,
        });
      }
      if (baseAssumptions.retirementAge !== assumptions.retirementAge) {
        changedFields.push({
          field: 'Retirement Age',
          previous: baseAssumptions.retirementAge,
          current: assumptions.retirementAge,
        });
      }

      const response = await fetch('/api/scenarios/explain', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          baseProjection: {
            retirementBalance: baseProjection.summary.projectedRetirementBalance,
            yearsUntilDepletion: baseProjection.summary.yearsUntilDepletion,
            retirementAge: baseAssumptions.retirementAge,
          },
          scenarioProjection: {
            retirementBalance: projection.summary.projectedRetirementBalance,
            yearsUntilDepletion: projection.summary.yearsUntilDepletion,
            retirementAge: assumptions.retirementAge,
          },
          changedFields,
        }),
      });

      const result = await response.json();

      if (result.success && result.data) {
        setScenarioExplanation(result.data);
      } else {
        console.error('Failed to fetch scenario explanation:', result.error);
      }
    } catch (error) {
      console.error('Error fetching scenario explanation:', error);
    } finally {
      setIsExplanationLoading(false);
    }
  };

  fetchExplanation();
}, [isScenarioActive, baseProjection, baseAssumptions, projection, assumptions, isLoading]);
```

**Add scenario reset handler** (after handleScenarioApply):
```typescript
const handleScenarioReset = useCallback(() => {
  if (baseAssumptions) {
    setAssumptions(baseAssumptions);
  }
  setIsScenarioActive(false);
  setBaseProjection(null);
  setBaseAssumptions(null);
  setScenarioExplanation(null);
}, [baseAssumptions]);
```

**Update ScenarioInput usage** (around line 209):
```typescript
<ScenarioInput
  currentAssumptions={assumptions}
  onApply={handleScenarioApply}  // Changed from setAssumptions
  disabled={isLoading}
/>
```

**Add ScenarioExplanation component** (after ScenarioInput section, around line 214):
```typescript
{/* Scenario Explanation */}
{isScenarioActive && (scenarioExplanation || isExplanationLoading) && (
  <div className="rounded-lg border shadow-sm">
    {isExplanationLoading ? (
      <div className="p-4 flex items-center gap-2 text-muted-foreground">
        <Loader2 className="h-4 w-4 animate-spin" />
        <span className="text-sm">Analyzing scenario impact...</span>
      </div>
    ) : scenarioExplanation ? (
      <ScenarioExplanation
        explanation={scenarioExplanation}
        onReset={handleScenarioReset}
      />
    ) : null}
  </div>
)}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Linting passes: `npm run lint`
- [x] Build succeeds: `npm run build`

#### Manual Verification:
- [ ] Enter scenario query (e.g., "What if I retire at 65?")
- [ ] Confirm parsed fields in dialog
- [ ] Scenario explanation appears with "Compared to your base plan..."
- [ ] Key changes show with colored indicators
- [ ] "Reset to Base" button returns to original projection
- [ ] New scenario after reset works correctly
- [ ] Loading state shows "Analyzing scenario impact..."

**Implementation Note**: After completing this phase and all automated verification passes, the feature is complete.

---

## Testing Strategy

### Unit Tests:
- `scenario-explain.ts`: Test `buildScenarioExplainUserMessage()` output format
- `validateExplanation()`: Test banned phrase detection

### Integration Tests:
- `/api/scenarios/explain`: Test authentication, validation, and response format
- Mock OpenAI responses to test retry logic

### Manual Testing Steps:
1. Navigate to /plans page
2. Enter "What if I retire at 62?" in scenario input
3. Confirm the parsed retirement age
4. Verify explanation appears with quantified deltas
5. Click "Reset to Base" and verify original projection restored
6. Try multiple scenarios in sequence
7. Test on mobile viewport

## Performance Considerations

- Explanation fetches only after projection calculation completes (no duplicate calls)
- No caching needed since scenarios are ephemeral
- OpenAI call uses `max_tokens: 512` (smaller than plan summary)
- Retry logic limited to 2 retries to prevent excessive API calls

## Migration Notes

No database migrations required. This feature is entirely client-side with a new API endpoint.

## References

- Original ticket: [thoughts/personal/tickets/epic-5/story-2-scope.md](thoughts/personal/tickets/epic-5/story-2-scope.md)
- Research document: [thoughts/shared/research/2026-01-14-ENG-5.2-delta-based-explanation.md](thoughts/shared/research/2026-01-14-ENG-5.2-delta-based-explanation.md)
- Story 5.1 plan: [thoughts/shared/plans/2026-01-13-ENG-5.1-scenario-parsing-confirmation.md](thoughts/shared/plans/2026-01-13-ENG-5.1-scenario-parsing-confirmation.md)
- Staleness utility: [src/lib/projections/staleness.ts](src/lib/projections/staleness.ts)
- AI summary pattern: [src/app/api/ai/plan-summary/route.ts](src/app/api/ai/plan-summary/route.ts)
