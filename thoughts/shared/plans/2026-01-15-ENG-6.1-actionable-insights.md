# Epic 6 Story 1 - Actionable Insights Implementation Plan

## Overview

Implement three features that help users understand their retirement projection sensitivity:
1. **Top 3 Levers**: Identify which input parameters have the largest impact on retirement outcomes
2. **Low-Friction Wins**: Surface small changes that produce outsized effects
3. **Assumption Sensitivity**: Explain which assumptions the projection depends on most

Key principle: **Computation happens algorithmically; AI only narrates results.** This ensures insights are reproducible, auditable, and don't cross into financial advice territory.

## Current State Analysis

### Existing Infrastructure
- **Projection Engine** ([engine.ts:117-240](src/lib/projections/engine.ts#L117-L240)): `runProjection()` is synchronous and optimized for < 100ms execution
- **Input Builder** ([input-builder.ts:32-101](src/lib/projections/input-builder.ts#L32-L101)): `buildProjectionInputFromSnapshot()` constructs `ProjectionInput` from database snapshot with overrides support
- **AI Prompts** ([scenario-explain.ts](src/lib/ai/prompts/scenario-explain.ts)): Established pattern for guardrailed AI explanations with banned phrases
- **Response Validation** ([validate-response.ts](src/lib/ai/validate-response.ts)): `validateAgainstBannedPhrases()` for content guardrails
- **UI Components**: Card, Skeleton, and badge patterns in shadcn/ui

### What's Missing
- No sensitivity analysis engine
- No low-friction wins detection
- No assumption sensitivity quantification
- No UI components for displaying insights

## Desired End State

After implementation:
1. Users see a new "Insights" section on the plans page (below the chart)
2. Three cards display: Top Levers, Quick Wins, and Assumption Sensitivity
3. Each card includes algorithmically computed metrics with AI-generated narrative
4. All AI text uses observational language (no prescriptive advice)

### Verification Criteria
- `npm run build` passes with no TypeScript errors
- `npm run lint` passes
- Insights API returns valid sensitivity analysis results
- AI explanations pass banned phrase validation
- UI renders correctly on desktop (3-column grid) and mobile (single column)

## What We're NOT Doing

- **NOT** suggesting specific financial products or investments
- **NOT** providing personalized financial advice
- **NOT** storing sensitivity analysis results in database (computed on-demand)
- **NOT** implementing caching for sensitivity results (may add later if needed)
- **NOT** showing insights during active scenario mode
- **NOT** adding new onboarding steps or data collection

---

## Implementation Approach

We'll implement in four phases:
1. **Phase 1**: Sensitivity analysis engine (core computation)
2. **Phase 2**: API endpoint with AI explanation generation
3. **Phase 3**: UI components for displaying insights
4. **Phase 4**: Integration into the plans page

---

## Phase 1: Sensitivity Analysis Engine

### Overview
Create the core computation engine that runs multiple projections with parameter variations to identify the most impactful levers.

### Changes Required

#### 1. Create Sensitivity Types
**File**: `src/lib/projections/sensitivity-types.ts` (NEW)

```typescript
import type { ProjectionInput } from './types';

/**
 * Result of varying a single lever
 */
export interface LeverImpact {
  lever: keyof ProjectionInput;
  displayName: string;
  currentValue: number;
  testDelta: number;
  testDirection: 'increase' | 'decrease';
  impactOnBalance: number;
  impactOnDepletion: number | null;
  percentImpact: number;
}

/**
 * Complete sensitivity analysis result
 */
export interface SensitivityResult {
  topLevers: LeverImpact[];
  baselineBalance: number;
  baselineDepletion: number | null;
  analysisTimestamp: Date;
}

/**
 * Low-friction win opportunity
 */
export interface LowFrictionWin {
  id: string;
  title: string;
  description: string;
  effortLevel: 'minimal' | 'low' | 'moderate';
  potentialImpact: number;
  impactDescription: string;
  uncertaintyCaveat: string;
  lever: string;
  delta: number;
}

/**
 * Sensitive assumption with review guidance
 */
export interface SensitiveAssumption {
  assumption: string;
  displayName: string;
  currentValue: number;
  formattedValue: string;
  sensitivityScore: number;
  explanation: string;
  reviewSuggestion: string;
}

/**
 * Combined insights response from API
 */
export interface InsightsResponse {
  topLevers: LeverImpact[];
  leverExplanation: string;
  lowFrictionWins: LowFrictionWin[];
  sensitiveAssumptions: SensitiveAssumption[];
  sensitivityExplanation: string;
  baseline: {
    balance: number;
    depletion: number | null;
  };
}
```

#### 2. Create Sensitivity Analysis Engine
**File**: `src/lib/projections/sensitivity.ts` (NEW)

```typescript
import { runProjection } from './engine';
import type { ProjectionInput } from './types';
import type { LeverImpact, SensitivityResult, LowFrictionWin, SensitiveAssumption } from './sensitivity-types';

/**
 * Lever test configuration
 */
interface LeverTest {
  lever: keyof ProjectionInput;
  displayName: string;
  delta: number | ((input: ProjectionInput) => number);
  direction: 'increase' | 'decrease';
}

/**
 * Standard lever tests to evaluate
 */
const LEVER_TESTS: LeverTest[] = [
  {
    lever: 'expectedReturn',
    displayName: 'Expected Return',
    delta: 0.01, // 1 percentage point
    direction: 'increase',
  },
  {
    lever: 'inflationRate',
    displayName: 'Inflation Rate',
    delta: 0.005, // 0.5 percentage point
    direction: 'decrease',
  },
  {
    lever: 'retirementAge',
    displayName: 'Retirement Age',
    delta: 1, // 1 year
    direction: 'increase',
  },
  {
    lever: 'annualContribution',
    displayName: 'Annual Savings',
    delta: (input) => input.annualContribution * 0.1, // 10% increase
    direction: 'increase',
  },
  {
    lever: 'annualExpenses',
    displayName: 'Annual Expenses',
    delta: (input) => input.annualExpenses * 0.1, // 10% decrease
    direction: 'decrease',
  },
  {
    lever: 'annualHealthcareCosts',
    displayName: 'Healthcare Costs',
    delta: 1000, // $1,000 decrease
    direction: 'decrease',
  },
];

/**
 * Calculate depletion delta in years
 */
function calculateDepletionDelta(
  baseDepletion: number | null,
  modifiedDepletion: number | null
): number | null {
  if (baseDepletion === null && modifiedDepletion === null) {
    return null; // Both sustainable
  }
  if (baseDepletion === null) {
    return modifiedDepletion; // Base was sustainable, now depletes
  }
  if (modifiedDepletion === null) {
    return null; // Now sustainable (improvement)
  }
  return modifiedDepletion - baseDepletion;
}

/**
 * Run sensitivity analysis on projection inputs
 */
export function analyzeSensitivity(baseInput: ProjectionInput): SensitivityResult {
  // Run base projection
  const baseResult = runProjection(baseInput);
  const baseBalance = baseResult.summary.projectedRetirementBalance;
  const baseDepletion = baseResult.summary.yearsUntilDepletion;

  const impacts: LeverImpact[] = [];

  // Test each lever
  for (const test of LEVER_TESTS) {
    // Skip if lever doesn't apply (e.g., no contributions to increase)
    const currentValue = baseInput[test.lever];
    if (typeof currentValue !== 'number') continue;
    if (test.lever === 'annualContribution' && currentValue === 0) continue;
    if (test.lever === 'annualExpenses' && currentValue === 0) continue;

    // Calculate test delta
    const testDelta = typeof test.delta === 'function'
      ? test.delta(baseInput)
      : test.delta;

    // Create modified input
    const modifiedInput = { ...baseInput };
    const newValue = test.direction === 'increase'
      ? currentValue + testDelta
      : currentValue - testDelta;

    // Type assertion needed for computed property assignment
    (modifiedInput as Record<string, unknown>)[test.lever] = newValue;

    // Run modified projection
    const modifiedResult = runProjection(modifiedInput as ProjectionInput);

    const impactOnBalance = modifiedResult.summary.projectedRetirementBalance - baseBalance;
    const impactOnDepletion = calculateDepletionDelta(
      baseDepletion,
      modifiedResult.summary.yearsUntilDepletion
    );

    impacts.push({
      lever: test.lever,
      displayName: test.displayName,
      currentValue,
      testDelta,
      testDirection: test.direction,
      impactOnBalance,
      impactOnDepletion,
      percentImpact: baseBalance > 0
        ? Math.abs(impactOnBalance / baseBalance) * 100
        : 0,
    });
  }

  // Sort by absolute impact and take top 3
  const topLevers = impacts
    .sort((a, b) => Math.abs(b.impactOnBalance) - Math.abs(a.impactOnBalance))
    .slice(0, 3);

  return {
    topLevers,
    baselineBalance: baseBalance,
    baselineDepletion: baseDepletion,
    analysisTimestamp: new Date(),
  };
}

/**
 * Identify low-friction wins from sensitivity results
 */
export function identifyLowFrictionWins(
  baseInput: ProjectionInput,
  sensitivityResult: SensitivityResult
): LowFrictionWin[] {
  const wins: LowFrictionWin[] = [];
  const baseResult = runProjection(baseInput);
  const baseBalance = baseResult.summary.projectedRetirementBalance;

  // Win 1: Retire 1 year later (if under 70)
  if (baseInput.retirementAge < 70) {
    const laterRetirement = { ...baseInput, retirementAge: baseInput.retirementAge + 1 };
    const result = runProjection(laterRetirement);
    const impact = result.summary.projectedRetirementBalance - baseBalance;

    if (impact > 10000) {
      wins.push({
        id: 'retire-one-year-later',
        title: 'One additional working year',
        description: `Working until age ${baseInput.retirementAge + 1} instead of ${baseInput.retirementAge}`,
        effortLevel: 'moderate',
        potentialImpact: impact,
        impactDescription: `adds approximately ${formatCurrency(impact)} to retirement funds`,
        uncertaintyCaveat: 'Assumes continued employment and contribution levels',
        lever: 'retirementAge',
        delta: 1,
      });
    }
  }

  // Win 2: 5% expense reduction
  const expenseReduction = baseInput.annualExpenses * 0.05;
  if (expenseReduction > 0) {
    const reducedExpenses = { ...baseInput, annualExpenses: baseInput.annualExpenses - expenseReduction };
    const expenseResult = runProjection(reducedExpenses);
    const expenseImpact = expenseResult.summary.projectedRetirementBalance - baseBalance;

    if (expenseImpact > 5000) {
      wins.push({
        id: 'reduce-expenses-5pct',
        title: 'Modest expense reduction',
        description: `Reducing annual expenses by ${formatCurrency(expenseReduction)}/year (5%)`,
        effortLevel: 'low',
        potentialImpact: expenseImpact,
        impactDescription: `frees up approximately ${formatCurrency(expenseImpact)} for retirement`,
        uncertaintyCaveat: 'Based on current expense levels; actual savings may vary',
        lever: 'annualExpenses',
        delta: expenseReduction,
      });
    }
  }

  // Win 3: 10% savings increase (if currently contributing)
  if (baseInput.annualContribution > 0) {
    const contributionIncrease = baseInput.annualContribution * 0.10;
    const increasedContribution = { ...baseInput, annualContribution: baseInput.annualContribution + contributionIncrease };
    const contributionResult = runProjection(increasedContribution);
    const contributionImpact = contributionResult.summary.projectedRetirementBalance - baseBalance;

    if (contributionImpact > 5000) {
      wins.push({
        id: 'increase-savings-10pct',
        title: 'Incremental savings boost',
        description: `Saving an additional ${formatCurrency(contributionIncrease)}/year (10% increase)`,
        effortLevel: 'low',
        potentialImpact: contributionImpact,
        impactDescription: `grows to approximately ${formatCurrency(contributionImpact)} by retirement`,
        uncertaintyCaveat: 'Assumes consistent contribution over time; market returns may vary',
        lever: 'annualContribution',
        delta: contributionIncrease,
      });
    }
  }

  // Sort by impact and return top 3
  return wins
    .sort((a, b) => b.potentialImpact - a.potentialImpact)
    .slice(0, 3);
}

/**
 * Identify sensitive assumptions from analysis results
 */
export function identifySensitiveAssumptions(
  input: ProjectionInput,
  sensitivityResult: SensitivityResult
): SensitiveAssumption[] {
  const assumptions: SensitiveAssumption[] = [];
  const maxImpact = Math.max(
    ...sensitivityResult.topLevers.map(l => Math.abs(l.impactOnBalance)),
    1 // Avoid division by zero
  );

  // Take top 2 most sensitive levers
  for (const lever of sensitivityResult.topLevers.slice(0, 2)) {
    const sensitivityScore = Math.round((Math.abs(lever.impactOnBalance) / maxImpact) * 100);

    assumptions.push({
      assumption: lever.lever,
      displayName: lever.displayName,
      currentValue: lever.currentValue,
      formattedValue: formatAssumptionValue(lever.lever, lever.currentValue),
      sensitivityScore,
      explanation: generateAssumptionExplanation(lever),
      reviewSuggestion: getReviewSuggestion(lever.lever),
    });
  }

  return assumptions;
}

/**
 * Format currency for display
 */
function formatCurrency(value: number): string {
  if (value >= 1_000_000) return `$${(value / 1_000_000).toFixed(1)}M`;
  if (value >= 1_000) return `$${Math.round(value / 1_000)}K`;
  return `$${Math.round(value)}`;
}

/**
 * Format assumption value for display
 */
function formatAssumptionValue(lever: string, value: number): string {
  switch (lever) {
    case 'expectedReturn':
    case 'inflationRate':
    case 'healthcareInflationRate':
    case 'contributionGrowthRate':
      return `${(value * 100).toFixed(1)}%`;
    case 'retirementAge':
    case 'maxAge':
      return `Age ${value}`;
    case 'annualContribution':
    case 'annualExpenses':
    case 'annualHealthcareCosts':
      return formatCurrency(value);
    default:
      return String(value);
  }
}

/**
 * Format delta value for display
 */
export function formatDeltaValue(lever: string, delta: number): string {
  switch (lever) {
    case 'expectedReturn':
    case 'inflationRate':
    case 'healthcareInflationRate':
    case 'contributionGrowthRate':
      return `${(delta * 100).toFixed(1)}%`;
    case 'retirementAge':
    case 'maxAge':
      return `${delta} year${delta !== 1 ? 's' : ''}`;
    case 'annualContribution':
    case 'annualExpenses':
    case 'annualHealthcareCosts':
      return formatCurrency(delta);
    default:
      return String(delta);
  }
}

/**
 * Generate explanation for a sensitive assumption
 */
function generateAssumptionExplanation(lever: LeverImpact): string {
  const direction = lever.impactOnBalance > 0 ? 'higher' : 'lower';
  const absImpact = Math.abs(lever.impactOnBalance);
  const deltaFormatted = formatDeltaValue(lever.lever, lever.testDelta);

  return `A ${deltaFormatted} ${lever.testDirection} in ${lever.displayName.toLowerCase()} results in approximately ${formatCurrency(absImpact)} ${direction} retirement balance.`;
}

/**
 * Get review suggestion for a lever
 */
function getReviewSuggestion(lever: string): string {
  const suggestions: Record<string, string> = {
    expectedReturn: 'Review annually based on portfolio allocation and market conditions',
    inflationRate: 'Consider updating if inflation trends significantly change',
    retirementAge: 'Revisit as career plans evolve',
    annualContribution: 'Update when income or expenses change meaningfully',
    annualExpenses: 'Refresh after major life changes or annual budget review',
    annualHealthcareCosts: 'Review as healthcare needs or coverage changes',
    healthcareInflationRate: 'Monitor healthcare cost trends periodically',
    contributionGrowthRate: 'Adjust based on expected career trajectory',
    maxAge: 'Consider family health history and lifestyle factors',
  };

  return suggestions[lever] || 'Review periodically as circumstances change';
}
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compiles with no errors: `npm run build`
- [x] Linting passes: `npm run lint`
- [x] Unit tests pass: `npm test -- --testPathPattern=sensitivity`

#### Manual Verification:
- [ ] `analyzeSensitivity()` returns 3 levers sorted by absolute impact
- [ ] `identifyLowFrictionWins()` correctly calculates win impacts
- [ ] `identifySensitiveAssumptions()` returns formatted assumption info

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 2.

---

## Phase 2: API Endpoint with AI Explanation

### Overview
Create API endpoint that runs sensitivity analysis and generates AI explanations using established guardrail patterns.

### Changes Required

#### 1. Create Insights Banned Phrases
**File**: `src/lib/ai/prompts/insights-explain.ts` (NEW)

```typescript
/**
 * Banned phrases for insights explanations.
 * Prevents prescriptive language while allowing observational statements.
 */
export const INSIGHTS_BANNED_PHRASES = [
  'you should',
  'you need to',
  'you must',
  'you have to',
  'consider changing',
  'i recommend',
  'i suggest',
  'focus on',
  'prioritize',
  'take action',
  'immediately',
  'urgently',
];

/**
 * System prompt for lever explanation generation
 */
export const LEVER_EXPLANATION_SYSTEM_PROMPT = `You explain retirement projection sensitivity analysis results.

CRITICAL RULES:
1. NEVER use prescriptive language ("you should", "you need to", "consider")
2. Use ONLY observational language ("has the biggest effect", "shows the largest impact")
3. Include quantified impacts from the data provided
4. Keep explanations factual and bounded to the analysis

FORMAT:
- Lead with the #1 lever and its quantified impact
- Briefly mention the other top factors
- Keep to 2-3 sentences total

EXAMPLE:
"Expected return has the biggest effect on your projected retirement balance. A 1% higher return would add approximately $127,000 to your retirement funds. Your retirement age and annual savings also show meaningful impact on long-term outcomes."

OUTPUT FORMAT (JSON):
{
  "explanation": "Your 2-3 sentence explanation using observational language only."
}`;

/**
 * System prompt for sensitivity explanation generation
 */
export const SENSITIVITY_EXPLANATION_SYSTEM_PROMPT = `You explain which assumptions a retirement projection is most sensitive to.

CRITICAL RULES:
1. Use observational language ONLY ("your projection depends heavily on", "shows sensitivity to")
2. NEVER suggest immediate action or changes
3. Encourage periodic review, not urgent response
4. Include the quantified sensitivity from the data
5. Frame as informational awareness, not advice

TONE:
- Educational and calm
- Forward-looking but not alarming
- Emphasize understanding over action

EXAMPLE:
"Your projection shows the most sensitivity to expected investment returns and retirement timing. The return assumption has a particularly large influence—variations of 1% translate to significant differences in projected outcomes. These assumptions are worth revisiting periodically as market conditions and your plans evolve."

OUTPUT FORMAT (JSON):
{
  "explanation": "Your 2-3 sentence explanation using observational language only."
}`;

/**
 * Build user message for lever explanation
 */
export function buildLeverUserMessage(
  levers: Array<{
    displayName: string;
    testDirection: string;
    testDelta: number;
    impactOnBalance: number;
  }>,
  formatDelta: (lever: string, delta: number) => string,
  formatCurrency: (value: number) => string,
  baselineBalance: number,
  baselineDepletion: number | null
): string {
  const leverDescriptions = levers.map((lever, index) =>
    `${index + 1}. ${lever.displayName}: ${lever.testDirection === 'increase' ? '+' : '-'}${formatDelta(lever.displayName.toLowerCase().replace(/ /g, ''), lever.testDelta)} → ${formatCurrency(lever.impactOnBalance)} impact on retirement balance`
  ).join('\n');

  const depletionText = baselineDepletion === null
    ? 'Never (sustainable)'
    : `${baselineDepletion} years after retirement`;

  return `TOP 3 LEVERS BY IMPACT:
${leverDescriptions}

BASELINE:
- Retirement Balance: ${formatCurrency(baselineBalance)}
- Fund Depletion: ${depletionText}

Generate a 2-3 sentence explanation of these findings using observational language only.`;
}

/**
 * Build user message for sensitivity explanation
 */
export function buildSensitivityUserMessage(
  assumptions: Array<{
    displayName: string;
    formattedValue: string;
    sensitivityScore: number;
    explanation: string;
  }>
): string {
  const assumptionDescriptions = assumptions.map((a, index) =>
    `${index + 1}. ${a.displayName} (Current: ${a.formattedValue}, Sensitivity: ${a.sensitivityScore}%)\n   ${a.explanation}`
  ).join('\n\n');

  return `MOST SENSITIVE ASSUMPTIONS:
${assumptionDescriptions}

Generate a 2-3 sentence explanation about these sensitivity findings. Encourage periodic review rather than immediate action.`;
}
```

#### 2. Create Insights Validation
**File**: `src/lib/ai/validate-insights.ts` (NEW)

```typescript
import { INSIGHTS_BANNED_PHRASES } from './prompts/insights-explain';

export interface InsightsValidationResult {
  valid: boolean;
  violations: string[];
}

/**
 * Validate insights explanation against banned phrases
 */
export function validateInsightsExplanation(text: string): InsightsValidationResult {
  const lowerText = text.toLowerCase();
  const violations: string[] = [];

  for (const phrase of INSIGHTS_BANNED_PHRASES) {
    if (lowerText.includes(phrase.toLowerCase())) {
      violations.push(phrase);
    }
  }

  return {
    valid: violations.length === 0,
    violations,
  };
}
```

#### 3. Create Insights API Endpoint
**File**: `src/app/api/insights/analyze/route.ts` (NEW)

```typescript
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { getServerUser } from '@/lib/auth/server';
import { db } from '@/db';
import { financialSnapshot } from '@/db/schema/financial-snapshot';
import { eq } from 'drizzle-orm';
import { buildProjectionInputFromSnapshot } from '@/lib/projections/input-builder';
import {
  analyzeSensitivity,
  identifyLowFrictionWins,
  identifySensitiveAssumptions,
  formatDeltaValue,
} from '@/lib/projections/sensitivity';
import type { InsightsResponse } from '@/lib/projections/sensitivity-types';
import {
  LEVER_EXPLANATION_SYSTEM_PROMPT,
  SENSITIVITY_EXPLANATION_SYSTEM_PROMPT,
  buildLeverUserMessage,
  buildSensitivityUserMessage,
} from '@/lib/ai/prompts/insights-explain';
import { validateInsightsExplanation } from '@/lib/ai/validate-insights';

const MAX_RETRIES = 2;

/**
 * Format currency for display
 */
function formatCurrency(value: number): string {
  if (value >= 1_000_000) return `$${(value / 1_000_000).toFixed(1)}M`;
  if (value >= 1_000) return `$${Math.round(value / 1_000)}K`;
  return `$${Math.round(value)}`;
}

export async function POST(request: NextRequest) {
  try {
    // Authenticate
    const user = await getServerUser();
    if (!user) {
      return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
    }

    // Get financial snapshot
    const [snapshot] = await db
      .select()
      .from(financialSnapshot)
      .where(eq(financialSnapshot.userId, user.id))
      .limit(1);

    if (!snapshot) {
      return NextResponse.json(
        { message: 'Financial snapshot not found. Please complete onboarding.' },
        { status: 404 }
      );
    }

    // Build projection input
    const input = buildProjectionInputFromSnapshot(snapshot, {});

    // Run sensitivity analysis
    const sensitivityResult = analyzeSensitivity(input);

    // Identify low-friction wins
    const lowFrictionWins = identifyLowFrictionWins(input, sensitivityResult);

    // Identify sensitive assumptions
    const sensitiveAssumptions = identifySensitiveAssumptions(input, sensitivityResult);

    // Check if OpenAI is configured
    if (!process.env.OPENAI_API_KEY) {
      // Return results without AI explanations
      return NextResponse.json({
        topLevers: sensitivityResult.topLevers,
        leverExplanation: '',
        lowFrictionWins,
        sensitiveAssumptions,
        sensitivityExplanation: '',
        baseline: {
          balance: sensitivityResult.baselineBalance,
          depletion: sensitivityResult.baselineDepletion,
        },
      } satisfies InsightsResponse);
    }

    const openai = new OpenAI();

    // Generate lever explanation
    let leverExplanation = '';
    const leverUserMessage = buildLeverUserMessage(
      sensitivityResult.topLevers,
      formatDeltaValue,
      formatCurrency,
      sensitivityResult.baselineBalance,
      sensitivityResult.baselineDepletion
    );

    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
      try {
        const leverCompletion = await openai.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: LEVER_EXPLANATION_SYSTEM_PROMPT },
            { role: 'user', content: leverUserMessage },
          ],
          response_format: { type: 'json_object' },
          temperature: 0,
          max_tokens: 256,
        });

        const leverContent = leverCompletion.choices[0]?.message?.content;
        if (!leverContent) continue;

        const leverParsed = JSON.parse(leverContent) as { explanation: string };
        const validation = validateInsightsExplanation(leverParsed.explanation);

        if (validation.valid) {
          leverExplanation = leverParsed.explanation;
          break;
        } else {
          console.warn('Lever explanation validation failed:', validation.violations);
        }
      } catch (error) {
        console.error('Lever explanation generation error:', error);
      }
    }

    // Generate sensitivity explanation
    let sensitivityExplanation = '';
    const sensitivityUserMessage = buildSensitivityUserMessage(sensitiveAssumptions);

    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
      try {
        const sensitivityCompletion = await openai.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: SENSITIVITY_EXPLANATION_SYSTEM_PROMPT },
            { role: 'user', content: sensitivityUserMessage },
          ],
          response_format: { type: 'json_object' },
          temperature: 0,
          max_tokens: 256,
        });

        const sensitivityContent = sensitivityCompletion.choices[0]?.message?.content;
        if (!sensitivityContent) continue;

        const sensitivityParsed = JSON.parse(sensitivityContent) as { explanation: string };
        const validation = validateInsightsExplanation(sensitivityParsed.explanation);

        if (validation.valid) {
          sensitivityExplanation = sensitivityParsed.explanation;
          break;
        } else {
          console.warn('Sensitivity explanation validation failed:', validation.violations);
        }
      } catch (error) {
        console.error('Sensitivity explanation generation error:', error);
      }
    }

    return NextResponse.json({
      topLevers: sensitivityResult.topLevers,
      leverExplanation,
      lowFrictionWins,
      sensitiveAssumptions,
      sensitivityExplanation,
      baseline: {
        balance: sensitivityResult.baselineBalance,
        depletion: sensitivityResult.baselineDepletion,
      },
    } satisfies InsightsResponse);
  } catch (error) {
    console.error('Insights analysis error:', error);
    return NextResponse.json(
      { message: 'Failed to analyze insights' },
      { status: 500 }
    );
  }
}
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compiles: `npm run build`
- [x] Linting passes: `npm run lint`
- [ ] API endpoint responds to POST: `curl -X POST http://localhost:3000/api/insights/analyze`

#### Manual Verification:
- [ ] API returns sensitivity analysis with top 3 levers
- [ ] AI explanations are generated (when OpenAI key configured)
- [ ] Banned phrases are rejected during validation
- [ ] Response matches `InsightsResponse` type structure

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 3.

---

## Phase 3: UI Components

### Overview
Create React components to display insights using established card and badge patterns.

### Changes Required

#### 1. Create TopLeversCard Component
**File**: `src/components/insights/TopLeversCard.tsx` (NEW)

```typescript
'use client';

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { TrendingUp } from 'lucide-react';
import { cn } from '@/lib/utils';
import type { LeverImpact } from '@/lib/projections/sensitivity-types';
import { formatDeltaValue } from '@/lib/projections/sensitivity';

interface TopLeversCardProps {
  levers: LeverImpact[];
  explanation: string;
  isLoading?: boolean;
}

function formatCurrency(value: number): string {
  if (value >= 1_000_000) return `$${(value / 1_000_000).toFixed(1)}M`;
  if (value >= 1_000) return `$${Math.round(value / 1_000)}K`;
  return `$${Math.round(value)}`;
}

export function TopLeversCard({ levers, explanation, isLoading }: TopLeversCardProps) {
  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <TrendingUp className="h-5 w-5 animate-pulse" />
            Analyzing Key Factors...
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <Skeleton className="h-20 w-full" />
          <Skeleton className="h-16 w-full" />
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2 text-lg">
          <TrendingUp className="h-5 w-5 text-primary" />
          What Matters Most
        </CardTitle>
        <CardDescription>
          Factors with the biggest effect on your retirement projection
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {explanation && (
          <p className="text-sm leading-relaxed">{explanation}</p>
        )}

        <div className="space-y-3">
          {levers.map((lever, index) => (
            <LeverItem key={lever.lever} lever={lever} rank={index + 1} />
          ))}
        </div>

        <p className="text-xs text-muted-foreground italic pt-2 border-t">
          Impact calculated by varying each factor individually. Actual results depend on multiple factors working together.
        </p>
      </CardContent>
    </Card>
  );
}

function LeverItem({ lever, rank }: { lever: LeverImpact; rank: number }) {
  const isPositive = lever.impactOnBalance > 0;

  return (
    <div className="flex items-center justify-between p-3 rounded-lg bg-muted/50">
      <div className="flex items-center gap-3">
        <span className={cn(
          'w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold',
          rank === 1 && 'bg-primary text-primary-foreground',
          rank === 2 && 'bg-secondary text-secondary-foreground',
          rank === 3 && 'bg-muted-foreground/20 text-muted-foreground'
        )}>
          {rank}
        </span>
        <div>
          <p className="font-medium text-sm">{lever.displayName}</p>
          <p className="text-xs text-muted-foreground">
            {lever.testDirection === 'increase' ? '+' : '-'}{formatDeltaValue(lever.lever, lever.testDelta)}
          </p>
        </div>
      </div>
      <div className={cn(
        'text-right',
        isPositive ? 'text-success' : 'text-destructive'
      )}>
        <p className="font-semibold text-sm">
          {isPositive ? '+' : ''}{formatCurrency(lever.impactOnBalance)}
        </p>
        <p className="text-xs text-muted-foreground">
          {lever.percentImpact.toFixed(1)}% impact
        </p>
      </div>
    </div>
  );
}
```

#### 2. Create LowFrictionWinsCard Component
**File**: `src/components/insights/LowFrictionWinsCard.tsx` (NEW)

```typescript
'use client';

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { Zap } from 'lucide-react';
import { cn } from '@/lib/utils';
import type { LowFrictionWin } from '@/lib/projections/sensitivity-types';

interface LowFrictionWinsCardProps {
  wins: LowFrictionWin[];
  isLoading?: boolean;
}

function formatCurrency(value: number): string {
  if (value >= 1_000_000) return `$${(value / 1_000_000).toFixed(1)}M`;
  if (value >= 1_000) return `$${Math.round(value / 1_000)}K`;
  return `$${Math.round(value)}`;
}

export function LowFrictionWinsCard({ wins, isLoading }: LowFrictionWinsCardProps) {
  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Zap className="h-5 w-5 animate-pulse" />
            Finding Quick Wins...
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-32 w-full" />
        </CardContent>
      </Card>
    );
  }

  if (wins.length === 0) {
    return null;
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2 text-lg">
          <Zap className="h-5 w-5 text-warning" />
          Small Changes, Big Effects
        </CardTitle>
        <CardDescription>
          Modest adjustments that show meaningful impact in projections
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {wins.map((win) => (
          <WinItem key={win.id} win={win} />
        ))}
      </CardContent>
    </Card>
  );
}

function WinItem({ win }: { win: LowFrictionWin }) {
  return (
    <div className="p-4 rounded-lg border bg-card">
      <div className="flex items-start justify-between gap-4">
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-1">
            <h4 className="font-medium text-sm">{win.title}</h4>
            <EffortBadge level={win.effortLevel} />
          </div>
          <p className="text-sm text-muted-foreground mb-2">
            {win.description}
          </p>
          <p className="text-sm">
            <span className="text-success font-medium">
              {win.impactDescription}
            </span>
          </p>
        </div>
        <div className="text-right">
          <p className="text-lg font-bold text-success">
            +{formatCurrency(win.potentialImpact)}
          </p>
        </div>
      </div>
      <p className="text-xs text-muted-foreground italic mt-3 pt-3 border-t">
        {win.uncertaintyCaveat}
      </p>
    </div>
  );
}

function EffortBadge({ level }: { level: LowFrictionWin['effortLevel'] }) {
  const styles = {
    minimal: 'bg-success/10 text-success',
    low: 'bg-warning/10 text-warning',
    moderate: 'bg-muted text-muted-foreground',
  };

  return (
    <span className={cn(
      'inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium',
      styles[level]
    )}>
      {level} effort
    </span>
  );
}
```

#### 3. Create AssumptionSensitivityCard Component
**File**: `src/components/insights/AssumptionSensitivityCard.tsx` (NEW)

```typescript
'use client';

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { Settings, Info } from 'lucide-react';
import { cn } from '@/lib/utils';
import type { SensitiveAssumption } from '@/lib/projections/sensitivity-types';

interface AssumptionSensitivityCardProps {
  assumptions: SensitiveAssumption[];
  explanation: string;
  isLoading?: boolean;
}

export function AssumptionSensitivityCard({
  assumptions,
  explanation,
  isLoading,
}: AssumptionSensitivityCardProps) {
  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Settings className="h-5 w-5 animate-pulse" />
            Analyzing Assumptions...
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-24 w-full" />
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2 text-lg">
          <Settings className="h-5 w-5 text-primary" />
          Assumption Sensitivity
        </CardTitle>
        <CardDescription>
          Which assumptions your projection depends on most
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {explanation && (
          <p className="text-sm leading-relaxed">{explanation}</p>
        )}

        <div className="space-y-3">
          {assumptions.map((assumption) => (
            <AssumptionItem key={assumption.assumption} assumption={assumption} />
          ))}
        </div>

        <div className="p-3 rounded-lg bg-muted/50 mt-4">
          <p className="text-sm text-muted-foreground">
            <Info className="h-4 w-4 inline mr-2" />
            These assumptions may evolve over time. Periodic review helps keep projections aligned with your actual situation.
          </p>
        </div>
      </CardContent>
    </Card>
  );
}

function AssumptionItem({ assumption }: { assumption: SensitiveAssumption }) {
  return (
    <div className="p-3 rounded-lg border">
      <div className="flex items-center justify-between mb-2">
        <h4 className="font-medium text-sm">{assumption.displayName}</h4>
        <SensitivityMeter score={assumption.sensitivityScore} />
      </div>
      <p className="text-sm text-muted-foreground mb-2">
        Current: <span className="font-medium text-foreground">{assumption.formattedValue}</span>
      </p>
      <p className="text-xs text-muted-foreground">
        {assumption.explanation}
      </p>
      <p className="text-xs text-primary mt-2">
        {assumption.reviewSuggestion}
      </p>
    </div>
  );
}

function SensitivityMeter({ score }: { score: number }) {
  return (
    <div className="flex items-center gap-2">
      <div className="w-16 h-2 rounded-full bg-muted overflow-hidden">
        <div
          className={cn(
            'h-full rounded-full transition-all',
            score >= 80 && 'bg-destructive',
            score >= 50 && score < 80 && 'bg-warning',
            score < 50 && 'bg-success'
          )}
          style={{ width: `${score}%` }}
        />
      </div>
      <span className="text-xs text-muted-foreground">{score}%</span>
    </div>
  );
}
```

#### 4. Create Insights Section Container
**File**: `src/components/insights/InsightsSection.tsx` (NEW)

```typescript
'use client';

import { useEffect, useState } from 'react';
import { TopLeversCard } from './TopLeversCard';
import { LowFrictionWinsCard } from './LowFrictionWinsCard';
import { AssumptionSensitivityCard } from './AssumptionSensitivityCard';
import type { InsightsResponse } from '@/lib/projections/sensitivity-types';

interface InsightsSectionProps {
  isScenarioActive: boolean;
}

export function InsightsSection({ isScenarioActive }: InsightsSectionProps) {
  const [insights, setInsights] = useState<InsightsResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // Don't fetch during scenario mode
    if (isScenarioActive) {
      return;
    }

    async function fetchInsights() {
      setIsLoading(true);
      setError(null);

      try {
        const response = await fetch('/api/insights/analyze', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        });

        if (!response.ok) {
          throw new Error('Failed to fetch insights');
        }

        const data = await response.json() as InsightsResponse;
        setInsights(data);
      } catch (err) {
        console.error('Insights fetch error:', err);
        setError('Unable to load insights');
      } finally {
        setIsLoading(false);
      }
    }

    fetchInsights();
  }, [isScenarioActive]);

  // Hide during scenario mode
  if (isScenarioActive) {
    return null;
  }

  // Show error state
  if (error && !isLoading) {
    return null; // Silently hide if insights fail to load
  }

  return (
    <div className="space-y-6 mt-8">
      <div>
        <h2 className="text-xl font-semibold mb-1">Insights</h2>
        <p className="text-sm text-muted-foreground">
          Understanding what affects your retirement projection most
        </p>
      </div>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        <TopLeversCard
          levers={insights?.topLevers ?? []}
          explanation={insights?.leverExplanation ?? ''}
          isLoading={isLoading}
        />
        <LowFrictionWinsCard
          wins={insights?.lowFrictionWins ?? []}
          isLoading={isLoading}
        />
        <AssumptionSensitivityCard
          assumptions={insights?.sensitiveAssumptions ?? []}
          explanation={insights?.sensitivityExplanation ?? ''}
          isLoading={isLoading}
        />
      </div>
    </div>
  );
}
```

#### 5. Export Components
**File**: `src/components/insights/index.ts` (NEW)

```typescript
export { TopLeversCard } from './TopLeversCard';
export { LowFrictionWinsCard } from './LowFrictionWinsCard';
export { AssumptionSensitivityCard } from './AssumptionSensitivityCard';
export { InsightsSection } from './InsightsSection';
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compiles: `npm run build`
- [x] Linting passes: `npm run lint`
- [ ] Components render without errors in Storybook (if available)

#### Manual Verification:
- [ ] TopLeversCard displays 3 ranked levers with impact values
- [ ] LowFrictionWinsCard shows effort badges and impact descriptions
- [ ] AssumptionSensitivityCard displays sensitivity meter correctly
- [ ] Loading states display skeletons appropriately
- [ ] Components are responsive (single column on mobile)

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 4.

---

## Phase 4: Integration into Plans Page

### Overview
Integrate the InsightsSection component into the plans page, ensuring it displays below the chart and hides during scenario mode.

### Changes Required

#### 1. Update Plans Client
**File**: `src/app/plans/plans-client.tsx`
**Changes**: Import and render InsightsSection component

Add import at top of file:
```typescript
import { InsightsSection } from '@/components/insights';
```

Add InsightsSection after the chart section (approximately line 460, after the `</div>` that closes the chart container):

```typescript
{/* Add after the chart section, before the table */}
<InsightsSection isScenarioActive={isScenarioActive} />
```

The location should be after:
```typescript
          </CardContent>
        </Card>
```

And before:
```typescript
        {/* Detailed breakdown table */}
        <ProjectionTable records={projection.records} />
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compiles: `npm run build`
- [x] Linting passes: `npm run lint`
- [ ] Application starts without errors: `npm run dev`

#### Manual Verification:
- [ ] Insights section appears below the chart on plans page
- [ ] Three insight cards render in a responsive grid
- [ ] Cards show loading skeletons while data fetches
- [ ] Cards populate with real data after API returns
- [ ] Insights section hides when scenario mode is active
- [ ] Insights section reappears when scenario is reset
- [ ] AI explanations render (if OpenAI configured)
- [ ] Page remains performant (no noticeable slowdown)

**Implementation Note**: This is the final phase. After all verification passes, the feature is complete.

---

## Testing Strategy

### Unit Tests

Create test file at `src/lib/projections/__tests__/sensitivity.test.ts`:

```typescript
import { analyzeSensitivity, identifyLowFrictionWins, identifySensitiveAssumptions } from '../sensitivity';
import type { ProjectionInput } from '../types';

describe('sensitivity analysis', () => {
  const baseInput: ProjectionInput = {
    currentAge: 35,
    retirementAge: 65,
    maxAge: 90,
    balancesByType: { taxDeferred: 100000, taxFree: 50000, taxable: 50000 },
    annualContribution: 20000,
    contributionAllocation: { taxDeferred: 60, taxFree: 30, taxable: 10 },
    expectedReturn: 0.07,
    inflationRate: 0.025,
    contributionGrowthRate: 0.02,
    annualExpenses: 60000,
    annualHealthcareCosts: 8000,
    healthcareInflationRate: 0.05,
    incomeStreams: [],
    annualDebtPayments: 0,
  };

  describe('analyzeSensitivity', () => {
    it('returns exactly 3 top levers', () => {
      const result = analyzeSensitivity(baseInput);
      expect(result.topLevers).toHaveLength(3);
    });

    it('sorts levers by absolute impact', () => {
      const result = analyzeSensitivity(baseInput);
      const impacts = result.topLevers.map(l => Math.abs(l.impactOnBalance));
      expect(impacts).toEqual([...impacts].sort((a, b) => b - a));
    });

    it('includes baseline values', () => {
      const result = analyzeSensitivity(baseInput);
      expect(result.baselineBalance).toBeGreaterThan(0);
    });
  });

  describe('identifyLowFrictionWins', () => {
    it('identifies wins above threshold', () => {
      const sensitivityResult = analyzeSensitivity(baseInput);
      const wins = identifyLowFrictionWins(baseInput, sensitivityResult);

      for (const win of wins) {
        expect(win.potentialImpact).toBeGreaterThan(5000);
      }
    });

    it('returns at most 3 wins', () => {
      const sensitivityResult = analyzeSensitivity(baseInput);
      const wins = identifyLowFrictionWins(baseInput, sensitivityResult);
      expect(wins.length).toBeLessThanOrEqual(3);
    });
  });

  describe('identifySensitiveAssumptions', () => {
    it('returns at most 2 assumptions', () => {
      const sensitivityResult = analyzeSensitivity(baseInput);
      const assumptions = identifySensitiveAssumptions(baseInput, sensitivityResult);
      expect(assumptions.length).toBeLessThanOrEqual(2);
    });

    it('includes sensitivity scores', () => {
      const sensitivityResult = analyzeSensitivity(baseInput);
      const assumptions = identifySensitiveAssumptions(baseInput, sensitivityResult);

      for (const assumption of assumptions) {
        expect(assumption.sensitivityScore).toBeGreaterThanOrEqual(0);
        expect(assumption.sensitivityScore).toBeLessThanOrEqual(100);
      }
    });
  });
});
```

### Integration Tests

Test API endpoint with authenticated request:
1. Create test user with financial snapshot
2. POST to `/api/insights/analyze`
3. Verify response structure matches `InsightsResponse`
4. Verify levers are sorted by impact
5. Verify AI explanations (if configured) pass validation

### Manual Testing Steps

1. **Initial Load**: Navigate to plans page, verify insights section loads
2. **Loading State**: Observe loading skeletons during data fetch
3. **Data Display**: Verify all three cards show populated data
4. **Scenario Mode**: Enter a scenario, verify insights hide
5. **Scenario Reset**: Reset scenario, verify insights reappear
6. **Responsive**: Test on mobile viewport, verify single-column layout
7. **AI Content**: Verify explanations use observational language only
8. **Edge Cases**: Test with $0 contributions, already retired age

---

## Performance Considerations

1. **Sensitivity analysis runs ~6 projections** - each projection is < 100ms, total < 600ms
2. **No caching implemented** - analysis runs fresh on each page load
3. **AI calls are sequential** - lever and sensitivity explanations generated in order
4. **Future optimization**: Consider caching results with input hash if performance becomes an issue

---

## Migration Notes

No database migrations required. All data is computed on-demand from existing financial snapshot data.

---

## References

- Original research: [thoughts/shared/research/2026-01-14-ENG-6.1-actionable-insights-implementation.md](thoughts/shared/research/2026-01-14-ENG-6.1-actionable-insights-implementation.md)
- Projection engine: [src/lib/projections/engine.ts](src/lib/projections/engine.ts)
- AI guardrail patterns: [src/lib/ai/prompts/scenario-explain.ts](src/lib/ai/prompts/scenario-explain.ts)
- Response validation: [src/lib/ai/validate-response.ts](src/lib/ai/validate-response.ts)
- Plans page: [src/app/plans/plans-client.tsx](src/app/plans/plans-client.tsx)
