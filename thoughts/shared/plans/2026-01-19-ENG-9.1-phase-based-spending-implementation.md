# ENG-9.1: Phase-Based Spending Implementation Plan

## Overview

Implement life-phase-based spending (Go-Go, Slow-Go, No-Go retirement phases) into the PlanSmart projection engine and UI. This feature allows users to model realistic spending patterns that match how retirees actually live, recognizing that early retirement is typically more active and expensive, while spending naturally decreases with age.

## Current State Analysis

### Existing Architecture

The projection engine currently calculates expenses with a flat model during the drawdown phase:

**File**: [engine.ts:164-177](src/lib/projections/engine.ts#L164-L177)
```typescript
// Current: flat expenses with inflation only
const inflationMultiplier = Math.pow(1 + input.inflationRate, yearsFromRetirement);
const essentialExpenses = (input.annualEssentialExpenses ?? input.annualExpenses) * inflationMultiplier;
const discretionaryExpenses = (input.annualDiscretionaryExpenses ?? 0) * inflationMultiplier;
```

**Key Integration Points Identified:**
- `ProjectionInput` interface in [types.ts:76-116](src/lib/projections/types.ts#L76-L116) - needs new field
- `buildProjectionInputFromSnapshot()` in [input-builder.ts:34-141](src/lib/projections/input-builder.ts#L34-L141) - needs phase config transformation
- `calculateIncomeFloor()` in [income-floor.ts:35-113](src/lib/projections/income-floor.ts#L35-L113) - needs phase-aware expense calculation
- Database schema in [financial-snapshot.ts](src/db/schema/financial-snapshot.ts) - needs new JSONB column
- Validation in [projections.ts](src/lib/validation/projections.ts) - needs phase config schema
- API route in [route.ts](src/app/api/projections/calculate/route.ts) - needs to pass phase config

### What's Missing
- No concept of age-based spending variation
- No data model for spending phases
- No UI for configuring phases
- Income floor analysis doesn't account for spending changes over time

## Desired End State

After implementation:
1. Users can define 1-4 spending phases with separate multipliers for essential and discretionary expenses
2. Phases can optionally use absolute amounts instead of multipliers
3. Default phases (Go-Go, Slow-Go, No-Go) are available but disabled by default (opt-in)
4. Projection engine applies phase multipliers before inflation adjustment
5. Income floor analysis reflects phase-adjusted spending
6. UI allows full phase configuration on profile page
7. API supports phase config overrides

### Verification Criteria
- Projection with phases enabled shows varying expense levels by age
- Phase multipliers correctly reduce/increase spending at configured ages
- Essential and discretionary can have different multipliers per phase
- Income floor coverage reflects actual phase-adjusted expenses
- UI allows adding, editing, removing phases with validation

## What We're NOT Doing

| Excluded | Reason |
|----------|--------|
| Visual spending timeline/chart | Story 9.3 covers this |
| Phase-specific category breakdowns | Future enhancement |
| Automatic phase recommendations | Future enhancement |
| Migration of existing users to phases | Opt-in model, no migration needed |
| Onboarding step for phases | Profile-only for now, can add later |

## Implementation Approach

The implementation follows a layered approach:
1. **Phase 1**: Core data types and engine logic
2. **Phase 2**: Database schema and persistence
3. **Phase 3**: API integration and validation
4. **Phase 4**: UI components for phase configuration

---

## Phase 1: Core Data Types and Engine Logic

### Overview
Add TypeScript interfaces for spending phases and implement the core calculation logic in the projection engine.

### Changes Required

#### 1. Type Definitions
**File**: `src/lib/projections/types.ts`

Add new interfaces after line 70 (after `BalanceByType`):

```typescript
/**
 * Individual spending phase configuration
 * Supports both multiplier-based and absolute amount spending
 */
export interface SpendingPhase {
  id: string;
  name: string;
  startAge: number;
  endAge?: number;  // Inferred from next phase or maxAge if not specified

  // Multiplier-based spending (1.0 = 100% of base)
  essentialMultiplier: number;
  discretionaryMultiplier: number;

  // Optional absolute amount overrides (takes precedence over multipliers)
  absoluteEssential?: number;
  absoluteDiscretionary?: number;
}

/**
 * Complete spending phase configuration
 */
export interface SpendingPhaseConfig {
  enabled: boolean;
  phases: SpendingPhase[];
}
```

Update `ProjectionInput` interface (around line 116) to add:

```typescript
export interface ProjectionInput {
  // ... existing fields ...

  /** Optional spending phase configuration for age-based spending variation */
  spendingPhaseConfig?: SpendingPhaseConfig;
}
```

Update `ProjectionRecord` interface (around line 156) to add phase tracking:

```typescript
export interface ProjectionRecord {
  // ... existing fields ...

  // Phase information for UI display
  activePhaseId?: string;
  activePhaseName?: string;
}
```

#### 2. Default Phase Configuration
**File**: `src/lib/projections/assumptions.ts`

Add after line 70 (after `estimateHealthcareCosts`):

```typescript
import type { SpendingPhase, SpendingPhaseConfig } from './types';

/**
 * Default spending phases based on retirement research
 * Go-Go: Active early retirement (travel, hobbies)
 * Slow-Go: Moderate activity, reduced spending
 * No-Go: Focus on care, minimal discretionary
 */
export const DEFAULT_SPENDING_PHASES: SpendingPhase[] = [
  {
    id: 'go-go',
    name: 'Go-Go Years',
    startAge: 65,
    essentialMultiplier: 1.0,
    discretionaryMultiplier: 1.1,  // 110% discretionary (travel, hobbies)
  },
  {
    id: 'slow-go',
    name: 'Slow-Go',
    startAge: 75,
    essentialMultiplier: 0.95,
    discretionaryMultiplier: 0.75,  // 75% discretionary
  },
  {
    id: 'no-go',
    name: 'No-Go',
    startAge: 85,
    essentialMultiplier: 0.90,
    discretionaryMultiplier: 0.50,  // 50% discretionary
  },
];

/**
 * Get default spending phase config adjusted for actual retirement age
 */
export function getDefaultSpendingPhaseConfig(retirementAge: number): SpendingPhaseConfig {
  const phases = DEFAULT_SPENDING_PHASES.map((phase, index) => ({
    ...phase,
    // Adjust first phase to start at actual retirement age
    startAge: index === 0 ? retirementAge : phase.startAge,
  }));

  return {
    enabled: false,  // Opt-in: disabled by default
    phases,
  };
}
```

#### 3. Phase Multiplier Helper Function
**File**: `src/lib/projections/engine.ts`

Add helper function after `calculateTotalIncome` (around line 108):

```typescript
import type { SpendingPhaseConfig, SpendingPhase } from './types';

/**
 * Get the active spending phase for a given age
 */
function getActivePhaseForAge(
  age: number,
  config?: SpendingPhaseConfig
): SpendingPhase | null {
  if (!config?.enabled || !config.phases.length) {
    return null;
  }

  // Sort phases by startAge descending to find the active one
  const sortedPhases = [...config.phases].sort((a, b) => b.startAge - a.startAge);

  for (const phase of sortedPhases) {
    if (age >= phase.startAge) {
      return phase;
    }
  }

  return null;
}

/**
 * Calculate phase-adjusted expenses for a given age
 * Returns expenses before inflation adjustment
 */
function calculatePhaseAdjustedExpenses(
  age: number,
  baseEssential: number,
  baseDiscretionary: number,
  config?: SpendingPhaseConfig
): { essential: number; discretionary: number; activePhase: SpendingPhase | null } {
  const activePhase = getActivePhaseForAge(age, config);

  if (!activePhase) {
    // No phase active, return base amounts (flat spending)
    return {
      essential: baseEssential,
      discretionary: baseDiscretionary,
      activePhase: null,
    };
  }

  // Absolute amounts take precedence over multipliers
  const essential = activePhase.absoluteEssential !== undefined
    ? activePhase.absoluteEssential
    : baseEssential * activePhase.essentialMultiplier;

  const discretionary = activePhase.absoluteDiscretionary !== undefined
    ? activePhase.absoluteDiscretionary
    : baseDiscretionary * activePhase.discretionaryMultiplier;

  return { essential, discretionary, activePhase };
}
```

#### 4. Engine Modification
**File**: `src/lib/projections/engine.ts`

Modify the drawdown phase expense calculation (lines 162-177):

```typescript
    } else {
      // DRAWDOWN PHASE
      const yearsFromRetirement = age - input.retirementAge;
      const inflationMultiplier = Math.pow(1 + input.inflationRate, yearsFromRetirement);

      // Calculate phase-adjusted base expenses (before inflation)
      const baseEssential = input.annualEssentialExpenses ?? input.annualExpenses;
      const baseDiscretionary = input.annualDiscretionaryExpenses ?? 0;

      const phaseResult = calculatePhaseAdjustedExpenses(
        age,
        baseEssential,
        baseDiscretionary,
        input.spendingPhaseConfig
      );

      // Apply inflation to phase-adjusted amounts
      const essentialExpenses = phaseResult.essential * inflationMultiplier;
      const discretionaryExpenses = phaseResult.discretionary * inflationMultiplier;
      const generalExpenses = essentialExpenses + discretionaryExpenses;

      // Calculate healthcare costs with separate (higher) inflation
      const healthcareInflationMultiplier = Math.pow(1 + input.healthcareInflationRate, yearsFromRetirement);
      const healthcareExpenses = input.annualHealthcareCosts * healthcareInflationMultiplier;

      // Total expenses = general + healthcare
      const expensesNeeded = generalExpenses + healthcareExpenses;

      // ... rest of withdrawal logic unchanged ...

      // Store expense breakdown in record (update to include phase info)
      currentEssentialExpenses = Math.round(essentialExpenses * 100) / 100;
      currentDiscretionaryExpenses = Math.round(discretionaryExpenses * 100) / 100;
      currentActivePhaseId = phaseResult.activePhase?.id;
      currentActivePhaseName = phaseResult.activePhase?.name;
    }
```

Update the record push to include phase info:

```typescript
    records.push({
      age,
      year,
      balance: Math.max(0, totalBalance(balances)),
      inflows: Math.round(inflows * 100) / 100,
      outflows: Math.round(outflows * 100) / 100,
      balanceByType: {
        taxDeferred: Math.max(0, Math.round(balances.taxDeferred * 100) / 100),
        taxFree: Math.max(0, Math.round(balances.taxFree * 100) / 100),
        taxable: Math.max(0, Math.round(balances.taxable * 100) / 100),
      },
      withdrawalsByType,
      essentialExpenses: currentEssentialExpenses,
      discretionaryExpenses: currentDiscretionaryExpenses,
      activePhaseId: currentActivePhaseId,
      activePhaseName: currentActivePhaseName,
    });
```

#### 5. Income Floor Integration
**File**: `src/lib/projections/income-floor.ts`

Update `calculateIncomeFloor` to use phase-adjusted expenses:

Add import at top:
```typescript
import type { SpendingPhaseConfig } from './types';
```

Add helper (reuse from engine or import):
```typescript
// Import or duplicate the phase calculation helper
import { calculatePhaseAdjustedExpenses } from './engine';
```

Modify the expense calculation in the loop (around line 50):

```typescript
  for (let age = input.retirementAge; age <= input.maxAge; age++) {
    const year = currentYear + (age - input.currentAge);
    const yearsFromRetirement = age - input.retirementAge;

    // Calculate inflation multiplier
    const inflationMultiplier = Math.pow(1 + input.inflationRate, yearsFromRetirement);

    // Calculate phase-adjusted essential expenses
    const baseEssential = input.annualEssentialExpenses;
    const baseDiscretionary = input.annualDiscretionaryExpenses ?? 0;

    const phaseResult = calculatePhaseAdjustedExpenses(
      age,
      baseEssential,
      baseDiscretionary,
      input.spendingPhaseConfig
    );

    // Apply inflation to phase-adjusted essential expenses only
    const essentialExpenses = phaseResult.essential * inflationMultiplier;

    // ... rest of calculation unchanged ...
  }
```

### Success Criteria

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] All existing tests pass: `npm test` (2 pre-existing failures in ProjectionTable CSV export tests - unrelated)
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Create a test projection input with phase config and verify expenses vary by age
- [ ] Verify phase multipliers are applied before inflation
- [ ] Verify absolute amounts override multipliers when specified
- [ ] Verify income floor reflects phase-adjusted essential expenses

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 2.

---

## Phase 2: Database Schema and Persistence

### Overview
Add database column for storing spending phase configuration and update type definitions.

### Changes Required

#### 1. Database Schema Types
**File**: `src/db/schema/financial-snapshot.ts`

Add new JSON types after `IncomeStreamJson` (around line 51):

```typescript
export type SpendingPhaseJson = {
  id: string;
  name: string;
  startAge: number;
  endAge?: number;
  essentialMultiplier: number;
  discretionaryMultiplier: number;
  absoluteEssential?: number;
  absoluteDiscretionary?: number;
};

export type SpendingPhaseConfigJson = {
  enabled: boolean;
  phases: SpendingPhaseJson[];
};
```

Add column to table definition (around line 112, before `createdAt`):

```typescript
  // Epic 9: Spending phase configuration
  spendingPhases: jsonb('spending_phases').$type<SpendingPhaseConfigJson>(),
```

#### 2. Database Migration
**File**: `src/db/migrations/XXXX_add_spending_phases.sql` (new file)

```sql
-- Add spending phases column for Epic 9: Life-Phase-Based Spending
ALTER TABLE financial_snapshot
ADD COLUMN spending_phases JSONB;

-- Add comment for documentation
COMMENT ON COLUMN financial_snapshot.spending_phases IS 'Epic 9: Spending phase configuration (Go-Go, Slow-Go, No-Go)';
```

#### 3. Input Builder Integration
**File**: `src/lib/projections/input-builder.ts`

Add import:
```typescript
import type { SpendingPhaseConfig } from './types';
```

Update `ProjectionOverrides` interface (around line 22):

```typescript
export interface ProjectionOverrides {
  // ... existing fields ...
  spendingPhaseConfig?: SpendingPhaseConfig;
}
```

Add helper function after `calculatePropertySummary`:

```typescript
/**
 * Build spending phase config from snapshot and overrides
 */
function buildSpendingPhaseConfig(
  snapshot: FinancialSnapshotRow,
  overrides?: ProjectionOverrides
): SpendingPhaseConfig | undefined {
  // Override takes precedence
  if (overrides?.spendingPhaseConfig) {
    return overrides.spendingPhaseConfig;
  }

  // Use snapshot config if exists
  if (snapshot.spendingPhases) {
    return snapshot.spendingPhases as SpendingPhaseConfig;
  }

  // Return undefined for flat spending (opt-in model)
  return undefined;
}
```

Update `buildProjectionInputFromSnapshot` return statement (around line 123):

```typescript
  // Build spending phase config
  const spendingPhaseConfig = buildSpendingPhaseConfig(snapshot, overrides);

  return {
    // ... existing fields ...
    spendingPhaseConfig,
  };
```

### Success Criteria

#### Automated Verification:
- [x] Migration runs successfully: `npm run db:migrate` (migration generated: 0009_slim_post.sql)
- [x] TypeScript compiles: `npm run typecheck`
- [x] Database schema matches types: verify with test query
- [x] Existing tests pass: `npm test` (2 pre-existing failures in ProjectionTable CSV export tests - unrelated)

#### Manual Verification:
- [ ] Verify column exists in database with correct type
- [ ] Test saving a spending phase config to the database
- [ ] Test loading a spending phase config from the database
- [ ] Verify null/undefined handling for users without phases

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 3.

---

## Phase 3: API Integration and Validation

### Overview
Add Zod validation schema for spending phases and update the projection API to accept phase overrides.

### Changes Required

#### 1. Validation Schema
**File**: `src/lib/validation/projections.ts`

Add after `incomeStreamSchema` (around line 14):

```typescript
/**
 * Individual spending phase validation schema
 */
export const spendingPhaseSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1, 'Phase name is required').max(50),
  startAge: z.number().int().min(50, 'Start age must be at least 50').max(100),
  endAge: z.number().int().min(50).max(120).optional(),

  // Multipliers (0.1 to 2.0 = 10% to 200%)
  essentialMultiplier: z.number()
    .min(0.1, 'Multiplier must be at least 10%')
    .max(2.0, 'Multiplier cannot exceed 200%'),
  discretionaryMultiplier: z.number()
    .min(0.0, 'Multiplier cannot be negative')
    .max(3.0, 'Multiplier cannot exceed 300%'),

  // Optional absolute amounts
  absoluteEssential: z.number().min(0).max(500000).optional(),
  absoluteDiscretionary: z.number().min(0).max(500000).optional(),
});

/**
 * Spending phase config validation with cross-field rules
 */
export const spendingPhaseConfigSchema = z.object({
  enabled: z.boolean(),
  phases: z.array(spendingPhaseSchema)
    .min(1, 'At least one phase is required when enabled')
    .max(4, 'Maximum 4 phases allowed'),
}).refine(
  (data) => {
    if (!data.enabled) return true;

    // Validate phases are ordered by startAge with no gaps
    const sorted = [...data.phases].sort((a, b) => a.startAge - b.startAge);
    for (let i = 1; i < sorted.length; i++) {
      // Phases should be ordered (next startAge > previous startAge)
      if (sorted[i].startAge <= sorted[i - 1].startAge) {
        return false;
      }
    }
    return true;
  },
  { message: 'Phases must have unique, ascending start ages' }
);
```

Update `projectionRequestSchema` (around line 104):

```typescript
export const projectionRequestSchema = z.object({
  // ... existing fields ...

  // Spending phase config override
  spendingPhaseConfig: spendingPhaseConfigSchema.optional(),
});
```

#### 2. API Route Update
**File**: `src/app/api/projections/calculate/route.ts`

Add import:
```typescript
import type { SpendingPhaseConfig } from '@/lib/projections/types';
```

Update `calculateProjection` function to include phase config (around line 221-238):

```typescript
  // Build projection input with defaults and overrides
  const projectionInput: ProjectionInput = {
    // ... existing fields ...

    // Spending phase configuration
    spendingPhaseConfig: overrides.spendingPhaseConfig as SpendingPhaseConfig | undefined,
  };
```

Update the inputs echo in the response (around line 299):

```typescript
    inputs: {
      // ... existing fields ...
      spendingPhaseConfig: projectionInput.spendingPhaseConfig,
    },
```

#### 3. Profile API Update
**File**: `src/app/api/profile/route.ts` (or equivalent)

Add spending phases to the profile update endpoint to allow saving phase configuration.

### Success Criteria

#### Automated Verification:
- [x] TypeScript compiles: `npm run typecheck`
- [x] Validation schema tests pass (add tests for phase validation)
- [x] API accepts valid phase config in POST body
- [x] API rejects invalid phase config with helpful errors
- [x] All existing tests pass: `npm test` (2 pre-existing failures in ProjectionTable CSV export tests - unrelated)

#### Manual Verification:
- [ ] Test API with valid phase config override
- [ ] Test API with invalid phase config (overlapping ages, too many phases)
- [ ] Verify validation error messages are user-friendly
- [ ] Test projection result includes phase information in records

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation before proceeding to Phase 4.

---

## Phase 4: UI Components

### Overview
Create UI components for configuring spending phases on the profile page.

### Changes Required

#### 1. Spending Phase Editor Component
**File**: `src/components/spending-phase-editor.tsx` (new file)

```typescript
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Plus, Trash2, GripVertical } from 'lucide-react';
import type { SpendingPhase, SpendingPhaseConfig } from '@/lib/projections/types';
import { DEFAULT_SPENDING_PHASES } from '@/lib/projections/assumptions';

interface SpendingPhaseEditorProps {
  config: SpendingPhaseConfig | undefined;
  retirementAge: number;
  onChange: (config: SpendingPhaseConfig) => void;
}

export function SpendingPhaseEditor({
  config,
  retirementAge,
  onChange,
}: SpendingPhaseEditorProps) {
  // Initialize with defaults if no config
  const [localConfig, setLocalConfig] = useState<SpendingPhaseConfig>(() => {
    if (config) return config;
    return {
      enabled: false,
      phases: DEFAULT_SPENDING_PHASES.map((p, i) => ({
        ...p,
        startAge: i === 0 ? retirementAge : p.startAge,
      })),
    };
  });

  const handleEnabledChange = (enabled: boolean) => {
    const newConfig = { ...localConfig, enabled };
    setLocalConfig(newConfig);
    onChange(newConfig);
  };

  const handlePhaseChange = (index: number, updates: Partial<SpendingPhase>) => {
    const newPhases = [...localConfig.phases];
    newPhases[index] = { ...newPhases[index], ...updates };
    const newConfig = { ...localConfig, phases: newPhases };
    setLocalConfig(newConfig);
    onChange(newConfig);
  };

  const addPhase = () => {
    if (localConfig.phases.length >= 4) return;

    const lastPhase = localConfig.phases[localConfig.phases.length - 1];
    const newPhase: SpendingPhase = {
      id: `phase-${Date.now()}`,
      name: 'New Phase',
      startAge: (lastPhase?.startAge ?? retirementAge) + 10,
      essentialMultiplier: 1.0,
      discretionaryMultiplier: 1.0,
    };

    const newConfig = {
      ...localConfig,
      phases: [...localConfig.phases, newPhase],
    };
    setLocalConfig(newConfig);
    onChange(newConfig);
  };

  const removePhase = (index: number) => {
    if (localConfig.phases.length <= 1) return;

    const newPhases = localConfig.phases.filter((_, i) => i !== index);
    const newConfig = { ...localConfig, phases: newPhases };
    setLocalConfig(newConfig);
    onChange(newConfig);
  };

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>Spending Phases</CardTitle>
          <Switch
            checked={localConfig.enabled}
            onCheckedChange={handleEnabledChange}
          />
        </div>
        <p className="text-sm text-muted-foreground">
          Model how spending changes through retirement phases
        </p>
      </CardHeader>

      {localConfig.enabled && (
        <CardContent className="space-y-4">
          {localConfig.phases
            .sort((a, b) => a.startAge - b.startAge)
            .map((phase, index) => (
              <PhaseCard
                key={phase.id}
                phase={phase}
                index={index}
                isFirst={index === 0}
                canDelete={localConfig.phases.length > 1}
                onChange={(updates) => handlePhaseChange(index, updates)}
                onDelete={() => removePhase(index)}
              />
            ))}

          {localConfig.phases.length < 4 && (
            <Button
              variant="outline"
              className="w-full"
              onClick={addPhase}
            >
              <Plus className="mr-2 h-4 w-4" />
              Add Phase
            </Button>
          )}
        </CardContent>
      )}
    </Card>
  );
}

interface PhaseCardProps {
  phase: SpendingPhase;
  index: number;
  isFirst: boolean;
  canDelete: boolean;
  onChange: (updates: Partial<SpendingPhase>) => void;
  onDelete: () => void;
}

function PhaseCard({
  phase,
  index,
  isFirst,
  canDelete,
  onChange,
  onDelete,
}: PhaseCardProps) {
  const [useAbsolute, setUseAbsolute] = useState(
    phase.absoluteEssential !== undefined || phase.absoluteDiscretionary !== undefined
  );

  return (
    <div className="border rounded-lg p-4 space-y-4">
      <div className="flex items-center gap-2">
        <GripVertical className="h-4 w-4 text-muted-foreground" />
        <Input
          value={phase.name}
          onChange={(e) => onChange({ name: e.target.value })}
          className="font-medium"
          placeholder="Phase name"
        />
        {canDelete && (
          <Button
            variant="ghost"
            size="icon"
            onClick={onDelete}
          >
            <Trash2 className="h-4 w-4" />
          </Button>
        )}
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div>
          <Label>Start Age</Label>
          <Input
            type="number"
            value={phase.startAge}
            onChange={(e) => onChange({ startAge: parseInt(e.target.value) || 0 })}
            min={50}
            max={100}
          />
        </div>

        <div className="flex items-end">
          <div className="flex items-center gap-2">
            <Switch
              checked={useAbsolute}
              onCheckedChange={(checked) => {
                setUseAbsolute(checked);
                if (!checked) {
                  onChange({
                    absoluteEssential: undefined,
                    absoluteDiscretionary: undefined,
                  });
                }
              }}
            />
            <Label className="text-sm">Use absolute amounts</Label>
          </div>
        </div>
      </div>

      {useAbsolute ? (
        <div className="grid grid-cols-2 gap-4">
          <div>
            <Label>Essential ($/year)</Label>
            <Input
              type="number"
              value={phase.absoluteEssential ?? ''}
              onChange={(e) => onChange({
                absoluteEssential: e.target.value ? parseFloat(e.target.value) : undefined
              })}
              placeholder="Use multiplier"
            />
          </div>
          <div>
            <Label>Discretionary ($/year)</Label>
            <Input
              type="number"
              value={phase.absoluteDiscretionary ?? ''}
              onChange={(e) => onChange({
                absoluteDiscretionary: e.target.value ? parseFloat(e.target.value) : undefined
              })}
              placeholder="Use multiplier"
            />
          </div>
        </div>
      ) : (
        <div className="grid grid-cols-2 gap-4">
          <div>
            <Label>Essential ({Math.round(phase.essentialMultiplier * 100)}%)</Label>
            <Input
              type="range"
              min={10}
              max={200}
              value={phase.essentialMultiplier * 100}
              onChange={(e) => onChange({
                essentialMultiplier: parseInt(e.target.value) / 100
              })}
              className="w-full"
            />
          </div>
          <div>
            <Label>Discretionary ({Math.round(phase.discretionaryMultiplier * 100)}%)</Label>
            <Input
              type="range"
              min={0}
              max={300}
              value={phase.discretionaryMultiplier * 100}
              onChange={(e) => onChange({
                discretionaryMultiplier: parseInt(e.target.value) / 100
              })}
              className="w-full"
            />
          </div>
        </div>
      )}
    </div>
  );
}
```

#### 2. Profile Page Integration
**File**: `src/app/profile/profile-client.tsx`

Add import:
```typescript
import { SpendingPhaseEditor } from '@/components/spending-phase-editor';
import type { SpendingPhaseConfig } from '@/lib/projections/types';
```

Add state for phase config (in the component):
```typescript
const [spendingPhaseConfig, setSpendingPhaseConfig] = useState<SpendingPhaseConfig | undefined>(
  snapshot?.spendingPhases as SpendingPhaseConfig | undefined
);
```

Add the editor component in a new Collapsible section (similar to existing pattern around line 641-655):
```typescript
<Collapsible>
  <CollapsibleTrigger className="flex w-full items-center justify-between">
    <h3 className="text-lg font-semibold">Spending Phases</h3>
    <ChevronDown className="h-4 w-4" />
  </CollapsibleTrigger>
  <CollapsibleContent className="pt-4">
    <SpendingPhaseEditor
      config={spendingPhaseConfig}
      retirementAge={snapshot?.targetRetirementAge ?? 65}
      onChange={(config) => {
        setSpendingPhaseConfig(config);
        setHasUnsavedChanges(true);
      }}
    />
  </CollapsibleContent>
</Collapsible>
```

Update the save handler to include spending phases in the API call.

### Success Criteria

#### Automated Verification:
- [ ] TypeScript compiles: `npm run typecheck`
- [ ] Component renders without errors
- [ ] Linting passes: `npm run lint`
- [ ] Build succeeds: `npm run build`

#### Manual Verification:
- [ ] Toggle enables/disables phase configuration
- [ ] Can add phases (up to 4 max)
- [ ] Can remove phases (minimum 1 required)
- [ ] Can edit phase names, start ages, multipliers
- [ ] Can switch between multiplier and absolute amount modes
- [ ] Slider shows percentage value as it changes
- [ ] Changes persist after save
- [ ] Projection updates reflect phase configuration

**Implementation Note**: After completing this phase, perform comprehensive end-to-end testing before marking the story complete.

---

## Testing Strategy

### Unit Tests

**File**: `src/lib/projections/__tests__/engine.test.ts`

Add tests for:
```typescript
describe('Phase-based spending', () => {
  it('returns flat expenses when phases disabled', () => {
    // Test with spendingPhaseConfig: undefined
  });

  it('applies phase multipliers to expenses', () => {
    // Test with enabled phases, verify multipliers applied
  });

  it('uses absolute amounts when specified', () => {
    // Test absoluteEssential/absoluteDiscretionary override
  });

  it('handles separate essential/discretionary multipliers', () => {
    // Verify different multipliers for each type
  });

  it('transitions between phases at correct ages', () => {
    // Test phase boundaries
  });

  it('applies inflation after phase adjustment', () => {
    // Verify order: base → phase multiplier → inflation
  });
});
```

**File**: `src/lib/projections/__tests__/income-floor.test.ts`

Add tests for:
```typescript
describe('Income floor with phases', () => {
  it('calculates coverage using phase-adjusted essential expenses', () => {
    // Verify income floor uses phase-adjusted amounts
  });
});
```

### Integration Tests

Test the full flow:
1. Save phase config via API
2. Load projection with phase config
3. Verify expenses in projection records match expected phase-adjusted values

### Manual Testing Steps

1. **Enable phases on profile page**
   - Toggle on spending phases
   - Verify default Go-Go/Slow-Go/No-Go phases appear

2. **Edit phase configuration**
   - Change phase names
   - Adjust start ages
   - Modify multipliers using sliders
   - Switch to absolute amounts mode

3. **Save and verify persistence**
   - Save profile changes
   - Refresh page
   - Verify phases are still configured

4. **Verify projection impact**
   - View projection chart
   - Verify expense levels change at phase boundaries
   - Check that early years have higher discretionary spending

5. **Test edge cases**
   - Add 4 phases, verify cannot add more
   - Try to remove last phase, verify prevented
   - Enter invalid start ages, verify validation

---

## Performance Considerations

- Phase lookup is O(n) where n is number of phases (max 4) - negligible impact
- No additional database queries needed (phase config stored in existing snapshot)
- Phase calculation happens once per projection year during engine run

---

## Migration Notes

- **No data migration required**: Opt-in model means existing users continue with flat spending
- **Backward compatibility**: `spendingPhaseConfig: undefined` results in flat spending (existing behavior)
- **Default phases provided**: When user enables phases, sensible defaults are pre-populated

---

## References

- Original ticket: `thoughts/personal/tickets/epic-9/story-1-scope.md`
- Research document: `thoughts/shared/research/2026-01-19-ENG-9.1-phase-based-spending-integration.md`
- Similar implementation pattern: [income-floor.ts](src/lib/projections/income-floor.ts)
- UI pattern reference: [profile-client.tsx:641-655](src/app/profile/profile-client.tsx#L641-L655)
