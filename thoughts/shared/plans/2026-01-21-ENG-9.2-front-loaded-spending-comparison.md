# Story 9.2 + 9.3: Front-Loaded Spending Comparison & Visual Timeline Implementation Plan

## Overview

Implement the spending comparison feature that allows users to compare flat vs phase-based spending strategies, calculate break-even points, and visualize spending trajectories over time. This plan combines Story 9.2 (Front-Loaded Spending Support) and Story 9.3 (Visual Spending Timeline) as the visualization requirements overlap significantly.

## Current State Analysis

### What's Fully Implemented (Story 9.1)
- **Projection engine** (`src/lib/projections/engine.ts:139-166`) - `calculatePhaseAdjustedExpenses()` fully supports phase-based spending
- **Type definitions** (`src/lib/projections/types.ts:76-97`) - `SpendingPhase` and `SpendingPhaseConfig` interfaces
- **Default phases** (`src/lib/projections/assumptions.ts:78-100`) - Go-Go/Slow-Go/No-Go defaults
- **SpendingPhaseEditor** (`src/components/spending-phase-editor.tsx`) - Phase configuration UI
- **Database schema** (`src/db/schema/financial-snapshot.ts:132`) - `spendingPhases` JSONB column
- **Validation** (`src/lib/validation/projections.ts:6-48`) - Zod schemas with multiplier bounds

### Key Discoveries
- `ProjectionRecord` already tracks `essentialExpenses`, `discretionaryExpenses`, `activePhaseId`, `activePhaseName` (`types.ts:197-203`)
- Existing `/api/projections/calculate` supports `spendingPhaseConfig` override (`route.ts:239-241`)
- `ProjectionChart` uses recharts v3.6.0 with `ComposedChart` pattern (`ProjectionChart.tsx:230-384`)
- Plans page uses debounced recalculation with assumptions panel (`plans-client.tsx:54-120`)

## Desired End State

After implementation:

1. **New API Endpoint**: `/api/projections/compare` that returns flat vs phased spending comparison metrics
2. **SpendingComparison Type**: Interface capturing lifetime spending, depletion ages, early years bonus, and break-even age
3. **Compare Tab**: New "Compare" tab in Plans page showing side-by-side spending analysis
4. **SpendingTrajectoryChart**: Standalone chart showing annual spending over time with phase coloring
5. **SpendingImpactSummary**: Card component displaying key comparison metrics
6. **Neutral Framing**: All copy uses factual comparisons without penalty language

### Verification
- All new types compile without errors
- API endpoint returns valid `SpendingComparison` response
- Chart renders spending trajectory with correct phase boundaries
- Comparison metrics match manual calculation from projection data
- UI is accessible and mobile-responsive

## What We're NOT Doing

- Dynamic spending rules (guardrails) - Future epic
- Market-adaptive spending - Out of scope
- Healthcare cost spike modeling - Out of scope
- Drag-to-adjust phase boundaries - Story 9.3 enhancement
- Animation between scenarios - Future polish
- Export/share timeline image - Future feature

## Implementation Approach

The implementation follows the existing patterns in the codebase:
1. **Types first** - Define `SpendingComparison` interface
2. **Core logic** - Create comparison calculation function
3. **API endpoint** - New `/api/projections/compare` route
4. **Visualization** - `SpendingTrajectoryChart` component using recharts patterns
5. **UI integration** - Tab-based comparison view in Plans page

---

## Phase 1: Core Types and Comparison Logic

### Overview
Add the `SpendingComparison` interface and create the comparison calculation function.

### Changes Required:

#### 1. Add SpendingComparison Type
**File**: `src/lib/projections/types.ts`
**Changes**: Add new interface at the end of the file (after line 253)

```typescript
/**
 * Comparison result between flat and phased spending strategies
 * Used by Story 9.2 to show trade-offs
 */
export interface SpendingComparison {
  flatSpending: {
    /** Total spending from retirement to maxAge */
    totalLifetimeSpending: number;
    /** Age when portfolio depletes, or null if never */
    portfolioDepletionAge: number | null;
    /** Portfolio balance at maxAge */
    endingBalance: number;
    /** Year-by-year spending amounts for chart */
    yearlySpending: { age: number; amount: number }[];
  };
  phasedSpending: {
    /** Total spending from retirement to maxAge */
    totalLifetimeSpending: number;
    /** Age when portfolio depletes, or null if never */
    portfolioDepletionAge: number | null;
    /** Portfolio balance at maxAge */
    endingBalance: number;
    /** Year-by-year spending with phase info for chart */
    yearlySpending: { age: number; amount: number; phase: string | null }[];
    /** Extra spending in early years vs flat approach */
    earlyYearsBonus: number;
    /** Number of years considered "early years" (default: first 10 years of retirement) */
    earlyYearsCount: number;
  };
  /** Age where cumulative spending equals between strategies, or null if never */
  breakEvenAge: number | null;
  /** Difference in portfolio longevity (positive = phased lasts longer) */
  longevityDifference: number;
}

/**
 * Response from /api/projections/compare endpoint
 */
export interface SpendingComparisonResponse {
  comparison: SpendingComparison;
  inputs: {
    retirementAge: number;
    maxAge: number;
    baseEssentialExpenses: number;
    baseDiscretionaryExpenses: number;
    phases: SpendingPhase[];
  };
  meta: {
    calculationTimeMs: number;
  };
}
```

#### 2. Create Spending Comparison Module
**File**: `src/lib/projections/spending-comparison.ts` (NEW)
**Changes**: Create new file with comparison calculation logic

```typescript
import { runProjection } from './engine';
import type {
  ProjectionInput,
  ProjectionResult,
  SpendingComparison,
  SpendingPhaseConfig,
} from './types';

/**
 * Default number of years to consider "early years" for bonus calculation
 */
const DEFAULT_EARLY_YEARS_COUNT = 10;

/**
 * Calculate spending comparison between flat and phased strategies
 *
 * @param baseInput - Base projection input with spending phase config
 * @param earlyYearsCount - Number of early retirement years to compare (default: 10)
 * @returns SpendingComparison with metrics for both strategies
 */
export function calculateSpendingComparison(
  baseInput: ProjectionInput,
  earlyYearsCount: number = DEFAULT_EARLY_YEARS_COUNT
): SpendingComparison {
  // Run flat projection (phases disabled)
  const flatInput: ProjectionInput = {
    ...baseInput,
    spendingPhaseConfig: undefined,
  };
  const flatResult = runProjection(flatInput);

  // Run phased projection (phases enabled)
  const phasedInput: ProjectionInput = {
    ...baseInput,
    spendingPhaseConfig: baseInput.spendingPhaseConfig ?? undefined,
  };
  const phasedResult = runProjection(phasedInput);

  // Extract metrics from both results
  const flatMetrics = extractSpendingMetrics(flatResult, baseInput.retirementAge);
  const phasedMetrics = extractSpendingMetrics(phasedResult, baseInput.retirementAge);

  // Calculate early years bonus
  const flatEarlySpending = calculateEarlyYearsSpending(
    flatResult,
    baseInput.retirementAge,
    earlyYearsCount
  );
  const phasedEarlySpending = calculateEarlyYearsSpending(
    phasedResult,
    baseInput.retirementAge,
    earlyYearsCount
  );
  const earlyYearsBonus = phasedEarlySpending - flatEarlySpending;

  // Calculate break-even age
  const breakEvenAge = calculateBreakEvenAge(
    flatResult,
    phasedResult,
    baseInput.retirementAge
  );

  // Calculate longevity difference
  const flatDepletionYears = flatResult.summary.yearsUntilDepletion;
  const phasedDepletionYears = phasedResult.summary.yearsUntilDepletion;
  let longevityDifference = 0;
  if (flatDepletionYears !== null && phasedDepletionYears !== null) {
    longevityDifference = phasedDepletionYears - flatDepletionYears;
  } else if (flatDepletionYears !== null && phasedDepletionYears === null) {
    // Phased never depletes, flat does
    longevityDifference = baseInput.maxAge - baseInput.currentAge - flatDepletionYears;
  } else if (flatDepletionYears === null && phasedDepletionYears !== null) {
    // Flat never depletes, phased does
    longevityDifference = -(baseInput.maxAge - baseInput.currentAge - phasedDepletionYears);
  }

  // Build yearly spending arrays for charts
  const flatYearlySpending = buildYearlySpending(flatResult, baseInput.retirementAge);
  const phasedYearlySpending = buildPhasedYearlySpending(phasedResult, baseInput.retirementAge);

  return {
    flatSpending: {
      totalLifetimeSpending: flatMetrics.totalSpending,
      portfolioDepletionAge: flatMetrics.depletionAge,
      endingBalance: flatResult.summary.endingBalance,
      yearlySpending: flatYearlySpending,
    },
    phasedSpending: {
      totalLifetimeSpending: phasedMetrics.totalSpending,
      portfolioDepletionAge: phasedMetrics.depletionAge,
      endingBalance: phasedResult.summary.endingBalance,
      yearlySpending: phasedYearlySpending,
      earlyYearsBonus,
      earlyYearsCount,
    },
    breakEvenAge,
    longevityDifference,
  };
}

/**
 * Extract spending metrics from a projection result
 */
function extractSpendingMetrics(
  result: ProjectionResult,
  retirementAge: number
): { totalSpending: number; depletionAge: number | null } {
  const retirementRecords = result.records.filter((r) => r.age >= retirementAge);
  const totalSpending = retirementRecords.reduce((sum, r) => sum + r.outflows, 0);

  let depletionAge: number | null = null;
  if (result.summary.yearsUntilDepletion !== null) {
    const startAge = result.records[0]?.age ?? 0;
    depletionAge = startAge + result.summary.yearsUntilDepletion;
  }

  return { totalSpending, depletionAge };
}

/**
 * Calculate spending in early retirement years
 */
function calculateEarlyYearsSpending(
  result: ProjectionResult,
  retirementAge: number,
  yearsCount: number
): number {
  return result.records
    .filter((r) => r.age >= retirementAge && r.age < retirementAge + yearsCount)
    .reduce((sum, r) => sum + r.outflows, 0);
}

/**
 * Calculate break-even age where cumulative spending equals
 */
function calculateBreakEvenAge(
  flatResult: ProjectionResult,
  phasedResult: ProjectionResult,
  retirementAge: number
): number | null {
  let flatCumulative = 0;
  let phasedCumulative = 0;
  let foundBreakEven = false;
  let breakEvenAge: number | null = null;

  const flatRecords = flatResult.records.filter((r) => r.age >= retirementAge);
  const phasedRecords = phasedResult.records.filter((r) => r.age >= retirementAge);

  for (let i = 0; i < Math.min(flatRecords.length, phasedRecords.length); i++) {
    const prevFlatCumulative = flatCumulative;
    const prevPhasedCumulative = phasedCumulative;

    flatCumulative += flatRecords[i].outflows;
    phasedCumulative += phasedRecords[i].outflows;

    // Check if we crossed the break-even point
    const prevDiff = prevPhasedCumulative - prevFlatCumulative;
    const currDiff = phasedCumulative - flatCumulative;

    // If sign changed or difference is negligible, we found break-even
    if ((prevDiff > 0 && currDiff <= 0) || (prevDiff < 0 && currDiff >= 0)) {
      breakEvenAge = flatRecords[i].age;
      foundBreakEven = true;
      break;
    }

    // Also check if cumulative values are approximately equal (within $100)
    if (Math.abs(flatCumulative - phasedCumulative) < 100 && i > 0) {
      breakEvenAge = flatRecords[i].age;
      foundBreakEven = true;
      break;
    }
  }

  return foundBreakEven ? breakEvenAge : null;
}

/**
 * Build yearly spending array for flat spending chart
 */
function buildYearlySpending(
  result: ProjectionResult,
  retirementAge: number
): { age: number; amount: number }[] {
  return result.records
    .filter((r) => r.age >= retirementAge)
    .map((r) => ({
      age: r.age,
      amount: Math.round(r.outflows * 100) / 100,
    }));
}

/**
 * Build yearly spending array with phase info for phased spending chart
 */
function buildPhasedYearlySpending(
  result: ProjectionResult,
  retirementAge: number
): { age: number; amount: number; phase: string | null }[] {
  return result.records
    .filter((r) => r.age >= retirementAge)
    .map((r) => ({
      age: r.age,
      amount: Math.round(r.outflows * 100) / 100,
      phase: r.activePhaseName ?? null,
    }));
}
```

#### 3. Export from projections index
**File**: `src/lib/projections/index.ts`
**Changes**: Add export for new module

```typescript
export { calculateSpendingComparison } from './spending-comparison';
export type { SpendingComparison, SpendingComparisonResponse } from './types';
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Unit tests pass for `calculateSpendingComparison`: `npm test -- spending-comparison`
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Function returns valid comparison data with test input

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation that the unit tests cover the expected scenarios before proceeding to the next phase.

---

## Phase 2: API Endpoint

### Overview
Create the `/api/projections/compare` endpoint that returns spending comparison data.

### Changes Required:

#### 1. Create Compare API Route
**File**: `src/app/api/projections/compare/route.ts` (NEW)
**Changes**: Create new API endpoint following existing patterns from `/api/projections/calculate`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getServerUser } from '@/lib/auth/server';
import { db } from '@/db/client';
import { financialSnapshot } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { buildProjectionInput } from '@/lib/projections/input-builder';
import { calculateSpendingComparison } from '@/lib/projections/spending-comparison';
import type { SpendingComparisonResponse, SpendingPhaseConfig } from '@/lib/projections/types';
import { createTimer } from '@/lib/monitoring/performance';

/**
 * POST - Calculate spending comparison (flat vs phased)
 *
 * Request body:
 * {
 *   earlyYearsCount?: number; // Default 10
 *   spendingPhaseConfig?: SpendingPhaseConfig; // Override stored phases
 * }
 */
export async function POST(request: NextRequest) {
  try {
    const user = await getServerUser();
    if (!user) {
      return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
    }

    // Parse request body
    const body = await request.json().catch(() => ({}));
    const earlyYearsCount = body.earlyYearsCount ?? 10;
    const spendingPhaseConfigOverride = body.spendingPhaseConfig as
      | SpendingPhaseConfig
      | undefined;

    // Fetch financial snapshot
    const [snapshot] = await db
      .select()
      .from(financialSnapshot)
      .where(eq(financialSnapshot.userId, user.id))
      .limit(1);

    if (!snapshot) {
      return NextResponse.json(
        { message: 'Financial snapshot not found. Please complete onboarding.' },
        { status: 404 }
      );
    }

    // Build projection input from snapshot
    const timer = createTimer();
    const projectionInput = buildProjectionInput(snapshot);

    // Apply spending phase config (override or from snapshot)
    const spendingPhaseConfig =
      spendingPhaseConfigOverride ??
      (snapshot.spendingPhases as SpendingPhaseConfig | null) ??
      undefined;

    // Ensure phases are enabled for comparison
    if (!spendingPhaseConfig || !spendingPhaseConfig.enabled) {
      return NextResponse.json(
        {
          message:
            'Spending phases must be configured and enabled for comparison. Configure spending phases in your profile first.',
        },
        { status: 400 }
      );
    }

    // Calculate comparison
    const inputWithPhases = {
      ...projectionInput,
      spendingPhaseConfig,
    };

    const comparison = calculateSpendingComparison(inputWithPhases, earlyYearsCount);
    const calculationTimeMs = timer.getElapsed();

    const response: SpendingComparisonResponse = {
      comparison,
      inputs: {
        retirementAge: projectionInput.retirementAge,
        maxAge: projectionInput.maxAge,
        baseEssentialExpenses: projectionInput.annualEssentialExpenses,
        baseDiscretionaryExpenses: projectionInput.annualDiscretionaryExpenses,
        phases: spendingPhaseConfig.phases,
      },
      meta: {
        calculationTimeMs,
      },
    };

    return NextResponse.json(response);
  } catch (error) {
    console.error('Spending comparison error:', error);
    return NextResponse.json(
      { message: 'Failed to calculate spending comparison' },
      { status: 500 }
    );
  }
}
```

#### 2. Create Input Builder Function
**File**: `src/lib/projections/input-builder.ts`
**Changes**: Check if `buildProjectionInput` exists, if not create it. Based on research, extract the input building logic from `route.ts:149-242` into a reusable function.

First, let me check if this file exists. If not, we need to extract the input building logic from the calculate route.

```typescript
// If file doesn't exist, create it with the extracted logic from route.ts
import type { FinancialSnapshot } from '@/db/schema';
import type {
  ProjectionInput,
  BalanceByType,
  IncomeStream,
  SpendingPhaseConfig,
} from './types';
import {
  DEFAULT_RETURN_RATES,
  DEFAULT_INFLATION_RATE,
  DEFAULT_MAX_AGE,
  DEFAULT_CONTRIBUTION_ALLOCATION,
  DEFAULT_CONTRIBUTION_GROWTH_RATE,
  DEFAULT_HEALTHCARE_INFLATION_RATE,
  DEFAULT_SS_AGE,
  estimateSocialSecurityMonthly,
  deriveAnnualExpenses,
  estimateAnnualDebtPayments,
  estimateHealthcareCosts,
} from './assumptions';
import { ACCOUNT_TAX_CATEGORY } from './types';
import type { RiskTolerance } from '@/types/database';
import type {
  InvestmentAccountJson,
  DebtJson,
  IncomeExpensesJson,
  IncomeStreamJson,
  IncomeSourceJson,
} from '@/db/schema/financial-snapshot';

/**
 * Build ProjectionInput from a financial snapshot
 */
export function buildProjectionInput(
  snapshot: FinancialSnapshot,
  overrides?: Partial<ProjectionInput>
): ProjectionInput {
  const currentYear = new Date().getFullYear();
  const currentAge = currentYear - snapshot.birthYear;
  const riskTolerance = snapshot.riskTolerance as RiskTolerance;

  // Calculate balances by tax category
  const accounts = (snapshot.investmentAccounts || []) as InvestmentAccountJson[];
  const balancesByType: BalanceByType = {
    taxDeferred: 0,
    taxFree: 0,
    taxable: 0,
  };

  accounts.forEach((account) => {
    const knownType = account.type as keyof typeof ACCOUNT_TAX_CATEGORY;
    const category = ACCOUNT_TAX_CATEGORY[knownType] || 'taxable';
    balancesByType[category] += account.balance;
  });

  // Calculate annual contribution from monthly contributions
  const annualContribution = accounts.reduce(
    (sum, account) => sum + (account.monthlyContribution || 0) * 12,
    0
  );

  // Calculate annual expenses
  const incomeExpenses = snapshot.incomeExpenses as IncomeExpensesJson | null;
  const incomeSources = snapshot.incomeSources as IncomeSourceJson[] | null;
  let annualExpenses: number;
  let annualEssentialExpenses: number;
  let annualDiscretionaryExpenses: number;

  if (incomeExpenses?.monthlyEssential || incomeExpenses?.monthlyDiscretionary) {
    annualEssentialExpenses = (incomeExpenses.monthlyEssential || 0) * 12;
    annualDiscretionaryExpenses = (incomeExpenses.monthlyDiscretionary || 0) * 12;
    annualExpenses = annualEssentialExpenses + annualDiscretionaryExpenses;
  } else {
    const totalIncome = calculateTotalIncome(incomeSources, snapshot.annualIncome);
    annualExpenses = deriveAnnualExpenses(totalIncome, parseFloat(snapshot.savingsRate));
    annualEssentialExpenses = annualExpenses;
    annualDiscretionaryExpenses = 0;
  }

  // Estimate debt payments
  const debts = (snapshot.debts || []) as DebtJson[];
  const annualDebtPayments = estimateAnnualDebtPayments(debts);

  // Retirement age
  const retirementAge = overrides?.retirementAge ?? snapshot.targetRetirementAge;

  // Healthcare costs
  const annualHealthcareCosts =
    overrides?.annualHealthcareCosts ?? estimateHealthcareCosts(retirementAge);

  // Build income streams
  const incomeStreams = buildIncomeStreams(snapshot);

  // Spending phases
  const spendingPhaseConfig =
    overrides?.spendingPhaseConfig ??
    (snapshot.spendingPhases as SpendingPhaseConfig | null) ??
    undefined;

  return {
    currentAge,
    retirementAge,
    maxAge: overrides?.maxAge ?? DEFAULT_MAX_AGE,
    balancesByType,
    annualContribution,
    contributionAllocation:
      overrides?.contributionAllocation ?? DEFAULT_CONTRIBUTION_ALLOCATION,
    expectedReturn: overrides?.expectedReturn ?? DEFAULT_RETURN_RATES[riskTolerance],
    inflationRate: overrides?.inflationRate ?? DEFAULT_INFLATION_RATE,
    contributionGrowthRate:
      overrides?.contributionGrowthRate ?? DEFAULT_CONTRIBUTION_GROWTH_RATE,
    annualEssentialExpenses,
    annualDiscretionaryExpenses,
    annualExpenses,
    annualHealthcareCosts,
    healthcareInflationRate:
      overrides?.healthcareInflationRate ?? DEFAULT_HEALTHCARE_INFLATION_RATE,
    incomeStreams,
    annualDebtPayments,
    spendingPhaseConfig,
  };
}

function calculateTotalIncome(
  incomeSources: IncomeSourceJson[] | null | undefined,
  annualIncome: string
): number {
  if (incomeSources && incomeSources.length > 0) {
    return incomeSources.reduce((sum, source) => {
      const adjustmentFactor =
        source.variability === 'variable'
          ? 0.85
          : source.variability === 'seasonal'
          ? 0.9
          : 1.0;
      return sum + source.annualAmount * adjustmentFactor;
    }, 0);
  }
  return parseFloat(annualIncome);
}

function buildIncomeStreams(snapshot: FinancialSnapshot): IncomeStream[] {
  const streams = snapshot.incomeStreams as IncomeStreamJson[] | null;
  if (streams && streams.length > 0) {
    return streams;
  }

  // Backward compatibility
  const incomeSources = snapshot.incomeSources as IncomeSourceJson[] | null;
  const incomeForSS =
    incomeSources && incomeSources.length > 0
      ? incomeSources.reduce((sum, s) => sum + s.annualAmount, 0)
      : parseFloat(snapshot.annualIncome);

  const ssMonthly = estimateSocialSecurityMonthly(incomeForSS);
  if (ssMonthly <= 0) return [];

  return [
    {
      id: 'ss-auto',
      name: 'Social Security',
      type: 'social_security' as const,
      annualAmount: ssMonthly * 12,
      startAge: DEFAULT_SS_AGE,
      endAge: undefined,
      inflationAdjusted: true,
      isGuaranteed: true,
      isSpouse: false,
    },
  ];
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] API endpoint integration test passes
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] API returns valid JSON when called with authenticated request
- [ ] API returns 400 error when spending phases not configured
- [ ] API returns 401 when unauthenticated

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual API testing before proceeding to the next phase.

---

## Phase 3: Spending Trajectory Chart Component

### Overview
Create the `SpendingTrajectoryChart` component that visualizes spending over time with phase coloring.

### Changes Required:

#### 1. Create SpendingTrajectoryChart Component
**File**: `src/components/projections/SpendingTrajectoryChart.tsx` (NEW)
**Changes**: Create new chart component following `ProjectionChart.tsx` patterns

```typescript
'use client';

import { useMemo, useState } from 'react';
import {
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  ComposedChart,
  ReferenceLine,
} from 'recharts';

interface SpendingDataPoint {
  age: number;
  amount: number;
  phase: string | null;
}

interface SpendingTrajectoryChartProps {
  /** Yearly spending data with phase info */
  data: SpendingDataPoint[];
  /** Optional flat spending overlay for comparison */
  flatData?: { age: number; amount: number }[];
  /** Whether to show in inflation-adjusted (real) dollars */
  showRealDollars?: boolean;
  /** Inflation rate for real dollar conversion */
  inflationRate?: number;
  /** Retirement age (starting point) */
  retirementAge: number;
}

// Phase colors matching existing design system
const PHASE_COLORS: Record<string, string> = {
  'Go-Go Years': 'hsl(var(--success))',
  'Slow-Go': 'hsl(var(--warning))',
  'No-Go': 'hsl(var(--muted-foreground))',
  default: 'hsl(var(--primary))',
};

function formatCurrency(value: number): string {
  if (value >= 1_000_000) return `$${(value / 1_000_000).toFixed(1)}M`;
  if (value >= 1_000) return `$${(value / 1_000).toFixed(0)}K`;
  return `$${value.toFixed(0)}`;
}

function formatTooltipCurrency(value: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    maximumFractionDigits: 0,
  }).format(value);
}

export function SpendingTrajectoryChart({
  data,
  flatData,
  showRealDollars = true,
  inflationRate = 0.025,
  retirementAge,
}: SpendingTrajectoryChartProps) {
  const [showFlat, setShowFlat] = useState(!!flatData);

  // Transform data for chart with optional inflation adjustment
  const chartData = useMemo(() => {
    return data.map((point, index) => {
      const yearsFromRetirement = point.age - retirementAge;
      const inflationFactor = Math.pow(1 + inflationRate, yearsFromRetirement);

      const displayAmount = showRealDollars
        ? point.amount / inflationFactor
        : point.amount;

      // Find corresponding flat spending if available
      let flatAmount: number | null = null;
      if (flatData && showFlat) {
        const flatPoint = flatData.find((f) => f.age === point.age);
        if (flatPoint) {
          flatAmount = showRealDollars
            ? flatPoint.amount / inflationFactor
            : flatPoint.amount;
        }
      }

      return {
        age: point.age,
        spending: Math.round(displayAmount * 100) / 100,
        flatSpending: flatAmount ? Math.round(flatAmount * 100) / 100 : null,
        phase: point.phase,
        originalAmount: point.amount,
      };
    });
  }, [data, flatData, showRealDollars, showFlat, inflationRate, retirementAge]);

  // Find phase boundaries for reference lines
  const phaseBoundaries = useMemo(() => {
    const boundaries: { age: number; phase: string }[] = [];
    let currentPhase: string | null = null;

    for (const point of data) {
      if (point.phase !== currentPhase && point.phase) {
        boundaries.push({ age: point.age, phase: point.phase });
        currentPhase = point.phase;
      }
    }

    return boundaries;
  }, [data]);

  // Custom tooltip
  const CustomTooltip = ({
    active,
    payload,
  }: {
    active?: boolean;
    payload?: Array<{ payload: (typeof chartData)[0] }>;
  }) => {
    if (!active || !payload?.length) return null;

    const point = payload[0].payload;
    const phaseColor = PHASE_COLORS[point.phase ?? 'default'] ?? PHASE_COLORS.default;

    return (
      <div className="rounded-lg border bg-background p-3 shadow-md">
        <p className="font-medium">Age {point.age}</p>
        <div className="mt-1 space-y-1 text-sm">
          <p style={{ color: phaseColor }}>
            {point.phase ?? 'Flat'}: {formatTooltipCurrency(point.spending)}
            {showRealDollars && (
              <span className="text-muted-foreground ml-1">
                (today&apos;s dollars)
              </span>
            )}
          </p>
          {point.flatSpending !== null && (
            <p className="text-muted-foreground">
              Flat: {formatTooltipCurrency(point.flatSpending)}
            </p>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="space-y-4">
      {/* Controls */}
      <div className="flex items-center justify-between">
        <div className="flex gap-2">
          <button
            onClick={() => setShowFlat(!showFlat)}
            disabled={!flatData}
            className={`px-3 py-1 text-sm rounded-md border ${
              showFlat
                ? 'bg-primary text-primary-foreground'
                : 'bg-background text-foreground'
            } ${!flatData ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            {showFlat ? 'Hide' : 'Show'} Flat Comparison
          </button>
        </div>
        <div className="text-sm text-muted-foreground">
          {showRealDollars ? "Today's dollars" : 'Future dollars'}
        </div>
      </div>

      {/* Chart */}
      <div className="h-64 sm:h-80">
        <ResponsiveContainer width="100%" height="100%">
          <ComposedChart
            data={chartData}
            margin={{ top: 20, right: 10, left: 0, bottom: 0 }}
          >
            <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="hsl(var(--border))" />
            <XAxis
              dataKey="age"
              tick={{ fill: 'hsl(var(--muted-foreground))', fontSize: 12 }}
              stroke="hsl(var(--border))"
            />
            <YAxis
              tickFormatter={formatCurrency}
              tick={{ fill: 'hsl(var(--muted-foreground))', fontSize: 12 }}
              stroke="hsl(var(--border))"
              width={60}
            />
            <Tooltip content={<CustomTooltip />} />

            {/* Phase boundary reference lines */}
            {phaseBoundaries.slice(1).map((boundary) => (
              <ReferenceLine
                key={boundary.age}
                x={boundary.age}
                stroke="hsl(var(--muted-foreground))"
                strokeDasharray="5 5"
                label={{
                  value: boundary.phase,
                  position: 'top',
                  fill: 'hsl(var(--muted-foreground))',
                  fontSize: 10,
                }}
              />
            ))}

            {/* Flat spending comparison line */}
            {showFlat && flatData && (
              <Area
                type="monotone"
                dataKey="flatSpending"
                stroke="hsl(var(--muted-foreground))"
                fill="none"
                strokeDasharray="5 5"
                strokeWidth={1}
                connectNulls={false}
              />
            )}

            {/* Phased spending area */}
            <Area
              type="monotone"
              dataKey="spending"
              stroke="hsl(var(--primary))"
              fill="hsl(var(--primary))"
              fillOpacity={0.1}
              strokeWidth={2}
            />
          </ComposedChart>
        </ResponsiveContainer>
      </div>

      {/* Legend */}
      <div className="flex flex-wrap gap-4 text-sm">
        <div className="flex items-center gap-2">
          <div className="h-3 w-3 rounded-sm" style={{ backgroundColor: 'hsl(var(--primary))' }} />
          <span>Phased Spending</span>
        </div>
        {showFlat && flatData && (
          <div className="flex items-center gap-2">
            <div
              className="h-0 w-4 border-t-2 border-dashed"
              style={{ borderColor: 'hsl(var(--muted-foreground))' }}
            />
            <span>Flat Spending</span>
          </div>
        )}
        {phaseBoundaries.map((boundary) => (
          <div key={boundary.phase} className="flex items-center gap-2">
            <div
              className="h-3 w-3 rounded-sm"
              style={{
                backgroundColor: PHASE_COLORS[boundary.phase] ?? PHASE_COLORS.default,
                opacity: 0.5,
              }}
            />
            <span>{boundary.phase}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### 2. Export from projections components
**File**: `src/components/projections/index.ts`
**Changes**: Add export for new component

```typescript
export { SpendingTrajectoryChart } from './SpendingTrajectoryChart';
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Component renders without errors in Storybook or test
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Chart displays spending trajectory with correct values
- [ ] Phase boundaries are clearly marked
- [ ] Flat comparison toggle works when data provided
- [ ] Tooltip shows correct values
- [ ] Chart is responsive on mobile

**Implementation Note**: After completing this phase and all automated verification passes, pause here for visual review of the chart component before proceeding to the next phase.

---

## Phase 4: Spending Impact Summary Component

### Overview
Create the `SpendingImpactSummary` component that displays key comparison metrics.

### Changes Required:

#### 1. Create SpendingImpactSummary Component
**File**: `src/components/projections/SpendingImpactSummary.tsx` (NEW)
**Changes**: Create summary card component

```typescript
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { ArrowUp, ArrowDown, Minus, TrendingUp, TrendingDown, Calendar } from 'lucide-react';
import type { SpendingComparison } from '@/lib/projections/types';

interface SpendingImpactSummaryProps {
  comparison: SpendingComparison;
  retirementAge: number;
}

function formatCurrency(value: number): string {
  if (Math.abs(value) >= 1_000_000)
    return `$${(value / 1_000_000).toFixed(1)}M`;
  if (Math.abs(value) >= 1_000) return `$${Math.round(value / 1_000)}K`;
  return `$${Math.round(value)}`;
}

export function SpendingImpactSummary({
  comparison,
  retirementAge,
}: SpendingImpactSummaryProps) {
  const { flatSpending, phasedSpending, breakEvenAge, longevityDifference } = comparison;

  // Calculate differences
  const spendingDifference =
    phasedSpending.totalLifetimeSpending - flatSpending.totalLifetimeSpending;
  const balanceDifference = phasedSpending.endingBalance - flatSpending.endingBalance;

  // Determine impact direction for each metric
  const earlyYearsBonusPositive = phasedSpending.earlyYearsBonus > 0;
  const longevityPositive = longevityDifference >= 0;

  return (
    <div className="space-y-4">
      <h3 className="text-lg font-semibold">Spending Strategy Comparison</h3>
      <p className="text-sm text-muted-foreground">
        How phased spending compares to flat spending over your retirement.
      </p>

      <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
        {/* Early Years Bonus */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground flex items-center gap-2">
              <TrendingUp className="h-4 w-4" />
              Early Years ({phasedSpending.earlyYearsCount} yrs)
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-baseline gap-2">
              <span
                className={`text-2xl font-bold ${
                  earlyYearsBonusPositive ? 'text-success' : 'text-muted-foreground'
                }`}
              >
                {earlyYearsBonusPositive ? '+' : ''}
                {formatCurrency(phasedSpending.earlyYearsBonus)}
              </span>
            </div>
            <p className="text-xs text-muted-foreground mt-1">
              {earlyYearsBonusPositive
                ? 'More spending in early retirement'
                : 'Same spending pattern'}
            </p>
          </CardContent>
        </Card>

        {/* Portfolio Longevity */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground flex items-center gap-2">
              <Calendar className="h-4 w-4" />
              Portfolio Longevity
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-baseline gap-2">
              {longevityDifference === 0 ? (
                <Minus className="h-5 w-5 text-muted-foreground" />
              ) : longevityPositive ? (
                <ArrowUp className="h-5 w-5 text-success" />
              ) : (
                <ArrowDown className="h-5 w-5 text-destructive" />
              )}
              <span
                className={`text-2xl font-bold ${
                  longevityDifference === 0
                    ? 'text-muted-foreground'
                    : longevityPositive
                    ? 'text-success'
                    : 'text-destructive'
                }`}
              >
                {longevityDifference === 0
                  ? 'Same'
                  : `${Math.abs(longevityDifference)} yr${Math.abs(longevityDifference) !== 1 ? 's' : ''}`}
              </span>
            </div>
            <p className="text-xs text-muted-foreground mt-1">
              {longevityDifference === 0
                ? 'No change in portfolio duration'
                : longevityPositive
                ? 'Longer portfolio life with phased'
                : 'Shorter portfolio life with phased'}
            </p>
          </CardContent>
        </Card>

        {/* Break-Even Age */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground flex items-center gap-2">
              <TrendingDown className="h-4 w-4" />
              Break-Even Point
            </CardTitle>
          </CardHeader>
          <CardContent>
            <span className="text-2xl font-bold">
              {breakEvenAge !== null ? `Age ${breakEvenAge}` : 'Never'}
            </span>
            <p className="text-xs text-muted-foreground mt-1">
              {breakEvenAge !== null
                ? `After ${breakEvenAge - retirementAge} years of retirement`
                : 'Cumulative spending never equals'}
            </p>
          </CardContent>
        </Card>

        {/* Ending Balance Difference */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground flex items-center gap-2">
              Ending Balance
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-baseline gap-2">
              {balanceDifference === 0 ? (
                <Minus className="h-5 w-5 text-muted-foreground" />
              ) : balanceDifference > 0 ? (
                <ArrowUp className="h-5 w-5 text-success" />
              ) : (
                <ArrowDown className="h-5 w-5 text-warning" />
              )}
              <span
                className={`text-2xl font-bold ${
                  balanceDifference === 0
                    ? 'text-muted-foreground'
                    : balanceDifference > 0
                    ? 'text-success'
                    : 'text-warning'
                }`}
              >
                {balanceDifference === 0
                  ? 'Same'
                  : `${balanceDifference > 0 ? '+' : ''}${formatCurrency(balanceDifference)}`}
              </span>
            </div>
            <p className="text-xs text-muted-foreground mt-1">
              Difference at age 90
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Detailed comparison table */}
      <Card>
        <CardContent className="pt-4">
          <table className="w-full text-sm">
            <thead>
              <tr className="border-b">
                <th className="text-left py-2 font-medium">Metric</th>
                <th className="text-right py-2 font-medium">Flat</th>
                <th className="text-right py-2 font-medium">Phased</th>
              </tr>
            </thead>
            <tbody>
              <tr className="border-b">
                <td className="py-2">Total Lifetime Spending</td>
                <td className="text-right py-2">
                  {formatCurrency(flatSpending.totalLifetimeSpending)}
                </td>
                <td className="text-right py-2">
                  {formatCurrency(phasedSpending.totalLifetimeSpending)}
                </td>
              </tr>
              <tr className="border-b">
                <td className="py-2">Portfolio Depletes At</td>
                <td className="text-right py-2">
                  {flatSpending.portfolioDepletionAge !== null
                    ? `Age ${flatSpending.portfolioDepletionAge}`
                    : 'Never'}
                </td>
                <td className="text-right py-2">
                  {phasedSpending.portfolioDepletionAge !== null
                    ? `Age ${phasedSpending.portfolioDepletionAge}`
                    : 'Never'}
                </td>
              </tr>
              <tr>
                <td className="py-2">Ending Balance (Age 90)</td>
                <td className="text-right py-2">
                  {formatCurrency(flatSpending.endingBalance)}
                </td>
                <td className="text-right py-2">
                  {formatCurrency(phasedSpending.endingBalance)}
                </td>
              </tr>
            </tbody>
          </table>
        </CardContent>
      </Card>
    </div>
  );
}
```

#### 2. Export from projections components
**File**: `src/components/projections/index.ts`
**Changes**: Add export for new component

```typescript
export { SpendingImpactSummary } from './SpendingImpactSummary';
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Component renders without errors
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] All metrics display correctly with sample data
- [ ] Neutral framing in all copy (no penalty language)
- [ ] Responsive layout on mobile

**Implementation Note**: After completing this phase and all automated verification passes, pause here for copy review to ensure neutral framing before proceeding to the next phase.

---

## Phase 5: Compare Tab Integration

### Overview
Add a "Compare" tab to the Plans page that shows the spending comparison view.

### Changes Required:

#### 1. Create SpendingCompareTab Component
**File**: `src/components/projections/SpendingCompareTab.tsx` (NEW)
**Changes**: Create the comparison tab content

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Loader2, AlertCircle } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { SpendingTrajectoryChart } from './SpendingTrajectoryChart';
import { SpendingImpactSummary } from './SpendingImpactSummary';
import type { SpendingComparison, SpendingComparisonResponse } from '@/lib/projections/types';

interface SpendingCompareTabProps {
  retirementAge: number;
  inflationRate: number;
}

export function SpendingCompareTab({
  retirementAge,
  inflationRate,
}: SpendingCompareTabProps) {
  const [comparison, setComparison] = useState<SpendingComparison | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchComparison = async () => {
      setIsLoading(true);
      setError(null);

      try {
        const response = await fetch('/api/projections/compare', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({}),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.message || 'Failed to load comparison');
        }

        const data: SpendingComparisonResponse = await response.json();
        setComparison(data.comparison);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load comparison');
      } finally {
        setIsLoading(false);
      }
    };

    fetchComparison();
  }, []);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-12">
        <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        <span className="ml-2 text-muted-foreground">
          Calculating spending comparison...
        </span>
      </div>
    );
  }

  if (error) {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Unable to Compare</AlertTitle>
        <AlertDescription>{error}</AlertDescription>
      </Alert>
    );
  }

  if (!comparison) {
    return (
      <Alert>
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>No Comparison Available</AlertTitle>
        <AlertDescription>
          Configure spending phases in your profile to see how phased spending
          compares to flat spending.
        </AlertDescription>
      </Alert>
    );
  }

  return (
    <div className="space-y-8">
      {/* Impact Summary */}
      <SpendingImpactSummary
        comparison={comparison}
        retirementAge={retirementAge}
      />

      {/* Spending Trajectory Chart */}
      <div>
        <h3 className="text-lg font-semibold mb-2">Spending Trajectory</h3>
        <p className="text-sm text-muted-foreground mb-4">
          How your annual spending changes throughout retirement
        </p>
        <SpendingTrajectoryChart
          data={comparison.phasedSpending.yearlySpending}
          flatData={comparison.flatSpending.yearlySpending}
          showRealDollars={true}
          inflationRate={inflationRate}
          retirementAge={retirementAge}
        />
      </div>
    </div>
  );
}
```

#### 2. Update PlansClient with Tab Navigation
**File**: `src/app/plans/plans-client.tsx`
**Changes**: Add tab navigation for Assets/Compare views

This requires modifying the existing PlansClient to add tabs. The key changes:

1. Add state for active tab
2. Add tab navigation UI
3. Conditionally render ProjectionChart or SpendingCompareTab based on active tab

```typescript
// Add to imports at top of file
import { SpendingCompareTab } from '@/components/projections';

// Add state for active tab (after line 44)
const [activeTab, setActiveTab] = useState<'assets' | 'compare'>('assets');

// Add tab navigation before the chart section (around line 443)
// Replace the existing chart section with:
{/* Tab Navigation */}
<div className="border-b">
  <nav className="flex gap-4" aria-label="Projection views">
    <button
      onClick={() => setActiveTab('assets')}
      className={`py-2 text-sm font-medium border-b-2 -mb-px transition-colors ${
        activeTab === 'assets'
          ? 'border-primary text-primary'
          : 'border-transparent text-muted-foreground hover:text-foreground'
      }`}
    >
      Assets Over Time
    </button>
    <button
      onClick={() => setActiveTab('compare')}
      className={`py-2 text-sm font-medium border-b-2 -mb-px transition-colors ${
        activeTab === 'compare'
          ? 'border-primary text-primary'
          : 'border-transparent text-muted-foreground hover:text-foreground'
      }`}
    >
      Compare Spending
    </button>
  </nav>
</div>

{/* Tab Content */}
{activeTab === 'assets' ? (
  <div>
    <h2 className="text-lg font-semibold mb-2">Assets Over Time</h2>
    <p className="text-sm text-muted-foreground mb-4">
      Your projected balance from age {currentAge} to 90
    </p>
    <ProjectionChart
      records={projection.records}
      retirementAge={assumptions.retirementAge}
      currentAge={currentAge}
      inflationRate={assumptions.inflationRate}
      shortfallAge={shortfallAge}
    />
  </div>
) : (
  <SpendingCompareTab
    retirementAge={assumptions.retirementAge}
    inflationRate={assumptions.inflationRate}
  />
)}
```

#### 3. Export SpendingCompareTab from projections
**File**: `src/components/projections/index.ts`
**Changes**: Add export

```typescript
export { SpendingCompareTab } from './SpendingCompareTab';
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Build succeeds: `npm run build`
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Tab navigation works correctly
- [ ] Compare tab loads and displays comparison data
- [ ] Error state shows when spending phases not configured
- [ ] Tab state persists during assumption changes
- [ ] Mobile responsive layout works

**Implementation Note**: After completing this phase and all automated verification passes, pause here for full end-to-end manual testing before considering the implementation complete.

---

## Phase 6: Unit Tests

### Overview
Add unit tests for the spending comparison logic.

### Changes Required:

#### 1. Create Spending Comparison Tests
**File**: `src/lib/projections/__tests__/spending-comparison.test.ts` (NEW)
**Changes**: Create comprehensive test suite

```typescript
import { describe, it, expect } from 'vitest';
import { calculateSpendingComparison } from '../spending-comparison';
import type { ProjectionInput, SpendingPhaseConfig } from '../types';

// Helper to create base input
function createBaseInput(overrides: Partial<ProjectionInput> = {}): ProjectionInput {
  return {
    currentAge: 40,
    retirementAge: 65,
    maxAge: 90,
    balancesByType: { taxDeferred: 500000, taxFree: 100000, taxable: 50000 },
    annualContribution: 20000,
    contributionAllocation: { taxDeferred: 60, taxFree: 20, taxable: 20 },
    expectedReturn: 0.06,
    inflationRate: 0.025,
    contributionGrowthRate: 0.02,
    annualEssentialExpenses: 40000,
    annualDiscretionaryExpenses: 20000,
    annualExpenses: 60000,
    annualHealthcareCosts: 5000,
    healthcareInflationRate: 0.04,
    incomeStreams: [
      {
        id: 'ss',
        name: 'Social Security',
        type: 'social_security',
        annualAmount: 24000,
        startAge: 67,
        inflationAdjusted: true,
        isGuaranteed: true,
      },
    ],
    annualDebtPayments: 0,
    ...overrides,
  };
}

const defaultPhases: SpendingPhaseConfig = {
  enabled: true,
  phases: [
    {
      id: 'gogo',
      name: 'Go-Go Years',
      startAge: 65,
      essentialMultiplier: 1.0,
      discretionaryMultiplier: 1.1,
    },
    {
      id: 'slowgo',
      name: 'Slow-Go',
      startAge: 75,
      essentialMultiplier: 0.95,
      discretionaryMultiplier: 0.75,
    },
    {
      id: 'nogo',
      name: 'No-Go',
      startAge: 85,
      essentialMultiplier: 0.9,
      discretionaryMultiplier: 0.5,
    },
  ],
};

describe('calculateSpendingComparison', () => {
  it('returns valid comparison structure', () => {
    const input = createBaseInput({ spendingPhaseConfig: defaultPhases });
    const result = calculateSpendingComparison(input);

    expect(result).toHaveProperty('flatSpending');
    expect(result).toHaveProperty('phasedSpending');
    expect(result).toHaveProperty('breakEvenAge');
    expect(result).toHaveProperty('longevityDifference');

    expect(result.flatSpending).toHaveProperty('totalLifetimeSpending');
    expect(result.flatSpending).toHaveProperty('portfolioDepletionAge');
    expect(result.flatSpending).toHaveProperty('endingBalance');
    expect(result.flatSpending).toHaveProperty('yearlySpending');

    expect(result.phasedSpending).toHaveProperty('totalLifetimeSpending');
    expect(result.phasedSpending).toHaveProperty('portfolioDepletionAge');
    expect(result.phasedSpending).toHaveProperty('endingBalance');
    expect(result.phasedSpending).toHaveProperty('yearlySpending');
    expect(result.phasedSpending).toHaveProperty('earlyYearsBonus');
    expect(result.phasedSpending).toHaveProperty('earlyYearsCount');
  });

  it('calculates positive early years bonus with front-loaded spending', () => {
    const input = createBaseInput({ spendingPhaseConfig: defaultPhases });
    const result = calculateSpendingComparison(input);

    // Go-Go phase has 110% discretionary multiplier, so early spending should be higher
    expect(result.phasedSpending.earlyYearsBonus).toBeGreaterThan(0);
  });

  it('calculates break-even age when spending patterns cross', () => {
    const input = createBaseInput({ spendingPhaseConfig: defaultPhases });
    const result = calculateSpendingComparison(input);

    // With front-loaded spending, there should be a break-even point
    // where cumulative phased spending equals cumulative flat spending
    if (result.breakEvenAge !== null) {
      expect(result.breakEvenAge).toBeGreaterThan(input.retirementAge);
      expect(result.breakEvenAge).toBeLessThanOrEqual(input.maxAge);
    }
  });

  it('returns correct yearlySpending array length', () => {
    const input = createBaseInput({ spendingPhaseConfig: defaultPhases });
    const result = calculateSpendingComparison(input);

    const retirementYears = input.maxAge - input.retirementAge + 1;
    expect(result.flatSpending.yearlySpending.length).toBe(retirementYears);
    expect(result.phasedSpending.yearlySpending.length).toBe(retirementYears);
  });

  it('includes phase info in phased yearly spending', () => {
    const input = createBaseInput({ spendingPhaseConfig: defaultPhases });
    const result = calculateSpendingComparison(input);

    // First year should be Go-Go
    expect(result.phasedSpending.yearlySpending[0].phase).toBe('Go-Go Years');

    // Year 10 (age 75) should be Slow-Go
    const slowGoEntry = result.phasedSpending.yearlySpending.find(
      (y) => y.age === 75
    );
    expect(slowGoEntry?.phase).toBe('Slow-Go');
  });

  it('respects custom earlyYearsCount parameter', () => {
    const input = createBaseInput({ spendingPhaseConfig: defaultPhases });
    const result5 = calculateSpendingComparison(input, 5);
    const result15 = calculateSpendingComparison(input, 15);

    expect(result5.phasedSpending.earlyYearsCount).toBe(5);
    expect(result15.phasedSpending.earlyYearsCount).toBe(15);

    // Different early years counts should produce different bonuses
    expect(result5.phasedSpending.earlyYearsBonus).not.toBe(
      result15.phasedSpending.earlyYearsBonus
    );
  });

  it('handles phases disabled gracefully', () => {
    const input = createBaseInput({
      spendingPhaseConfig: { enabled: false, phases: defaultPhases.phases },
    });
    const result = calculateSpendingComparison(input);

    // Both strategies should be essentially the same when phases are disabled
    expect(result.phasedSpending.earlyYearsBonus).toBe(0);
    expect(result.flatSpending.totalLifetimeSpending).toBeCloseTo(
      result.phasedSpending.totalLifetimeSpending,
      -2
    );
  });

  it('handles no spending phases configured', () => {
    const input = createBaseInput({ spendingPhaseConfig: undefined });
    const result = calculateSpendingComparison(input);

    // Both strategies should be the same
    expect(result.phasedSpending.earlyYearsBonus).toBe(0);
    expect(Math.abs(result.flatSpending.totalLifetimeSpending - result.phasedSpending.totalLifetimeSpending)).toBeLessThan(100);
  });
});
```

### Success Criteria:

#### Automated Verification:
- [x] All unit tests pass: `npm test -- spending-comparison`
- [x] Test coverage meets minimum threshold

#### Manual Verification:
- [ ] Tests cover expected scenarios from acceptance criteria

---

## Testing Strategy

### Unit Tests
- `calculateSpendingComparison()` function with various inputs
- Edge cases: no phases, phases disabled, single phase
- Break-even calculation accuracy
- Early years bonus calculation

### Integration Tests
- `/api/projections/compare` endpoint responses
- Error handling for missing data
- Authentication requirements

### Manual Testing Steps
1. Navigate to Plans page as authenticated user
2. Click "Compare Spending" tab
3. Verify comparison metrics match expected calculations
4. Verify spending trajectory chart shows correct phase boundaries
5. Test on mobile device for responsive layout
6. Test with spending phases disabled (should show appropriate message)
7. Test after modifying spending phase configuration

## Performance Considerations

- Comparison runs two full projections - should complete in <500ms
- Chart data is pre-computed by API to minimize client-side processing
- Tab content lazy-loads comparison data only when tab is selected
- Consider adding caching for comparison results if performance becomes an issue

## Migration Notes

No data migration required. The feature uses existing `spendingPhases` data from the financial snapshot.

## References

- Original research: `thoughts/shared/research/2026-01-21-ENG-9.2-front-loaded-spending-gap-analysis.md`
- Story 9.2 scope: `thoughts/personal/tickets/epic-9/story-2-scope.md`
- Story 9.3 scope: `thoughts/personal/tickets/epic-9/story-3-scope.md`
- Story 9.1 implementation plan: `thoughts/shared/plans/2026-01-19-ENG-9.1-phase-based-spending-implementation.md`
- Existing engine implementation: `src/lib/projections/engine.ts:139-166`
- Existing chart patterns: `src/components/projections/ProjectionChart.tsx`
