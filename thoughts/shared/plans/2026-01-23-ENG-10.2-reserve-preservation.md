# Story 10.2: Reserve Preservation Implementation Plan

## Overview

Implement reserve preservation functionality that allows users to protect a portion of their portfolio as a safety buffer. This extends the existing depletion target (Story 10.1) to enforce a "reserve floor" during projection calculations, preventing withdrawals from dipping below a user-specified threshold.

## Current State Analysis

### Existing Infrastructure (Story 10.1)
- **Type Definition**: `DepletionTarget` interface at [types.ts:103-107](src/lib/projections/types.ts#L103-L107)
- **UI Component**: `DepletionTargetInput` at [depletion-target-input.tsx](src/components/depletion-target-input.tsx)
- **Database**: JSONB column `depletion_target` in `financial_snapshot` table
- **Validation**: Zod schema at [projections.ts:55-66](src/lib/validation/projections.ts#L55-L66)

### Current Gaps
- Depletion target is NOT passed to the projection engine (exists in type but not populated)
- No reserve floor calculation in input-builder
- Engine has no mechanism to constrain withdrawals based on reserve
- No reserve-related fields in `ProjectionRecord` or `ProjectionSummary`

## Desired End State

After implementation:
1. Users can set a reserve amount (derived from depletion %, custom %, or absolute $)
2. The projection engine respects the reserve floor during withdrawals
3. When reserve is threatened, spending reduces in two stages: discretionary first, then essentials
4. Charts show dual-area visualization (available vs reserve zones)
5. Reserve runway is calculated and displayed (years of essential expense coverage)

### Verification Criteria
- Setting a 25% reserve with $1M portfolio creates a $250k floor
- Projections stop withdrawing when balance reaches reserve floor
- UI shows reserve settings alongside depletion target
- Chart displays green "available" and amber "reserve" zones
- Reserve runway calculation appears in summary

## What We're NOT Doing

- **No separate database column** - Reserve config lives within the existing `DepletionTarget` JSONB
- **No new API endpoints** - Uses existing `/api/profile` PATCH
- **No "hard stop" behavior** - When reserve is breached, spending reduces gracefully rather than stopping
- **No integration with income floor calculations** - These remain separate (per design decision in research doc)

## Implementation Approach

The implementation extends Story 10.1 patterns while adding new engine logic for reserve enforcement. We prioritize backward compatibility - existing projections continue to work unchanged.

---

## Phase 1: Extend Data Model & Types

### Overview
Add `ReserveConfig` type and extend `DepletionTarget` to include reserve settings.

### Changes Required:

#### 1. Type Definitions
**File**: [src/lib/projections/types.ts](src/lib/projections/types.ts)

Add after line 107 (after `DepletionTarget`):
```typescript
/**
 * Epic 10.2: Reserve Preservation Configuration
 * Defines how much portfolio should be protected from spending
 */
export type ReserveType = 'derived' | 'percentage' | 'absolute';

export type ReservePurpose =
  | 'longevity'
  | 'emergency'
  | 'legacy'
  | 'healthcare'
  | 'peace_of_mind';

export interface ReserveConfig {
  /** How reserve is specified */
  type: ReserveType;
  /** Amount (only used if type is 'percentage' or 'absolute') */
  amount?: number;
  /** Optional purposes for documentation (does not affect calculations) */
  purposes?: ReservePurpose[];
  /** Optional notes */
  notes?: string;
}
```

Extend `DepletionTarget` interface (modify lines 103-107):
```typescript
export interface DepletionTarget {
  enabled: boolean;
  targetPercentageSpent: number;  // 0-100
  targetAge: number;
  /** Epic 10.2: Reserve preservation configuration */
  reserve?: ReserveConfig;
}
```

Add to `ProjectionInput` after line 158:
```typescript
/** Epic 10.2: Pre-calculated absolute reserve floor amount */
reserveFloor?: number;
```

Extend `ProjectionRecord` (add after line 216):
```typescript
// Epic 10.2: Reserve tracking
/** Amount above reserve floor (undefined if no reserve configured) */
reserveBalance?: number;
/** Whether withdrawal was constrained by reserve this year */
reserveConstrained?: boolean;
/** Stage of spending reduction: none, discretionary_reduced, essentials_only, essentials_reduced */
reductionStage?: 'none' | 'discretionary_reduced' | 'essentials_only' | 'essentials_reduced';
/** Actual essential spending after reserve constraint (may be less than planned) */
actualEssentialSpending?: number;
/** Actual discretionary spending after reserve constraint (may be less than planned) */
actualDiscretionarySpending?: number;
/** Unmet spending need due to reserve constraint */
spendingShortfall?: number;
```

Extend `ProjectionSummary` (add after line 228):
```typescript
// Epic 10.2: Reserve summary
/** The absolute dollar reserve floor (undefined if no reserve) */
reserveFloor?: number;
/** Number of years where spending was constrained by reserve */
yearsReserveConstrained?: number;
/** First age when discretionary spending was reduced due to reserve */
firstReserveConstraintAge?: number | null;
/** First age when reduced to essentials only */
firstEssentialsOnlyAge?: number | null;
```

Extend `WithdrawalResult` (add after line 244):
```typescript
/** Whether withdrawal was limited by reserve floor */
reserveConstrained?: boolean;
/** Unmet withdrawal need due to reserve constraint */
reserveShortfall?: number;
```

#### 2. Database Schema Type
**File**: [src/db/schema/financial-snapshot.ts](src/db/schema/financial-snapshot.ts)

Update `DepletionTargetJson` type (around line 70-75):
```typescript
export type ReserveConfigJson = {
  type: 'derived' | 'percentage' | 'absolute';
  amount?: number;
  purposes?: ('longevity' | 'emergency' | 'legacy' | 'healthcare' | 'peace_of_mind')[];
  notes?: string;
};

export type DepletionTargetJson = {
  enabled: boolean;
  targetPercentageSpent: number;
  targetAge: number;
  reserve?: ReserveConfigJson;
};
```

#### 3. Validation Schema
**File**: [src/lib/validation/projections.ts](src/lib/validation/projections.ts)

Add after line 66 (after `depletionTargetSchema`):
```typescript
/**
 * Epic 10.2: Reserve configuration validation schema
 */
export const reserveConfigSchema = z.object({
  type: z.enum(['derived', 'percentage', 'absolute']),
  amount: z.number().min(0).optional(),
  purposes: z.array(z.enum([
    'longevity', 'emergency', 'legacy', 'healthcare', 'peace_of_mind'
  ])).optional(),
  notes: z.string().max(500).optional(),
}).refine(
  (data) => {
    // Amount required for percentage and absolute types
    if (data.type !== 'derived' && data.amount === undefined) {
      return false;
    }
    return true;
  },
  { message: 'Amount is required for percentage and absolute reserve types' }
);

/**
 * Extended depletion target schema with reserve
 */
export const depletionTargetWithReserveSchema = depletionTargetSchema.extend({
  reserve: reserveConfigSchema.optional(),
});
```

Add runtime validation function after `validateDepletionTarget`:
```typescript
/**
 * Validate reserve configuration with runtime context
 */
export function validateReserveConfig(
  reserve: ReserveConfig | undefined,
  depletionTarget: DepletionTarget,
  portfolioValue: number
): { valid: boolean; errors: string[]; warnings: string[] } {
  const errors: string[] = [];
  const warnings: string[] = [];

  if (!reserve) {
    return { valid: true, errors, warnings };
  }

  // Validate absolute amount doesn't exceed portfolio
  if (reserve.type === 'absolute' && reserve.amount !== undefined) {
    if (reserve.amount > portfolioValue) {
      errors.push('Reserve amount cannot exceed current portfolio value');
    }
  }

  // Validate percentage is reasonable
  if (reserve.type === 'percentage' && reserve.amount !== undefined) {
    if (reserve.amount > 100) {
      errors.push('Reserve percentage cannot exceed 100%');
    }
  }

  // Warn about consistency between depletion and reserve
  if (reserve.type !== 'derived') {
    const impliedReserve = 100 - depletionTarget.targetPercentageSpent;
    const actualReserve = reserve.type === 'percentage'
      ? reserve.amount ?? 0
      : ((reserve.amount ?? 0) / portfolioValue) * 100;

    if (Math.abs(impliedReserve - actualReserve) > 5) {
      warnings.push(
        `Depletion target implies ${impliedReserve.toFixed(0)}% reserve, ` +
        `but reserve is set to ${actualReserve.toFixed(0)}%`
      );
    }
  }

  return { valid: errors.length === 0, errors, warnings };
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles without errors: `npm run typecheck`
- [x] Validation schemas parse correctly in tests
- [x] Existing tests pass: `npm test` (pre-existing failures unrelated to changes)

#### Manual Verification:
- [ ] Verify type definitions are correctly inferred in IDE

**Implementation Note**: After completing this phase and all automated verification passes, pause here for confirmation before proceeding.

---

## Phase 2: Engine Integration

### Overview
Add reserve floor calculation to input-builder and modify the projection engine to respect reserve constraints during withdrawals.

### Changes Required:

#### 1. Input Builder - Calculate Reserve Floor
**File**: [src/lib/projections/input-builder.ts](src/lib/projections/input-builder.ts)

Add import at top:
```typescript
import type { ReserveConfig, DepletionTarget } from './types';
```

Add helper function after line 34 (before `buildProjectionInputFromSnapshot`):
```typescript
/**
 * Calculate the absolute reserve floor from reserve configuration
 */
function calculateReserveFloor(
  reserve: ReserveConfig | undefined,
  initialPortfolio: number,
  depletionTarget: DepletionTarget
): number | undefined {
  if (!reserve || !depletionTarget.enabled) {
    return undefined;
  }

  switch (reserve.type) {
    case 'derived':
      // Reserve = 100% - targetPercentageSpent
      return initialPortfolio * (1 - depletionTarget.targetPercentageSpent / 100);
    case 'percentage':
      return initialPortfolio * ((reserve.amount ?? 0) / 100);
    case 'absolute':
      return reserve.amount ?? 0;
    default:
      return undefined;
  }
}
```

Update `ProjectionOverrides` interface (add after line 33):
```typescript
// Epic 10.2: Depletion target with reserve
depletionTarget?: DepletionTarget;
```

Update `buildProjectionInputFromSnapshot` function to include reserve floor calculation (add before the return statement, around line 130):
```typescript
// Epic 10.2: Calculate reserve floor from depletion target
const depletionTarget = overrides.depletionTarget
  ?? (snapshot.depletionTarget as DepletionTarget | null)
  ?? undefined;

const totalPortfolio = balancesByType.taxDeferred + balancesByType.taxFree + balancesByType.taxable;
const reserveFloor = depletionTarget?.reserve
  ? calculateReserveFloor(depletionTarget.reserve, totalPortfolio, depletionTarget)
  : undefined;
```

Add to the return object (add after `spendingPhaseConfig,`):
```typescript
depletionTarget,
reserveFloor,
```

#### 2. Engine - Reserve-Constrained Spending
**File**: [src/lib/projections/engine.ts](src/lib/projections/engine.ts)

Add new type for reserve-constrained withdrawal result after imports:
```typescript
/**
 * Epic 10.2: Result of reserve-constrained spending calculation
 */
interface ReserveConstrainedSpending {
  essentialWithdrawal: number;
  discretionaryWithdrawal: number;
  totalWithdrawal: number;
  reductionStage: 'none' | 'discretionary_reduced' | 'essentials_only' | 'essentials_reduced';
  shortfall: number;
  reserveConstrained: boolean;
}
```

Add helper function after `calculatePhaseAdjustedExpenses` (around line 166):
```typescript
/**
 * Epic 10.2: Calculate spending constrained by reserve floor
 *
 * Two-stage reduction:
 * 1. Reduce discretionary proportionally, preserve essentials
 * 2. If still insufficient, reduce to essentials only
 * 3. If even essentials can't be covered, reduce essentials
 */
function calculateReserveConstrainedSpending(
  balances: BalanceByType,
  essentialExpenses: number,
  discretionaryExpenses: number,
  totalIncome: number,
  reserveFloor: number | undefined
): ReserveConstrainedSpending {
  const currentTotal = totalBalance(balances);

  // No reserve configured - no constraint
  if (reserveFloor === undefined) {
    const totalNeeded = Math.max(0, essentialExpenses + discretionaryExpenses - totalIncome);
    return {
      essentialWithdrawal: Math.max(0, essentialExpenses - totalIncome),
      discretionaryWithdrawal: discretionaryExpenses,
      totalWithdrawal: totalNeeded,
      reductionStage: 'none',
      shortfall: 0,
      reserveConstrained: false,
    };
  }

  const availableAboveReserve = Math.max(0, currentTotal - reserveFloor);

  // Calculate what's needed from portfolio (after income)
  const essentialFromPortfolio = Math.max(0, essentialExpenses - totalIncome);
  const discretionaryFromPortfolio = discretionaryExpenses; // Discretionary fully from portfolio
  const totalNeeded = essentialFromPortfolio + discretionaryFromPortfolio;

  // Stage 1: No constraint needed
  if (availableAboveReserve >= totalNeeded) {
    return {
      essentialWithdrawal: essentialFromPortfolio,
      discretionaryWithdrawal: discretionaryFromPortfolio,
      totalWithdrawal: totalNeeded,
      reductionStage: 'none',
      shortfall: 0,
      reserveConstrained: false,
    };
  }

  // Stage 2: Reduce discretionary proportionally, preserve essentials
  if (availableAboveReserve >= essentialFromPortfolio) {
    const remainingForDiscretionary = availableAboveReserve - essentialFromPortfolio;
    return {
      essentialWithdrawal: essentialFromPortfolio,
      discretionaryWithdrawal: remainingForDiscretionary,
      totalWithdrawal: availableAboveReserve,
      reductionStage: 'discretionary_reduced',
      shortfall: discretionaryFromPortfolio - remainingForDiscretionary,
      reserveConstrained: true,
    };
  }

  // Stage 3: Essentials only (no discretionary)
  if (availableAboveReserve > 0) {
    return {
      essentialWithdrawal: availableAboveReserve,
      discretionaryWithdrawal: 0,
      totalWithdrawal: availableAboveReserve,
      reductionStage: 'essentials_only',
      shortfall: essentialFromPortfolio - availableAboveReserve + discretionaryFromPortfolio,
      reserveConstrained: true,
    };
  }

  // Stage 4: Reserve depleted - nothing available
  return {
    essentialWithdrawal: 0,
    discretionaryWithdrawal: 0,
    totalWithdrawal: 0,
    reductionStage: 'essentials_reduced',
    shortfall: totalNeeded,
    reserveConstrained: true,
  };
}
```

#### 3. Engine - Modify Drawdown Logic
**File**: [src/lib/projections/engine.ts](src/lib/projections/engine.ts)

Update the `runProjection` function. Add tracking variables after line 183:
```typescript
// Epic 10.2: Reserve tracking
let yearsReserveConstrained = 0;
let firstReserveConstraintAge: number | null = null;
let firstEssentialsOnlyAge: number | null = null;
```

Modify the drawdown section (lines 222-289). Replace lines 252-272 with:
```typescript
// Epic 10.2: Calculate reserve-constrained spending
const spendingResult = calculateReserveConstrainedSpending(
  balances,
  essentialExpenses,
  discretionaryExpenses,
  totalIncome,
  input.reserveFloor
);

// Execute tax-aware withdrawal with constrained amount
const withdrawalResult = withdrawFromAccounts(spendingResult.totalWithdrawal, balances);
withdrawalsByType = withdrawalResult.withdrawals;

// Update balances
balances = subtractWithdrawals(balances, withdrawalResult.withdrawals);

// Apply returns to remaining balance
balances = applyReturns(balances, input.expectedReturn);

// Track totals
const actualWithdrawal = withdrawalResult.withdrawals.taxDeferred +
  withdrawalResult.withdrawals.taxFree +
  withdrawalResult.withdrawals.taxable;

inflows = totalIncome;
outflows = essentialExpenses + discretionaryExpenses + healthcareExpenses; // Original planned
totalWithdrawals += actualWithdrawal;

// Epic 10.2: Track reserve constraints
if (spendingResult.reserveConstrained) {
  yearsReserveConstrained++;
  if (firstReserveConstraintAge === null) {
    firstReserveConstraintAge = age;
  }
  if (spendingResult.reductionStage === 'essentials_only' ||
      spendingResult.reductionStage === 'essentials_reduced') {
    if (firstEssentialsOnlyAge === null) {
      firstEssentialsOnlyAge = age;
    }
  }
}

// Track depletion year
if (yearsUntilDepletion === null && totalBalance(balances) <= 0) {
  yearsUntilDepletion = yearsFromStart;
}
```

Add new variables for reserve tracking in the record (declare after existing ones around line 200):
```typescript
let currentReserveBalance: number | undefined;
let currentReserveConstrained: boolean | undefined;
let currentReductionStage: 'none' | 'discretionary_reduced' | 'essentials_only' | 'essentials_reduced' | undefined;
let currentActualEssential: number | undefined;
let currentActualDiscretionary: number | undefined;
let currentShortfall: number | undefined;
```

Set these values after the reserve tracking (after `if (firstEssentialsOnlyAge === null)`):
```typescript
// Set reserve tracking fields for record
currentReserveBalance = input.reserveFloor !== undefined
  ? Math.max(0, totalBalance(balances) - input.reserveFloor)
  : undefined;
currentReserveConstrained = spendingResult.reserveConstrained;
currentReductionStage = spendingResult.reductionStage;
currentActualEssential = spendingResult.essentialWithdrawal + Math.min(totalIncome, essentialExpenses);
currentActualDiscretionary = spendingResult.discretionaryWithdrawal;
currentShortfall = spendingResult.shortfall;
```

Update the record push (add after `activePhaseName`):
```typescript
// Epic 10.2: Reserve tracking
reserveBalance: currentReserveBalance,
reserveConstrained: currentReserveConstrained,
reductionStage: currentReductionStage,
actualEssentialSpending: currentActualEssential,
actualDiscretionarySpending: currentActualDiscretionary,
spendingShortfall: currentShortfall,
```

Update the summary return (add after `projectedRetirementBalance`):
```typescript
// Epic 10.2: Reserve summary
reserveFloor: input.reserveFloor,
yearsReserveConstrained,
firstReserveConstraintAge,
firstEssentialsOnlyAge,
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `npm run typecheck`
- [x] Unit tests pass: `npm test` (pre-existing failures unrelated to changes)
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Create projection with 25% reserve on $1M portfolio
- [ ] Verify withdrawals stop at $250k floor
- [ ] Verify `yearsReserveConstrained` > 0 in summary when floor is hit

**Implementation Note**: After completing this phase and all automated verification passes, pause for manual testing confirmation.

---

## Phase 3: UI Component Extension

### Overview
Extend the existing `DepletionTargetInput` component to include reserve configuration with mode selection and purpose tags.

### Changes Required:

#### 1. Reserve Purposes Constant
**File**: [src/lib/projections/assumptions.ts](src/lib/projections/assumptions.ts)

Add at the end of the file:
```typescript
/**
 * Epic 10.2: Reserve purpose labels for UI
 */
export const RESERVE_PURPOSE_LABELS: Record<ReservePurpose, string> = {
  longevity: 'Longevity Protection',
  emergency: 'Emergency Fund',
  legacy: 'Legacy/Inheritance',
  healthcare: 'Healthcare Reserve',
  peace_of_mind: 'Peace of Mind',
};
```

Add import at top:
```typescript
import type { ReservePurpose } from './types';
```

#### 2. Extended Depletion Target Input Component
**File**: [src/components/depletion-target-input.tsx](src/components/depletion-target-input.tsx)

This is a significant extension. Add new imports:
```typescript
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import type { ReserveConfig, ReserveType, ReservePurpose } from '@/lib/projections/types';
import { RESERVE_PURPOSE_LABELS } from '@/lib/projections/assumptions';
import { validateReserveConfig } from '@/lib/validation/projections';
import { cn } from '@/lib/utils';
```

Add state for reserve (after existing state declarations around line 44):
```typescript
// Reserve state
const [reserveType, setReserveType] = useState<ReserveType>(
  target?.reserve?.type ?? 'derived'
);
const [reserveAmount, setReserveAmount] = useState(
  target?.reserve?.amount?.toString() ?? ''
);
const [reservePurposes, setReservePurposes] = useState<Set<ReservePurpose>>(
  new Set(target?.reserve?.purposes ?? [])
);
const [reserveWarnings, setReserveWarnings] = useState<string[]>([]);
```

Add reserve validation effect (after existing validation effect):
```typescript
// Validate reserve config
useEffect(() => {
  if (localTarget.enabled && localTarget.reserve) {
    const result = validateReserveConfig(
      localTarget.reserve,
      localTarget,
      portfolioValue
    );
    setReserveWarnings(result.warnings);
  } else {
    setReserveWarnings([]);
  }
}, [localTarget, portfolioValue]);
```

Add handlers for reserve changes:
```typescript
const handleReserveTypeChange = useCallback((type: ReserveType) => {
  setReserveType(type);

  const reserve: ReserveConfig = {
    type,
    amount: type === 'derived' ? undefined : (parseFloat(reserveAmount) || 0),
    purposes: Array.from(reservePurposes),
  };

  const newTarget = { ...localTarget, reserve };
  setLocalTarget(newTarget);
  onChange(newTarget);
}, [localTarget, reserveAmount, reservePurposes, onChange]);

const handleReserveAmountChange = useCallback((value: string) => {
  setReserveAmount(value);
}, []);

const handleReserveAmountBlur = useCallback(() => {
  const parsed = parseFloat(reserveAmount);
  if (isNaN(parsed)) {
    setReserveAmount('');
    return;
  }

  const reserve: ReserveConfig = {
    type: reserveType,
    amount: reserveType === 'derived' ? undefined : parsed,
    purposes: Array.from(reservePurposes),
  };

  const newTarget = { ...localTarget, reserve };
  setLocalTarget(newTarget);
  onChange(newTarget);
}, [reserveAmount, reserveType, reservePurposes, localTarget, onChange]);

const togglePurpose = useCallback((purpose: ReservePurpose) => {
  const newPurposes = new Set(reservePurposes);
  if (newPurposes.has(purpose)) {
    newPurposes.delete(purpose);
  } else {
    newPurposes.add(purpose);
  }
  setReservePurposes(newPurposes);

  const reserve: ReserveConfig = {
    type: reserveType,
    amount: reserveType === 'derived' ? undefined : (parseFloat(reserveAmount) || 0),
    purposes: Array.from(newPurposes),
  };

  const newTarget = { ...localTarget, reserve };
  setLocalTarget(newTarget);
  onChange(newTarget);
}, [reservePurposes, reserveType, reserveAmount, localTarget, onChange]);
```

Add calculated reserve amount:
```typescript
// Calculate actual reserve amount for display
const calculatedReserveAmount = useMemo(() => {
  if (reserveType === 'derived') {
    return portfolioValue * (1 - localTarget.targetPercentageSpent / 100);
  }
  if (reserveType === 'percentage') {
    return portfolioValue * ((parseFloat(reserveAmount) || 0) / 100);
  }
  return parseFloat(reserveAmount) || 0;
}, [reserveType, portfolioValue, localTarget.targetPercentageSpent, reserveAmount]);
```

Add the Reserve Protection section to the JSX (add after the Age Input section, before Validation Errors):
```tsx
{/* Reserve Protection Section */}
<div className="space-y-4 pt-4 border-t">
  <h4 className="font-medium text-sm">Reserve Protection</h4>

  {/* Reserve Type Selection */}
  <RadioGroup
    value={reserveType}
    onValueChange={(v) => handleReserveTypeChange(v as ReserveType)}
    className="space-y-2"
  >
    <div className="flex items-center space-x-2">
      <RadioGroupItem value="derived" id="reserve-derived" />
      <Label htmlFor="reserve-derived" className="font-normal cursor-pointer">
        Match spending target ({100 - localTarget.targetPercentageSpent}%)
      </Label>
    </div>
    <div className="flex items-center space-x-2">
      <RadioGroupItem value="percentage" id="reserve-percentage" />
      <Label htmlFor="reserve-percentage" className="font-normal cursor-pointer">
        Custom percentage
      </Label>
    </div>
    <div className="flex items-center space-x-2">
      <RadioGroupItem value="absolute" id="reserve-absolute" />
      <Label htmlFor="reserve-absolute" className="font-normal cursor-pointer">
        Specific dollar amount
      </Label>
    </div>
  </RadioGroup>

  {/* Conditional Inputs */}
  {reserveType === 'derived' && (
    <div className="p-3 bg-muted rounded-lg text-sm">
      Reserve: {new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        maximumFractionDigits: 0,
      }).format(calculatedReserveAmount)} ({100 - localTarget.targetPercentageSpent}% of portfolio)
    </div>
  )}

  {reserveType === 'percentage' && (
    <div className="space-y-2">
      <div className="flex items-center gap-2">
        <Input
          type="number"
          value={reserveAmount}
          onChange={(e) => handleReserveAmountChange(e.target.value)}
          onBlur={handleReserveAmountBlur}
          placeholder="25"
          className="w-24"
          min={0}
          max={100}
        />
        <span className="text-sm text-muted-foreground">%</span>
      </div>
      <p className="text-xs text-muted-foreground">
        = {new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
          maximumFractionDigits: 0,
        }).format(calculatedReserveAmount)}
      </p>
    </div>
  )}

  {reserveType === 'absolute' && (
    <div className="space-y-2">
      <div className="flex items-center gap-2">
        <span className="text-sm text-muted-foreground">$</span>
        <Input
          type="number"
          value={reserveAmount}
          onChange={(e) => handleReserveAmountChange(e.target.value)}
          onBlur={handleReserveAmountBlur}
          placeholder="250,000"
          className="w-32"
          min={0}
        />
      </div>
    </div>
  )}

  {/* Purpose Tags */}
  <div className="space-y-2">
    <Label className="text-xs text-muted-foreground">
      Reserve purpose (optional)
    </Label>
    <div className="flex flex-wrap gap-2">
      {(Object.entries(RESERVE_PURPOSE_LABELS) as [ReservePurpose, string][]).map(
        ([purpose, label]) => (
          <button
            key={purpose}
            type="button"
            onClick={() => togglePurpose(purpose)}
            className={cn(
              'px-3 py-1 rounded-full text-xs border transition-colors',
              reservePurposes.has(purpose)
                ? 'bg-primary text-primary-foreground border-primary'
                : 'bg-muted hover:bg-muted/80 border-border'
            )}
          >
            {label}
          </button>
        )
      )}
    </div>
  </div>

  {/* Reserve Warnings */}
  {reserveWarnings.length > 0 && (
    <div className="flex gap-2 p-3 bg-amber-50 dark:bg-amber-950 rounded-lg">
      <Info className="h-4 w-4 mt-0.5 text-amber-600 dark:text-amber-400 flex-shrink-0" />
      <div className="text-sm text-amber-800 dark:text-amber-200">
        {reserveWarnings.map((warning, i) => (
          <p key={i}>{warning}</p>
        ))}
      </div>
    </div>
  )}
</div>
```

Update the Summary section to include reserve:
```tsx
{/* Summary */}
<div className="p-3 bg-muted/50 rounded-lg text-sm space-y-2">
  <p>
    <strong>Spending goal:</strong> Spend {localTarget.targetPercentageSpent}% by age {localTarget.targetAge}
  </p>
  <p>
    <strong>Reserve protection:</strong> Keep {new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      maximumFractionDigits: 0,
    }).format(calculatedReserveAmount)} as a safety buffer
  </p>
</div>
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `npm run typecheck`
- [x] Component renders without errors
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Toggle between derived/percentage/absolute reserve types
- [ ] Enter custom percentage and see dollar conversion
- [ ] Enter absolute amount and see it reflected
- [ ] Select/deselect purpose tags
- [ ] Verify warnings appear for inconsistent settings
- [ ] Verify changes persist after page refresh

**Implementation Note**: After completing this phase and all automated verification passes, pause for manual UI testing confirmation.

---

## Phase 4: Chart Visualization

### Overview
Add dual-area chart visualization showing "Available" (green) and "Reserve" (amber) zones.

### Changes Required:

#### 1. Update Projection Chart
**File**: [src/components/projections/ProjectionChart.tsx](src/components/projections/ProjectionChart.tsx)

Add to props interface:
```typescript
reserveFloor?: number;
```

Add chart data transformation to include reserve:
```typescript
const chartDataWithReserve = useMemo(() => {
  if (!reserveFloor) return null;

  return records.map((record) => ({
    ...record,
    xValue: xAxisType === 'age' ? record.age : record.year,
    balanceAboveReserve: Math.max(0, record.balance - reserveFloor),
    reservePortion: Math.min(record.balance, reserveFloor),
  }));
}, [records, reserveFloor, xAxisType]);
```

Add conditional rendering for reserve visualization (when `reserveFloor` is defined):
```tsx
{reserveFloor && chartDataWithReserve && (
  <>
    {/* Reserve zone (bottom) - protected funds */}
    <Area
      type="monotone"
      dataKey="reservePortion"
      stackId="reserve"
      fill="hsl(var(--warning) / 0.2)"
      stroke="hsl(var(--warning))"
      strokeWidth={1}
      name="Reserve"
    />

    {/* Available zone (top) - spendable funds */}
    <Area
      type="monotone"
      dataKey="balanceAboveReserve"
      stackId="reserve"
      fill="hsl(var(--success) / 0.2)"
      stroke="hsl(var(--success))"
      strokeWidth={2}
      name="Available"
    />

    {/* Reference line at reserve floor */}
    <ReferenceLine
      y={reserveFloor}
      stroke="hsl(var(--warning))"
      strokeDasharray="5 5"
      label={{
        value: `Reserve: $${(reserveFloor / 1000).toFixed(0)}k`,
        position: 'right',
        fill: 'hsl(var(--muted-foreground))',
        fontSize: 10,
      }}
    />
  </>
)}
```

Update the tooltip to show reserve information when applicable:
```tsx
{reserveFloor && (
  <>
    <p className="text-sm text-green-600 dark:text-green-400">
      Available: {formatTooltipCurrency(Math.max(0, data.balance - reserveFloor))}
    </p>
    <p className="text-sm text-amber-600 dark:text-amber-400">
      Reserve: {formatTooltipCurrency(Math.min(data.balance, reserveFloor))}
    </p>
    {data.reserveConstrained && (
      <p className="text-xs text-amber-600 dark:text-amber-400 mt-1">
        Spending reduced to protect reserve
      </p>
    )}
  </>
)}
```

Update legend to include reserve zones when applicable:
```tsx
{reserveFloor && (
  <>
    <div className="flex items-center gap-2">
      <div
        className="h-3 w-3 rounded-sm"
        style={{ backgroundColor: 'hsl(var(--success))' }}
      />
      <span>Available for Spending</span>
    </div>
    <div className="flex items-center gap-2">
      <div
        className="h-3 w-3 rounded-sm"
        style={{ backgroundColor: 'hsl(var(--warning))' }}
      />
      <span>Reserve</span>
    </div>
  </>
)}
```

#### 2. Pass Reserve Floor to Chart
Update the page/component that renders `ProjectionChart` to pass the `reserveFloor` from projection summary.

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `npm run typecheck`
- [x] Chart renders without errors
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Chart shows dual-area when reserve is configured
- [ ] Green area shows funds above reserve
- [ ] Amber area shows reserve floor
- [ ] Dashed reference line appears at reserve level
- [ ] Tooltip shows both amounts
- [ ] Legend includes reserve entries

**Implementation Note**: After completing this phase, pause for visual testing confirmation.

---

## Phase 5: Reserve Runway Calculation

### Overview
Calculate and display how many years the reserve would cover essential expenses.

### Changes Required:

#### 1. Create Reserve Runway Module
**File**: [src/lib/projections/reserve-runway.ts](src/lib/projections/reserve-runway.ts) (new file)

```typescript
/**
 * Epic 10.2: Reserve Runway Calculation
 * Calculates how many years the reserve would cover essential expenses
 */

export interface ReserveRunwayResult {
  /** Years reserve covers essential expenses (inflation-adjusted) */
  yearsOfEssentials: number;
  /** Years reserve covers full spending (inflation-adjusted) */
  yearsOfFullSpending: number;
  /** Human-readable description */
  description: string;
}

/**
 * Calculate reserve runway with inflation adjustment
 */
export function calculateReserveRunway(
  reserveAmount: number,
  annualEssentialExpenses: number,
  annualDiscretionaryExpenses: number,
  guaranteedAnnualIncome: number,
  inflationRate: number = 0.025
): ReserveRunwayResult {
  // Essential gap = expenses not covered by guaranteed income
  const essentialGap = Math.max(0, annualEssentialExpenses - guaranteedAnnualIncome);
  const fullSpendingGap = essentialGap + annualDiscretionaryExpenses;

  // Calculate inflation-adjusted runway for essentials
  const yearsOfEssentials = essentialGap > 0
    ? calculateInflationAdjustedYears(reserveAmount, essentialGap, inflationRate)
    : Infinity;

  // Calculate inflation-adjusted runway for full spending
  const yearsOfFullSpending = fullSpendingGap > 0
    ? calculateInflationAdjustedYears(reserveAmount, fullSpendingGap, inflationRate)
    : Infinity;

  return {
    yearsOfEssentials: Math.floor(yearsOfEssentials),
    yearsOfFullSpending: Math.floor(yearsOfFullSpending),
    description: generateDescription(yearsOfEssentials, essentialGap),
  };
}

/**
 * Calculate years until reserve depleted accounting for inflation
 */
function calculateInflationAdjustedYears(
  reserve: number,
  annualNeed: number,
  inflationRate: number
): number {
  if (annualNeed <= 0) return Infinity;

  let remaining = reserve;
  let years = 0;
  let currentNeed = annualNeed;

  while (remaining > 0 && years < 100) {
    remaining -= currentNeed;
    currentNeed *= (1 + inflationRate);
    years++;
  }

  return years;
}

/**
 * Generate human-readable runway description
 */
function generateDescription(years: number, essentialGap: number): string {
  if (essentialGap <= 0) {
    return 'Guaranteed income covers all essential expenses';
  }
  if (years >= 30) {
    return 'Reserve provides 30+ years of essential expense coverage';
  }
  if (years >= 10) {
    return `Reserve covers ~${Math.floor(years)} years of essential expenses`;
  }
  if (years >= 1) {
    return `Reserve covers ${Math.floor(years)} year${years >= 2 ? 's' : ''} of essential expenses`;
  }
  return `Reserve covers ${Math.floor(years * 12)} months of essential expenses`;
}

/**
 * Calculate guaranteed income from income streams
 */
export function calculateGuaranteedIncome(
  incomeStreams: { annualAmount: number; isGuaranteed: boolean }[],
  age: number
): number {
  return incomeStreams
    .filter(stream => stream.isGuaranteed)
    .reduce((sum, stream) => sum + stream.annualAmount, 0);
}
```

#### 2. Add Runway Display to UI
**File**: [src/components/depletion-target-input.tsx](src/components/depletion-target-input.tsx)

Add import:
```typescript
import { calculateReserveRunway, calculateGuaranteedIncome } from '@/lib/projections/reserve-runway';
```

Add props for runway calculation:
```typescript
interface DepletionTargetInputProps {
  // ... existing props
  annualEssentialExpenses?: number;
  annualDiscretionaryExpenses?: number;
  incomeStreams?: { annualAmount: number; isGuaranteed: boolean }[];
  currentAge: number;
  inflationRate?: number;
}
```

Add runway calculation:
```typescript
const runwayResult = useMemo(() => {
  if (!localTarget.enabled || calculatedReserveAmount <= 0) {
    return null;
  }

  const guaranteedIncome = calculateGuaranteedIncome(
    incomeStreams ?? [],
    currentAge
  );

  return calculateReserveRunway(
    calculatedReserveAmount,
    annualEssentialExpenses ?? 0,
    annualDiscretionaryExpenses ?? 0,
    guaranteedIncome,
    inflationRate ?? 0.025
  );
}, [
  localTarget.enabled,
  calculatedReserveAmount,
  annualEssentialExpenses,
  annualDiscretionaryExpenses,
  incomeStreams,
  currentAge,
  inflationRate,
]);
```

Add runway display in the reserve section:
```tsx
{/* Reserve Runway */}
{runwayResult && (
  <div className="p-3 bg-amber-50/50 dark:bg-amber-950/30 rounded-lg text-sm space-y-1">
    <div className="flex justify-between">
      <span className="text-muted-foreground">Reserve Runway</span>
      <span className="font-medium text-amber-700 dark:text-amber-300">
        {runwayResult.yearsOfEssentials === Infinity
          ? '∞ years'
          : `${runwayResult.yearsOfEssentials} years`}
      </span>
    </div>
    <p className="text-xs text-muted-foreground">
      {runwayResult.description}
    </p>
  </div>
)}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compiles: `npm run typecheck`
- [x] Unit tests for runway calculation pass
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Runway displays when reserve is configured
- [ ] Runway updates when reserve amount changes
- [ ] Infinity shown when income covers all essentials
- [ ] Description accurately reflects years

**Implementation Note**: After completing this phase, pause for final testing confirmation.

---

## Phase 6: Testing & Integration

### Overview
Add comprehensive tests and ensure all components work together correctly.

### Changes Required:

#### 1. Unit Tests for Reserve Runway
**File**: [src/lib/projections/__tests__/reserve-runway.test.ts](src/lib/projections/__tests__/reserve-runway.test.ts) (new file)

```typescript
import { calculateReserveRunway, calculateGuaranteedIncome } from '../reserve-runway';

describe('calculateReserveRunway', () => {
  it('returns infinity when income covers all essentials', () => {
    const result = calculateReserveRunway(
      100000, // reserve
      50000,  // essential expenses
      20000,  // discretionary
      60000,  // guaranteed income (covers essentials)
      0.025
    );

    expect(result.yearsOfEssentials).toBe(Infinity);
    expect(result.description).toContain('income covers');
  });

  it('calculates finite runway when income does not cover essentials', () => {
    const result = calculateReserveRunway(
      200000, // reserve
      60000,  // essential expenses
      20000,  // discretionary
      30000,  // guaranteed income (leaves $30k gap)
      0.025
    );

    // $200k / $30k gap = ~6-7 years with inflation
    expect(result.yearsOfEssentials).toBeGreaterThan(5);
    expect(result.yearsOfEssentials).toBeLessThan(10);
  });

  it('handles zero reserve', () => {
    const result = calculateReserveRunway(0, 50000, 20000, 30000, 0.025);
    expect(result.yearsOfEssentials).toBe(0);
  });
});

describe('calculateGuaranteedIncome', () => {
  it('sums only guaranteed income streams', () => {
    const streams = [
      { annualAmount: 30000, isGuaranteed: true },  // SS
      { annualAmount: 20000, isGuaranteed: true },  // Pension
      { annualAmount: 10000, isGuaranteed: false }, // Rental
    ];

    const result = calculateGuaranteedIncome(streams, 70);
    expect(result).toBe(50000); // Only guaranteed streams
  });
});
```

#### 2. Unit Tests for Engine Reserve Logic
**File**: [src/lib/projections/__tests__/engine-reserve.test.ts](src/lib/projections/__tests__/engine-reserve.test.ts) (new file)

```typescript
import { runProjection } from '../engine';
import type { ProjectionInput } from '../types';

describe('runProjection with reserve floor', () => {
  const baseInput: ProjectionInput = {
    currentAge: 65,
    retirementAge: 65,
    maxAge: 90,
    balancesByType: { taxDeferred: 500000, taxFree: 300000, taxable: 200000 },
    annualContribution: 0,
    contributionAllocation: { taxDeferred: 60, taxFree: 30, taxable: 10 },
    expectedReturn: 0.05,
    inflationRate: 0.025,
    contributionGrowthRate: 0,
    annualEssentialExpenses: 40000,
    annualDiscretionaryExpenses: 20000,
    annualExpenses: 60000,
    annualHealthcareCosts: 5000,
    healthcareInflationRate: 0.05,
    incomeStreams: [],
    annualDebtPayments: 0,
  };

  it('respects reserve floor by limiting withdrawals', () => {
    const input: ProjectionInput = {
      ...baseInput,
      reserveFloor: 250000, // 25% of $1M
    };

    const result = runProjection(input);

    // Balance should never go below reserve floor
    for (const record of result.records) {
      if (record.age >= 65) { // Retirement years
        expect(record.balance).toBeGreaterThanOrEqual(249000); // Allow small rounding
      }
    }
  });

  it('tracks years reserve constrained in summary', () => {
    const input: ProjectionInput = {
      ...baseInput,
      reserveFloor: 800000, // Very high reserve to trigger constraint
    };

    const result = runProjection(input);

    expect(result.summary.yearsReserveConstrained).toBeGreaterThan(0);
    expect(result.summary.firstReserveConstraintAge).toBe(65);
  });

  it('reduces discretionary before essentials', () => {
    const input: ProjectionInput = {
      ...baseInput,
      reserveFloor: 900000, // Very tight reserve
    };

    const result = runProjection(input);
    const constrainedRecord = result.records.find(r => r.reserveConstrained);

    if (constrainedRecord) {
      // Should reduce discretionary first
      expect(constrainedRecord.reductionStage).toBe('discretionary_reduced');
    }
  });
});
```

#### 3. Update Existing Tests
Ensure existing projection tests still pass by checking they don't require reserve fields.

### Success Criteria:

#### Automated Verification:
- [x] All new tests pass: `npm test`
- [x] All existing tests pass: `npm test` (pre-existing failures unrelated to changes)
- [x] TypeScript compiles: `npm run typecheck`
- [x] Linting passes: `npm run lint`
- [x] Build succeeds: `npm run build`

#### Manual Verification:
- [ ] End-to-end flow: Set reserve → Run projection → See chart → Verify summary
- [ ] Edge cases: 0% reserve, 100% reserve, reserve > portfolio
- [ ] Persistence: Refresh page, settings retained
- [ ] Responsive: UI looks good on mobile

---

## Testing Strategy

### Unit Tests
- Reserve runway calculation with various scenarios
- Engine reserve constraint logic
- Validation schema for reserve config
- Input builder reserve floor calculation

### Integration Tests
- Full projection flow with reserve enabled
- UI component state management
- API roundtrip with reserve config

### Manual Testing Steps
1. Navigate to Profile → Spending Target
2. Enable spending target with 75% by age 85
3. Observe "Reserve: 25%" auto-calculated
4. Switch to "Custom percentage" and enter 30%
5. Observe warning about inconsistency
6. Select purpose tags (longevity, peace of mind)
7. Save and run projection
8. Verify chart shows dual-area visualization
9. Check summary for reserve-constrained years
10. Test with extreme values (0%, 100%, very high absolute)

---

## Performance Considerations

- Reserve floor calculation is O(1) - no performance impact
- Engine loop adds minimal overhead (few extra comparisons per year)
- Chart rendering may be slightly heavier with stacked areas - monitor on large datasets

---

## Migration Notes

- No database migration needed - JSONB column accepts new fields automatically
- Existing users: `reserve` field will be `undefined`, engine treats as "no reserve"
- Default behavior unchanged: projections without reserve work exactly as before

---

## References

- Research document: [2026-01-23-ENG-10.2-reserve-preservation-implementation.md](thoughts/shared/research/2026-01-23-ENG-10.2-reserve-preservation-implementation.md)
- Story 10.1 patterns: [depletion-target-input.tsx](src/components/depletion-target-input.tsx)
- Engine source: [engine.ts](src/lib/projections/engine.ts)
- Types: [types.ts](src/lib/projections/types.ts)
