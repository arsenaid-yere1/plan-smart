# Story 10.3: Depletion Feedback Implementation Plan

## Overview

Implement visual feedback showing how a user's depletion target translates into monthly spending guidance and portfolio trajectory comparison. This story builds on the foundation from Stories 10.1 (Depletion Target Input) and 10.2 (Reserve Preservation) to provide actionable spending recommendations.

## Current State Analysis

### What Exists Now
- **Depletion Target Input** ([depletion-target-input.tsx](src/components/depletion-target-input.tsx)): Full UI for configuring depletion target with reserve protection
- **Reserve Floor Calculation** ([input-builder.ts:25-45](src/lib/projections/input-builder.ts#L25-L45)): Converts reserve config to absolute dollar amount
- **Reserve-Constrained Engine** ([engine.ts:188-263](src/lib/projections/engine.ts#L188-L263)): Multi-stage spending reduction logic
- **Dual-Area Chart** ([ProjectionChart.tsx:573-596](src/components/projections/ProjectionChart.tsx#L573-L596)): Reserve visualization with available/protected zones
- **Plans Page** ([plans-client.tsx](src/app/plans/plans-client.tsx)): Debounced projection recalculation, tab navigation

### What's Missing
1. **Sustainable spending calculation** - Given a depletion target, calculate what spending level achieves it
2. **Trajectory comparison** - Show user's current plan vs sustainable trajectory
3. **Feedback summary UI** - Display spending guidance with status indicators
4. **Target trajectory visualization** - Dashed line showing ideal path on chart

## Desired End State

After implementation:
1. Users see a "Spending Guidance" card showing their sustainable monthly/annual spending
2. Card displays status: "On Track", "Underspending", or "Overspending"
3. Phase breakdown shows spending by life phase when phases are enabled
4. Chart shows depletion target marker and optional target trajectory line
5. API returns depletion feedback alongside projection results
6. Real-time updates as user adjusts depletion target settings

### Key Verification Points
- [ ] Depletion feedback appears when depletion target is enabled
- [ ] Sustainable spending calculation is mathematically correct
- [ ] Status correctly reflects on_track/underspending/overspending
- [ ] Chart shows target age marker and trajectory line
- [ ] Feedback updates within 300ms of input changes (debounced)
- [ ] Phase breakdown displays when spending phases enabled

## What We're NOT Doing

- **Income Integration**: Not accounting for guaranteed income in sustainable withdrawal (Epic 8 scope)
- **Monte Carlo Simulations**: Using deterministic calculation, not probabilistic
- **Historical Backtesting**: No sequence-of-returns risk modeling
- **Dynamic Rebalancing**: Assuming fixed expected return throughout
- **Tax Optimization**: Not calculating tax-efficient withdrawal sequencing

## Implementation Approach

The implementation follows Option A (Integrated Approach) from the research document:
1. Add `calculateDepletionFeedback()` as a calculation layer
2. Call it from the projection API route after `runProjection()`
3. Return feedback alongside projection results
4. Add UI components to display feedback

---

## Phase 1: Core Calculation Module

### Overview
Create the depletion feedback calculation logic that determines sustainable spending and trajectory status.

### Changes Required:

#### 1. Add DepletionFeedback Types
**File**: [src/lib/projections/types.ts](src/lib/projections/types.ts)
**Changes**: Add new interfaces for depletion feedback

```typescript
// Add after line 133 (after ReserveConfig interface)

/**
 * Epic 10.3: Phase-based spending breakdown
 */
export interface PhaseSpendingBreakdown {
  phaseName: string;
  startAge: number;
  endAge: number;
  monthlySpending: number;
  annualSpending: number;
  yearsInPhase: number;
}

/**
 * Epic 10.3: Trajectory status assessment
 */
export type TrajectoryStatus = 'on_track' | 'underspending' | 'overspending';

/**
 * Epic 10.3: Depletion feedback showing sustainable spending
 */
export interface DepletionFeedback {
  /** Sustainable monthly spending to hit depletion target */
  sustainableMonthlySpending: number;
  /** Sustainable annual spending to hit depletion target */
  sustainableAnnualSpending: number;
  /** Phase-based breakdown when phases enabled */
  phaseBreakdown?: PhaseSpendingBreakdown[];
  /** Status comparing current plan to sustainable rate */
  trajectoryStatus: TrajectoryStatus;
  /** Human-readable status message */
  statusMessage: string;
  /** Warning messages for edge cases */
  warningMessages: string[];
  /** Projected balance at target age with current spending */
  projectedReserveAtTarget: number;
  /** Age when portfolio would deplete with current spending, or null */
  projectedDepletionAge: number | null;
}
```

#### 2. Create Depletion Feedback Calculation Module
**File**: `src/lib/projections/depletion-feedback.ts` (NEW)
**Changes**: Create the core calculation logic

```typescript
import type {
  ProjectionInput,
  ProjectionRecord,
  DepletionFeedback,
  PhaseSpendingBreakdown,
  TrajectoryStatus,
  SpendingPhase,
  SpendingPhaseConfig,
} from './types';

/**
 * Calculate sustainable spending rate and trajectory status for depletion target
 */
export function calculateDepletionFeedback(
  input: ProjectionInput,
  records: ProjectionRecord[]
): DepletionFeedback | null {
  const { depletionTarget, reserveFloor, spendingPhaseConfig, currentAge, retirementAge } = input;

  // Return null if depletion target not enabled
  if (!depletionTarget?.enabled) {
    return null;
  }

  const targetAge = depletionTarget.targetAge;
  const targetReserve = reserveFloor ?? 0;
  const currentPortfolio = calculateTotalPortfolio(input.balancesByType);
  const yearsToTarget = targetAge - currentAge;
  const retirementYears = Math.max(0, targetAge - retirementAge);

  // Only calculate for retirement period
  if (retirementYears <= 0) {
    return createDisabledFeedback('Target age must be after retirement');
  }

  // Calculate real return (adjusted for inflation)
  const realReturn = calculateRealReturn(input.expectedReturn, input.inflationRate);

  // Calculate sustainable annual withdrawal
  const sustainableAnnual = calculateSustainableWithdrawal(
    currentPortfolio,
    targetReserve,
    retirementYears,
    realReturn
  );

  // Get current planned spending (phase-adjusted average)
  const currentPlannedSpending = calculateCurrentPlannedSpending(input, records);

  // Assess trajectory status
  const trajectoryStatus = assessTrajectoryStatus(
    sustainableAnnual,
    currentPlannedSpending,
    0.05 // 5% tolerance band
  );

  // Calculate phase breakdown if phases enabled
  const phaseBreakdown = spendingPhaseConfig?.enabled
    ? calculatePhaseBreakdown(sustainableAnnual, spendingPhaseConfig, input)
    : undefined;

  // Find projected values at target age
  const targetAgeRecord = records.find(r => r.age === targetAge);
  const projectedReserveAtTarget = targetAgeRecord?.balance ?? 0;
  const projectedDepletionAge = findDepletionAge(records);

  // Generate warnings
  const warningMessages = generateWarnings(
    trajectoryStatus,
    currentPlannedSpending,
    sustainableAnnual,
    projectedReserveAtTarget,
    targetReserve,
    records,
    targetAge
  );

  // Generate status message
  const statusMessage = generateStatusMessage(
    trajectoryStatus,
    sustainableAnnual,
    depletionTarget.targetAge,
    depletionTarget.targetPercentageSpent
  );

  return {
    sustainableMonthlySpending: sustainableAnnual / 12,
    sustainableAnnualSpending: sustainableAnnual,
    phaseBreakdown,
    trajectoryStatus,
    statusMessage,
    warningMessages,
    projectedReserveAtTarget,
    projectedDepletionAge,
  };
}

/**
 * Calculate total portfolio value from balances by type
 */
function calculateTotalPortfolio(balancesByType: { taxDeferred: number; taxFree: number; taxable: number }): number {
  return balancesByType.taxDeferred + balancesByType.taxFree + balancesByType.taxable;
}

/**
 * Calculate real return (nominal return adjusted for inflation)
 */
function calculateRealReturn(nominalReturn: number, inflationRate: number): number {
  return (1 + nominalReturn) / (1 + inflationRate) - 1;
}

/**
 * Calculate sustainable withdrawal using present value of annuity formula
 * This determines annual spending that depletes to targetReserve over years
 */
function calculateSustainableWithdrawal(
  currentPortfolio: number,
  targetReserve: number,
  years: number,
  realReturn: number
): number {
  // Amount available for spending over the period
  const spendablePortfolio = currentPortfolio - targetReserve;

  if (spendablePortfolio <= 0 || years <= 0) {
    return 0;
  }

  // Simple case: no real growth
  if (Math.abs(realReturn) < 0.0001) {
    return spendablePortfolio / years;
  }

  // Use annuity formula: PMT = PV * [r(1+r)^n] / [(1+r)^n - 1]
  const r = realReturn;
  const n = years;
  const factor = Math.pow(1 + r, n);
  const numerator = r * factor;
  const denominator = factor - 1;

  return spendablePortfolio * (numerator / denominator);
}

/**
 * Calculate current planned spending as phase-adjusted average over retirement
 */
function calculateCurrentPlannedSpending(
  input: ProjectionInput,
  records: ProjectionRecord[]
): number {
  const { retirementAge, depletionTarget, annualEssentialExpenses, annualDiscretionaryExpenses } = input;
  const targetAge = depletionTarget?.targetAge ?? input.maxAge;

  // Filter to retirement years up to target
  const retirementRecords = records.filter(
    r => r.age >= retirementAge && r.age <= targetAge
  );

  if (retirementRecords.length === 0) {
    return annualEssentialExpenses + annualDiscretionaryExpenses;
  }

  // Calculate average actual spending (uses phase-adjusted values from engine)
  const totalSpending = retirementRecords.reduce((sum, r) => {
    const essential = r.actualEssentialSpending ?? r.essentialExpenses ?? 0;
    const discretionary = r.actualDiscretionarySpending ?? r.discretionaryExpenses ?? 0;
    return sum + essential + discretionary;
  }, 0);

  return totalSpending / retirementRecords.length;
}

/**
 * Assess trajectory status comparing current vs sustainable spending
 */
function assessTrajectoryStatus(
  sustainableAnnual: number,
  currentPlannedAnnual: number,
  toleranceBand: number
): TrajectoryStatus {
  if (sustainableAnnual <= 0) {
    return 'overspending';
  }

  const ratio = currentPlannedAnnual / sustainableAnnual;

  if (ratio <= 1 - toleranceBand) {
    return 'underspending';
  } else if (ratio >= 1 + toleranceBand) {
    return 'overspending';
  }
  return 'on_track';
}

/**
 * Calculate phase-based spending breakdown
 */
function calculatePhaseBreakdown(
  sustainableAnnual: number,
  config: SpendingPhaseConfig,
  input: ProjectionInput
): PhaseSpendingBreakdown[] {
  const { phases } = config;
  const { retirementAge, depletionTarget } = input;
  const targetAge = depletionTarget?.targetAge ?? input.maxAge;

  // Build phase periods with years in each
  const phaseYears: Array<{ phase: SpendingPhase; startAge: number; endAge: number; years: number }> = [];

  for (let i = 0; i < phases.length; i++) {
    const phase = phases[i];
    const startAge = Math.max(phase.startAge, retirementAge);
    const endAge = i < phases.length - 1
      ? Math.min(phases[i + 1].startAge, targetAge)
      : targetAge;

    if (startAge < targetAge && startAge < endAge) {
      phaseYears.push({
        phase,
        startAge,
        endAge,
        years: endAge - startAge,
      });
    }
  }

  if (phaseYears.length === 0) {
    return [];
  }

  // Calculate weighted average multiplier
  const totalYears = phaseYears.reduce((sum, p) => sum + p.years, 0);
  const weightedMultiplier = phaseYears.reduce((sum, p) => {
    const avgMultiplier = (p.phase.essentialMultiplier + p.phase.discretionaryMultiplier) / 2;
    return sum + (avgMultiplier * p.years / totalYears);
  }, 0);

  // Base spending that, when weighted, equals sustainable total
  const baseSpending = weightedMultiplier > 0 ? sustainableAnnual / weightedMultiplier : sustainableAnnual;

  // Generate breakdown
  return phaseYears.map(({ phase, startAge, endAge, years }) => {
    const avgMultiplier = (phase.essentialMultiplier + phase.discretionaryMultiplier) / 2;
    const annualSpending = baseSpending * avgMultiplier;

    return {
      phaseName: phase.name,
      startAge,
      endAge,
      monthlySpending: annualSpending / 12,
      annualSpending,
      yearsInPhase: years,
    };
  });
}

/**
 * Find age when portfolio depletes (balance <= 0)
 */
function findDepletionAge(records: ProjectionRecord[]): number | null {
  const depletionRecord = records.find(r => r.balance <= 0);
  return depletionRecord?.age ?? null;
}

/**
 * Generate warning messages for edge cases
 */
function generateWarnings(
  status: TrajectoryStatus,
  currentSpending: number,
  sustainableSpending: number,
  projectedReserve: number,
  targetReserve: number,
  records: ProjectionRecord[],
  targetAge: number
): string[] {
  const warnings: string[] = [];
  const formatCurrency = (v: number) => `$${Math.round(v).toLocaleString()}`;

  // Overspending warning
  if (status === 'overspending' && sustainableSpending > 0) {
    const overagePercent = Math.round(((currentSpending - sustainableSpending) / sustainableSpending) * 100);
    warnings.push(
      `Current spending exceeds sustainable rate by ${overagePercent}%. Consider reducing to ${formatCurrency(sustainableSpending / 12)}/month.`
    );
  }

  // Underspending message (framed positively)
  if (status === 'underspending' && currentSpending > 0) {
    const extraMonthly = Math.round((sustainableSpending - currentSpending) / 12);
    warnings.push(
      `You could enjoy ${formatCurrency(extraMonthly)}/month more without risking your goals!`
    );
  }

  // Reserve breach warning
  if (projectedReserve < targetReserve) {
    const shortfall = targetReserve - projectedReserve;
    warnings.push(
      `Current trajectory shows reserve shortfall of ${formatCurrency(shortfall)} at age ${targetAge}.`
    );
  }

  // Early depletion warning
  const depletionRecord = records.find(r => r.balance <= 0);
  if (depletionRecord && depletionRecord.age < targetAge) {
    warnings.push(
      `Warning: Portfolio depletes at age ${depletionRecord.age}, before reaching your target age ${targetAge}.`
    );
  }

  return warnings;
}

/**
 * Generate human-readable status message
 */
function generateStatusMessage(
  status: TrajectoryStatus,
  sustainableAnnual: number,
  targetAge: number,
  targetPercentageSpent: number
): string {
  switch (status) {
    case 'on_track':
      return `You're on track to spend ${targetPercentageSpent}% of your portfolio by age ${targetAge}.`;
    case 'underspending':
      return `You're spending below your sustainable rate. You could enjoy more now while still meeting your goals.`;
    case 'overspending':
      return `Your current spending exceeds what's sustainable for your depletion target. Consider adjustments to stay on track.`;
  }
}

/**
 * Create feedback for disabled/invalid states
 */
function createDisabledFeedback(message: string): DepletionFeedback {
  return {
    sustainableMonthlySpending: 0,
    sustainableAnnualSpending: 0,
    phaseBreakdown: undefined,
    trajectoryStatus: 'on_track',
    statusMessage: message,
    warningMessages: [],
    projectedReserveAtTarget: 0,
    projectedDepletionAge: null,
  };
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `npm run typecheck`
- [ ] Unit tests pass: `npm test -- depletion-feedback`
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Sustainable spending calculation is mathematically correct
- [ ] Status correctly identifies on_track/underspending/overspending

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation that the calculation logic is correct before proceeding to Phase 2.

---

## Phase 2: API Integration

### Overview
Integrate depletion feedback calculation into the projection API route and return it alongside projection results.

### Changes Required:

#### 1. Update Projection API Route
**File**: [src/app/api/projections/calculate/route.ts](src/app/api/projections/calculate/route.ts)
**Changes**: Add feedback calculation and return in response

```typescript
// Add import at top (after line 26)
import { calculateDepletionFeedback } from '@/lib/projections/depletion-feedback';

// In calculateProjection function, after line 264 (after running projection):
// Calculate depletion feedback if depletion target enabled
const depletionFeedback = projectionInput.depletionTarget?.enabled
  ? calculateDepletionFeedback(projectionInput, result.records)
  : null;

// Update return statement (line 293-316) to include depletionFeedback:
return {
  projection: result,
  inputs: {
    currentAge,
    retirementAge: projectionInput.retirementAge,
    maxAge: projectionInput.maxAge,
    expectedReturn: projectionInput.expectedReturn,
    inflationRate: projectionInput.inflationRate,
    contributionGrowthRate: projectionInput.contributionGrowthRate,
    incomeStreams: projectionInput.incomeStreams,
    spendingPhaseConfig: projectionInput.spendingPhaseConfig,
    depletionTarget: projectionInput.depletionTarget, // ADD
    reserveFloor: projectionInput.reserveFloor, // ADD
    annualExpenses,
    annualDebtPayments,
    annualContribution,
    startingBalancesByType: balancesByType,
  },
  depletionFeedback, // ADD
  meta: {
    calculationTimeMs,
    warnings: warnings.length > 0 ? warnings : undefined,
    inputWarnings: inputWarnings.length > 0 ? inputWarnings : undefined,
  },
};
```

#### 2. Update Projection Request Schema
**File**: [src/lib/validation/projections.ts](src/lib/validation/projections.ts)
**Changes**: Add depletion target to request schema (if not already present)

The schema should already support `depletionTarget` from Story 10.1. Verify and add if needed:

```typescript
// In projectionRequestSchema, add:
depletionTarget: depletionTargetSchema.optional(),
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `npm run typecheck`
- [ ] API returns 200 with depletionFeedback field: `curl -X POST localhost:3000/api/projections/calculate`
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] API returns `depletionFeedback: null` when depletion target disabled
- [ ] API returns full `depletionFeedback` object when depletion target enabled

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation that the API integration works before proceeding to Phase 3.

---

## Phase 3: Summary Component

### Overview
Create the DepletionFeedbackSummary component to display spending guidance with status indicators.

### Changes Required:

#### 1. Create DepletionFeedbackSummary Component
**File**: `src/components/projections/DepletionFeedbackSummary.tsx` (NEW)
**Changes**: Create the summary UI component

```typescript
'use client';

import type { DepletionFeedback, DepletionTarget } from '@/lib/projections/types';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { TrendingUp, TrendingDown, Check, AlertTriangle, Minus } from 'lucide-react';
import { cn } from '@/lib/utils';

interface DepletionFeedbackSummaryProps {
  feedback: DepletionFeedback;
  depletionTarget: DepletionTarget;
  currentPlannedSpending: number;
}

const statusConfig = {
  on_track: {
    icon: Check,
    color: 'text-green-600 dark:text-green-400',
    bgColor: 'bg-green-50 dark:bg-green-950/30',
    label: 'On Track',
  },
  underspending: {
    icon: TrendingDown,
    color: 'text-amber-600 dark:text-amber-400',
    bgColor: 'bg-amber-50 dark:bg-amber-950/30',
    label: 'Underspending',
  },
  overspending: {
    icon: TrendingUp,
    color: 'text-red-600 dark:text-red-400',
    bgColor: 'bg-red-50 dark:bg-red-950/30',
    label: 'Overspending',
  },
};

function formatCurrency(value: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    maximumFractionDigits: 0,
  }).format(value);
}

export function DepletionFeedbackSummary({
  feedback,
  depletionTarget,
  currentPlannedSpending,
}: DepletionFeedbackSummaryProps) {
  const { trajectoryStatus, sustainableMonthlySpending, sustainableAnnualSpending, phaseBreakdown } = feedback;
  const config = statusConfig[trajectoryStatus];
  const StatusIcon = config.icon;

  const currentMonthlySpending = currentPlannedSpending / 12;
  const spendingDiff = sustainableMonthlySpending - currentMonthlySpending;

  return (
    <Card>
      <CardHeader className="pb-3">
        <CardTitle className="text-lg flex items-center gap-2">
          Spending Guidance
          <span className={cn('px-2 py-0.5 rounded-full text-xs font-medium', config.bgColor, config.color)}>
            {config.label}
          </span>
        </CardTitle>
      </CardHeader>

      <CardContent className="space-y-4">
        {/* Main spending message */}
        <div className={cn('p-4 rounded-lg', config.bgColor)}>
          <p className="text-sm text-muted-foreground">
            To reach {depletionTarget.targetPercentageSpent}% depletion by age {depletionTarget.targetAge}:
          </p>
          <p className="text-2xl font-bold mt-1">
            {formatCurrency(sustainableMonthlySpending)}/month
          </p>
          <p className="text-sm text-muted-foreground mt-1">
            ({formatCurrency(sustainableAnnualSpending)}/year)
          </p>
        </div>

        {/* Comparison with current plan */}
        {currentPlannedSpending > 0 && (
          <div className="flex items-center gap-2 text-sm">
            {spendingDiff > 0 ? (
              <>
                <TrendingUp className="h-4 w-4 text-green-600 dark:text-green-400" />
                <span>
                  You can spend{' '}
                  <span className="font-medium text-green-600 dark:text-green-400">
                    {formatCurrency(Math.abs(spendingDiff))}/month more
                  </span>{' '}
                  than your current plan
                </span>
              </>
            ) : spendingDiff < 0 ? (
              <>
                <TrendingDown className="h-4 w-4 text-red-600 dark:text-red-400" />
                <span>
                  Your current plan is{' '}
                  <span className="font-medium text-red-600 dark:text-red-400">
                    {formatCurrency(Math.abs(spendingDiff))}/month higher
                  </span>{' '}
                  than sustainable
                </span>
              </>
            ) : (
              <>
                <Minus className="h-4 w-4 text-muted-foreground" />
                <span>Your current plan matches sustainable spending</span>
              </>
            )}
          </div>
        )}

        {/* Phase breakdown */}
        {phaseBreakdown && phaseBreakdown.length > 0 && (
          <div className="pt-4 border-t">
            <h4 className="text-sm font-medium mb-3">Spending by Life Phase</h4>
            <div className="space-y-2">
              {phaseBreakdown.map((phase) => (
                <div
                  key={phase.phaseName}
                  className="flex justify-between items-center p-2 bg-muted/50 rounded"
                >
                  <div>
                    <span className="font-medium">{phase.phaseName}</span>
                    <span className="text-sm text-muted-foreground ml-2">
                      (Ages {phase.startAge}-{phase.endAge})
                    </span>
                  </div>
                  <span className="font-medium">
                    {formatCurrency(phase.monthlySpending)}/mo
                  </span>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Warnings */}
        {feedback.warningMessages.length > 0 && (
          <div className="space-y-2">
            {feedback.warningMessages.map((warning, i) => (
              <Alert key={i} variant={trajectoryStatus === 'overspending' ? 'destructive' : 'default'} className="py-2">
                <AlertTriangle className="h-4 w-4" />
                <AlertDescription className="text-sm ml-2">
                  {warning}
                </AlertDescription>
              </Alert>
            ))}
          </div>
        )}

        {/* Reserve at target */}
        <div className="pt-4 border-t text-sm text-muted-foreground">
          <p>
            Projected balance at age {depletionTarget.targetAge}:{' '}
            <span className="font-medium text-foreground">
              {formatCurrency(feedback.projectedReserveAtTarget)}
            </span>
          </p>
        </div>
      </CardContent>
    </Card>
  );
}
```

#### 2. Export from Projections Index
**File**: [src/components/projections/index.ts](src/components/projections/index.ts)
**Changes**: Add export for new component

```typescript
export { DepletionFeedbackSummary } from './DepletionFeedbackSummary';
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `npm run typecheck`
- [ ] Component renders without errors in Storybook/test
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Component displays correct status badge colors
- [ ] Phase breakdown renders correctly when phases enabled
- [ ] Warnings display with appropriate styling

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation that the component renders correctly before proceeding to Phase 4.

---

## Phase 4: Chart Enhancements

### Overview
Add depletion target marker and optional target trajectory line to the ProjectionChart.

### Changes Required:

#### 1. Update ProjectionChart Props and Logic
**File**: [src/components/projections/ProjectionChart.tsx](src/components/projections/ProjectionChart.tsx)
**Changes**: Add depletion target visualization

```typescript
// Update interface (after line 38)
interface ProjectionChartProps {
  records: ProjectionRecord[];
  retirementAge: number;
  currentAge: number;
  inflationRate?: number;
  shortfallAge?: number;
  spendingEnabled?: boolean;
  onPhaseClick?: (phaseId: string) => void;
  reserveFloor?: number;
  // Epic 10.3: Depletion target visualization
  depletionTargetAge?: number;
  showTargetTrajectory?: boolean;
}

// Add to component props destructuring (around line 67)
depletionTargetAge,
showTargetTrajectory = true,

// Add calculation for depletion target X value (after shortfallXValue useMemo, around line 235)
const depletionTargetXValue = useMemo(() => {
  if (!depletionTargetAge) return null;
  if (xAxisType === 'age') {
    return depletionTargetAge;
  }
  const currentYear = new Date().getFullYear();
  return currentYear + (depletionTargetAge - currentAge);
}, [xAxisType, depletionTargetAge, currentAge]);

// Add target trajectory calculation (after depletionTargetXValue)
const targetTrajectoryData = useMemo(() => {
  if (!depletionTargetAge || !showTargetTrajectory || !reserveFloor || viewMode !== 'balance') {
    return null;
  }

  const startBalance = chartData[0]?.displayBalance ?? 0;
  const endBalance = adjustForInflation
    ? reserveFloor / Math.pow(1 + inflationRate, depletionTargetAge - currentAge)
    : reserveFloor;

  // Generate trajectory points only for ages we have data
  return chartData
    .filter(r => r.age >= currentAge && r.age <= depletionTargetAge)
    .map(r => {
      const progress = (r.age - currentAge) / (depletionTargetAge - currentAge);
      // Linear interpolation for simple visualization
      const targetBalance = startBalance - (startBalance - endBalance) * progress;

      return {
        xValue: r.xValue,
        targetBalance,
      };
    });
}, [chartData, depletionTargetAge, reserveFloor, showTargetTrajectory, currentAge, adjustForInflation, inflationRate, viewMode]);

// Add ReferenceLine for depletion target (after shortfall marker, around line 571)
{/* Depletion Target Age Marker */}
{depletionTargetXValue !== null && viewMode === 'balance' && (
  <ReferenceLine
    x={depletionTargetXValue}
    stroke="hsl(var(--primary))"
    strokeDasharray="5 5"
    label={{
      value: `Target Age ${depletionTargetAge}`,
      position: 'top',
      fill: 'hsl(var(--primary))',
      fontSize: 12,
    }}
  />
)}

// Add target trajectory line (after reserve visualization, before negative balance line)
{/* Target Trajectory Line */}
{targetTrajectoryData && viewMode === 'balance' && (
  <Line
    type="monotone"
    data={targetTrajectoryData}
    dataKey="targetBalance"
    stroke="hsl(var(--muted-foreground))"
    strokeDasharray="8 4"
    strokeWidth={1}
    dot={false}
    name="Target Trajectory"
  />
)}

// Update legend to include target trajectory (in reserve-enabled legend section, around line 680)
{depletionTargetAge && showTargetTrajectory && (
  <div className="flex items-center gap-2">
    <div className="h-0.5 w-4 border-b-2 border-dashed border-muted-foreground" />
    <span>Target Trajectory</span>
  </div>
)}
{depletionTargetAge && (
  <div className="flex items-center gap-2">
    <div className="h-4 w-0.5 border-l-2 border-dashed border-primary" />
    <span>Target Age</span>
  </div>
)}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `npm run typecheck`
- [ ] Chart renders without errors: `npm run dev`
- [x] Linting passes: `npm run lint`

#### Manual Verification:
- [ ] Depletion target marker appears at correct age
- [ ] Target trajectory line shows ideal path when enabled
- [ ] Legend updates to show new elements
- [ ] Tooltip still works correctly

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation that the chart visualizations are correct before proceeding to Phase 5.

---

## Phase 5: Plans Page Integration

### Overview
Wire up the depletion feedback to the Plans page, displaying the summary after snapshot cards.

### Changes Required:

#### 1. Update PlansClient Component
**File**: [src/app/plans/plans-client.tsx](src/app/plans/plans-client.tsx)
**Changes**: Add depletion feedback state and display

```typescript
// Add import (after line 12)
import { DepletionFeedbackSummary } from '@/components/projections';
import type { DepletionFeedback, DepletionTarget } from '@/lib/projections/types';

// Update PlansClientProps interface (after line 28)
interface PlansClientProps {
  initialProjection: ProjectionResult;
  currentAge: number;
  defaultAssumptions: Assumptions;
  currentAssumptions: Assumptions;
  monthlySpending: number;
  planId: string;
  initialSpendingConfig?: SpendingPhaseConfig | null;
  // Epic 10.3: Depletion feedback
  initialDepletionFeedback?: DepletionFeedback | null;
  depletionTarget?: DepletionTarget | null;
}

// Add to component props destructuring
initialDepletionFeedback,
depletionTarget,

// Add state for depletion feedback (after line 60)
const [depletionFeedback, setDepletionFeedback] = useState<DepletionFeedback | null>(
  initialDepletionFeedback ?? null
);

// Update the API response handling in useEffect (after line 107, in the recalculation effect)
// After: setProjection(data.projection);
if (data.depletionFeedback) {
  setDepletionFeedback(data.depletionFeedback);
} else {
  setDepletionFeedback(null);
}

// Update refetchProjection callback (after line 179)
// After: setProjection(data.projection);
if (data.depletionFeedback) {
  setDepletionFeedback(data.depletionFeedback);
}

// Add DepletionFeedbackSummary after Snapshot Cards (around line 499, after the grid of cards)
{/* Depletion Feedback Summary */}
{depletionFeedback && depletionTarget?.enabled && (
  <DepletionFeedbackSummary
    feedback={depletionFeedback}
    depletionTarget={depletionTarget}
    currentPlannedSpending={monthlySpending * 12}
  />
)}

// Update ProjectionChart props (around line 536)
<ProjectionChart
  records={projection.records}
  retirementAge={assumptions.retirementAge}
  currentAge={currentAge}
  inflationRate={assumptions.inflationRate}
  shortfallAge={shortfallAge}
  spendingEnabled={spendingConfig?.enabled ?? false}
  onPhaseClick={setEditingPhaseId}
  reserveFloor={projection.summary.reserveFloor}
  depletionTargetAge={depletionTarget?.enabled ? depletionTarget.targetAge : undefined}
  showTargetTrajectory={depletionTarget?.enabled}
/>
```

#### 2. Update Plans Page Server Component
**File**: [src/app/plans/page.tsx](src/app/plans/page.tsx)
**Changes**: Pass depletion feedback to client component

```typescript
// After projection calculation, calculate depletion feedback
// This requires importing and calling calculateDepletionFeedback

// Add import
import { calculateDepletionFeedback } from '@/lib/projections/depletion-feedback';

// After runProjection call (around line 281), add:
const depletionFeedback = projectionInput.depletionTarget?.enabled
  ? calculateDepletionFeedback(projectionInput, projection.records)
  : null;

// Update PlansClient props (around line 309)
<PlansClient
  initialProjection={projection}
  currentAge={currentAge}
  defaultAssumptions={defaultAssumptions}
  currentAssumptions={currentAssumptions}
  monthlySpending={monthlySpending}
  planId={planId}
  initialSpendingConfig={spendingPhaseConfig}
  initialDepletionFeedback={depletionFeedback}
  depletionTarget={projectionInput.depletionTarget}
/>
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation passes: `npm run typecheck`
- [ ] Page loads without errors: `npm run dev`
- [x] Linting passes: `npm run lint`
- [x] Build succeeds: `npm run build`

#### Manual Verification:
- [ ] Depletion feedback summary appears after snapshot cards
- [ ] Summary updates when depletion target settings change
- [ ] Chart shows target age marker and trajectory line
- [ ] Performance is acceptable (updates within 300ms)

**Implementation Note**: After completing this phase and all automated verification passes, pause here for comprehensive end-to-end testing.

---

## Testing Strategy

### Unit Tests:

1. **Depletion Feedback Calculation** (`__tests__/depletion-feedback.test.ts`)
   - Test sustainable withdrawal formula accuracy
   - Test trajectory status assessment (on_track, underspending, overspending)
   - Test phase breakdown calculation
   - Test edge cases (0 balance, negative years, etc.)

2. **Component Tests**
   - DepletionFeedbackSummary renders all states correctly
   - Status badge shows correct colors
   - Phase breakdown displays when phases provided

### Integration Tests:

1. **API Integration**
   - POST `/api/projections/calculate` returns depletionFeedback
   - Feedback is null when depletion target disabled
   - Feedback updates correctly with different inputs

### Manual Testing Steps:

1. Navigate to Plans page
2. Enable depletion target in profile settings
3. Set target to 75% by age 85
4. Verify spending guidance card appears
5. Adjust target percentage and verify real-time updates
6. Enable spending phases and verify phase breakdown displays
7. Test all three status states (adjust spending settings to trigger each)
8. Verify chart shows target marker and trajectory line
9. Toggle inflation adjustment and verify displays update

## Performance Considerations

- Depletion feedback calculation is O(n) where n = years in projection
- Calculation adds ~1-2ms to projection time (negligible)
- Debouncing prevents excessive recalculations
- No additional API calls required (piggybacks on projection)

## Migration Notes

None - this is a new feature with no existing data to migrate.

## References

- Research document: [thoughts/shared/research/2026-01-25-ENG-10.3-depletion-feedback-implementation.md](thoughts/shared/research/2026-01-25-ENG-10.3-depletion-feedback-implementation.md)
- Story 10.1: [depletion-target-input.tsx](src/components/depletion-target-input.tsx) - Depletion target input UI
- Story 10.2: [engine.ts:188-263](src/lib/projections/engine.ts#L188-L263) - Reserve preservation logic
- Epic 9: [plans-client.tsx](src/app/plans/plans-client.tsx) - Existing debounce pattern
