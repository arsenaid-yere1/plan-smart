---
date: 2025-12-29T12:00:00-08:00
researcher: Claude
git_commit: 5431711adf991c548eff68b9b2ba68735b939410
branch: main
repository: plan-smart
topic: "Story 3.5 — Persist Projection Results Implementation Research"
tags: [research, codebase, projections, persistence, database, epic-3]
status: complete
last_updated: 2025-12-29
last_updated_by: Claude
last_updated_note: "All questions resolved - ready for implementation"
---

# Research: Story 3.5 — Persist Projection Results

**Date**: 2025-12-29T12:00:00-08:00
**Researcher**: Claude
**Git Commit**: 5431711adf991c548eff68b9b2ba68735b939410
**Branch**: main
**Repository**: plan-smart

## Research Question

What is required to implement Story 3.5: Persist Projection Results? This involves storing projection outputs as structured JSON linked to a plan ID, including inputs, assumptions, and annual projection results, with support for re-rendering without recalculation and use as input for AI narrative generation.

## Summary

This research provides a comprehensive analysis of the existing codebase to support implementing projection result persistence. Key findings:

1. **Projection System**: A complete projection engine exists at `src/lib/projections/engine.ts` that calculates year-by-year retirement projections with tax-aware withdrawal strategies.

2. **Database Patterns**: The codebase uses Drizzle ORM with PostgreSQL/Supabase, JSONB columns for complex data, and Row-Level Security for user scoping.

3. **Existing Persistence Patterns**: Financial data is stored in `financial_snapshot` table with JSONB columns. Plans are stored in `plans` table with a `config` JSONB field.

4. **Authentication**: Supabase Auth with RLS policies ensures user data isolation. All queries are scoped to authenticated user IDs.

5. **AI Integration**: OpenAI GPT-4o-mini is already integrated for natural language parsing. Infrastructure exists to support future AI narrative generation.

## Detailed Findings

### 1. Projection Calculation System

#### Core Engine (`src/lib/projections/engine.ts`)

The projection engine implements an end-of-year retirement model with two phases:

**Accumulation Phase** (pre-retirement):
- Contribution growth: `input.annualContribution * Math.pow(1 + input.contributionGrowthRate, yearsFromStart)`
- Debt reduction applied before contributions
- End-of-year compounding: `balance * (1 + returnRate)`

**Drawdown Phase** (retirement):
- Dual inflation: general (2.5%) and healthcare (5%)
- Income stream aggregation with age-based activation
- Tax-aware withdrawal priority: taxable → taxDeferred → taxFree

#### Projection Input Structure (`src/lib/projections/types.ts:57-90`)

```typescript
interface ProjectionInput {
  currentAge: number;
  retirementAge: number;
  maxAge: number;
  balancesByType: BalanceByType;
  annualContribution: number;
  contributionAllocation: BalanceByType;
  contributionGrowthRate: number;
  expectedReturn: number;
  inflationRate: number;
  healthcareInflationRate: number;
  annualExpenses: number;
  annualHealthcareCosts: number;
  annualDebtPayments: number;
  incomeStreams: IncomeStream[];
}
```

#### Projection Output Structure (`src/lib/projections/types.ts:130-160`)

```typescript
interface ProjectionRecord {
  age: number;
  year: number;
  balance: number;
  inflows: number;
  outflows: number;
  balanceByType: BalanceByType;
  withdrawalsByType?: BalanceByType;
}

interface ProjectionSummary {
  startingBalance: number;
  endingBalance: number;
  totalContributions: number;
  totalWithdrawals: number;
  yearsUntilDepletion: number | null;
  projectedRetirementBalance: number;
}

interface ProjectionResult {
  records: ProjectionRecord[];
  summary: ProjectionSummary;
}
```

#### API Response Format (`src/app/api/projections/calculate/route.ts:176-197`)

Current API returns:
```typescript
{
  projection: ProjectionResult,
  inputs: {
    currentAge, retirementAge, maxAge, expectedReturn,
    inflationRate, contributionGrowthRate, incomeStreams,
    annualExpenses, annualDebtPayments, annualContribution,
    startingBalancesByType
  },
  meta: {
    calculationTimeMs: number,
    warnings?: string[]
  }
}
```

### 2. Database Schema and Patterns

#### Current Tables

| Table | Purpose | User Scoping |
|-------|---------|--------------|
| `user_profile` | Auth metadata, demographics | `id` = user ID |
| `financial_snapshot` | Financial data with JSONB | `userId` FK |
| `plans` | Retirement plans with config | `userId` FK |

#### JSONB Column Pattern (`src/db/schema/financial-snapshot.ts`)

```typescript
// Type-safe JSONB columns
investmentAccounts: jsonb('investment_accounts').$type<InvestmentAccountJson[]>(),
debts: jsonb('debts').$type<DebtJson[]>(),
incomeStreams: jsonb('income_streams').$type<IncomeStreamJson[]>(),
```

#### Plans Table Schema (`src/db/schema/plans.ts`)

```typescript
export const plans = pgTable('plans', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().references(() => userProfile.id, { onDelete: 'cascade' }),
  name: text('name').notNull(),
  description: text('description'),
  config: jsonb('config').notNull(),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});
```

### 3. Proposed Schema for Projection Results

Based on existing patterns, a new `projection_results` table should be created:

```typescript
// src/db/schema/projection-results.ts
export const projectionResults = pgTable('projection_results', {
  id: uuid('id').primaryKey().defaultRandom(),
  planId: uuid('plan_id').notNull().references(() => plans.id, { onDelete: 'cascade' }),
  userId: uuid('user_id').notNull().references(() => userProfile.id, { onDelete: 'cascade' }),

  // Stored inputs (for re-rendering and audit)
  inputs: jsonb('inputs').notNull().$type<ProjectionInput>(),

  // Stored assumptions (human-readable snapshot)
  assumptions: jsonb('assumptions').notNull().$type<ProjectionAssumptions>(),

  // Projection results
  records: jsonb('records').notNull().$type<ProjectionRecord[]>(),
  summary: jsonb('summary').notNull().$type<ProjectionSummary>(),

  // Metadata
  calculationTimeMs: integer('calculation_time_ms'),
  version: integer('version').notNull().default(1),

  // Timestamps
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});
```

#### Type Definitions

```typescript
// New type for stored assumptions
interface ProjectionAssumptions {
  expectedReturn: number;
  inflationRate: number;
  healthcareInflationRate: number;
  contributionGrowthRate: number;
  retirementAge: number;
  maxAge: number;
}
```

### 4. Authentication and User Scoping

#### RLS Policies (required for new table)

```sql
ALTER TABLE "projection_results" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only access their own projection results"
  ON "projection_results"
  FOR ALL
  USING (auth.uid() = user_id);
```

#### Application-Level Pattern

```typescript
// Following existing pattern from secure-query.ts
async getProjectionResults(planId: string) {
  return db.select().from(projectionResults)
    .where(and(
      eq(projectionResults.planId, planId),
      eq(projectionResults.userId, this.userId)
    ));
}

async saveProjectionResult(data: Omit<typeof projectionResults.$inferInsert, 'userId'>) {
  const [created] = await db.insert(projectionResults)
    .values({ ...data, userId: this.userId })
    .returning();
  return created;
}
```

### 5. AI Narrative Generation Support

#### Current AI Integration

- **Package**: `openai` v6.13.0
- **Model**: `gpt-4o-mini`
- **Endpoint**: `/api/parse-financial-nl`
- **Pattern**: Structured JSON output with confidence scores

#### Proposed Narrative Generation

For AI narrative generation from stored projections:

```typescript
// src/app/api/projections/[id]/narrative/route.ts
const NARRATIVE_PROMPT = `
You are a financial advisor explaining retirement projection results.
Given the following projection data, provide a clear, personalized narrative.

Projection Summary:
- Starting Balance: $${summary.startingBalance.toLocaleString()}
- Projected Retirement Balance: $${summary.projectedRetirementBalance.toLocaleString()}
- Years Until Depletion: ${summary.yearsUntilDepletion ?? 'Never (sustainable)'}

Key Assumptions:
- Expected Return: ${assumptions.expectedReturn * 100}%
- Inflation Rate: ${assumptions.inflationRate * 100}%
- Retirement Age: ${assumptions.retirementAge}

Generate a 2-3 paragraph summary that:
1. Explains the overall health of the retirement plan
2. Highlights key milestones and risks
3. Provides actionable recommendations
`;
```

### 6. Implementation Approach

#### Phase 1: Database Schema
1. Create `projection_results` table schema in `src/db/schema/projection-results.ts`
2. Export from `src/db/schema/index.ts`
3. Generate migration with `npm run db:generate`
4. Apply migration with `npm run db:migrate`

#### Phase 2: API Endpoints
1. `POST /api/projections/save` - Save projection result linked to plan
2. `GET /api/projections/[planId]` - Retrieve stored projection
3. `GET /api/projections/[planId]/latest` - Get most recent projection for plan

#### Phase 3: Re-rendering Support
1. Load stored projection without recalculation
2. Display stored inputs/assumptions alongside results
3. Indicate staleness if financial snapshot changed since calculation

#### Phase 4: AI Narrative Integration
1. `POST /api/projections/[id]/narrative` - Generate AI narrative from stored data
2. Store narrative alongside projection results
3. Cache narrative to avoid regeneration costs

## Code References

### Projection Engine
- [engine.ts:117](src/lib/projections/engine.ts#L117) - `runProjection()` main function
- [engine.ts:14](src/lib/projections/engine.ts#L14) - `withdrawFromAccounts()` tax-aware withdrawal
- [types.ts:57-90](src/lib/projections/types.ts#L57-L90) - `ProjectionInput` interface
- [types.ts:130-160](src/lib/projections/types.ts#L130-L160) - `ProjectionRecord` and `ProjectionSummary`

### Database Schema
- [financial-snapshot.ts](src/db/schema/financial-snapshot.ts) - JSONB column patterns
- [plans.ts](src/db/schema/plans.ts) - Plans table with config JSONB
- [secure-query.ts](src/db/secure-query.ts) - User-scoped query builder

### API Routes
- [route.ts](src/app/api/projections/calculate/route.ts) - Current projection calculation API
- [route.ts](src/app/api/profile/route.ts) - PATCH pattern for updates

### Authentication
- [server.ts](src/lib/auth/server.ts) - `getServerUser()` helper
- [0000_tricky_the_professor.sql](src/db/migrations/0000_tricky_the_professor.sql) - RLS policies

### AI Integration
- [route.ts](src/app/api/parse-financial-nl/route.ts) - OpenAI integration pattern

## Architecture Insights

### Design Patterns to Follow

1. **JSONB for Complex Data**: Use typed JSONB columns (`.$type<T>()`) for storing projection inputs, assumptions, and results.

2. **Dual Foreign Keys**: Reference both `planId` and `userId` for efficient querying and RLS enforcement.

3. **Cascade Deletes**: Use `{ onDelete: 'cascade' }` to auto-cleanup when plan or user is deleted.

4. **Versioning**: Include a `version` field to track schema evolution.

5. **Timestamps with Triggers**: Use auto-update triggers for `updatedAt` columns.

### Security Considerations

1. **RLS Policy**: Must enable RLS and create policy using `auth.uid() = user_id`.
2. **Application Filtering**: Always include `userId` in WHERE clauses as defense-in-depth.
3. **Plan Ownership Check**: Verify user owns the plan before saving projection.

### Performance Considerations

1. **JSONB Indexing**: Consider GIN index on `inputs` or `assumptions` for filtering.
2. **Pagination**: For plans with many projections, implement limit/offset.
3. **Selective Loading**: Allow loading summary without full records array.

## Historical Context (from thoughts/)

### Related Planning Documents
- [story-5-scope.md](thoughts/personal/tickets/epic-3/projection-modeling/story-5-scope.md) - Original acceptance criteria
- [story-3-scope.md](thoughts/personal/tickets/epic-3/projection-modeling/story-3-scope.md) - AI narrative features referenced
- [2025-12-18-epic-3-story-1-projection-engine.md](thoughts/shared/plans/2025-12-18-epic-3-story-1-projection-engine.md) - Projection engine implementation

### Architecture Decisions
- [2025-11-17-authentication-provider-decision.md](thoughts/shared/architecture/2025-11-17-authentication-provider-decision.md) - Database and RLS architecture

## Related Research
- [2025-12-17-epic-3-projection-engine-implementation-readiness.md](thoughts/shared/research/2025-12-17-epic-3-projection-engine-implementation-readiness.md)
- [2025-12-26-story-3.4-multiple-income-expense-streams-research.md](thoughts/shared/research/2025-12-26-story-3.4-multiple-income-expense-streams-research.md)

## Resolved Questions

### 1. Staleness Detection (RESOLVED)

**Decision: Field-Level Change Tracking (Option D)**

Since we're already storing `inputs` per the acceptance criteria, we can leverage this for accurate staleness detection by comparing stored inputs against current snapshot-derived inputs.

#### Options Analyzed

| Option | Approach | Pros | Cons |
|--------|----------|------|------|
| A | Timestamp comparison | Simple, uses existing triggers | Any update marks stale, even non-material |
| B | Snapshot hash | Detects material changes only | Complex, ordering-sensitive |
| C | Version counter | Simple integer comparison | Requires schema change, same issue as A |
| **D** | **Field-level comparison** | **Most accurate, enables change reporting** | **Deep comparison cost** |

#### Why Option D

1. **Already storing inputs** - The acceptance criteria requires storing inputs, so no additional data needed
2. **Accurate detection** - Only marks stale when actual projection inputs changed
3. **Change reporting** - Can show users exactly what changed (useful for AI narrative)
4. **AI integration** - Enables explanations like "Your income increased by $5k since last projection"

#### Implementation

```typescript
// src/lib/projections/staleness.ts
import { ProjectionInput } from './types';
import { FinancialSnapshot } from '@/db/schema/financial-snapshot';
import { buildProjectionInput } from './input-builder';

export interface StalenessResult {
  isStale: boolean;
  changedFields: string[];
  changes: Record<string, { previous: unknown; current: unknown }>;
}

export function checkProjectionStaleness(
  storedInputs: ProjectionInput,
  currentSnapshot: FinancialSnapshot
): StalenessResult {
  const currentInputs = buildProjectionInput(currentSnapshot);
  const changedFields: string[] = [];
  const changes: Record<string, { previous: unknown; current: unknown }> = {};

  // Check material fields that affect projection outcomes
  const fieldsToCheck: (keyof ProjectionInput)[] = [
    'currentAge',
    'retirementAge',
    'maxAge',
    'annualContribution',
    'expectedReturn',
    'inflationRate',
    'healthcareInflationRate',
    'annualExpenses',
    'annualHealthcareCosts',
    'annualDebtPayments',
    'contributionGrowthRate',
  ];

  for (const field of fieldsToCheck) {
    if (storedInputs[field] !== currentInputs[field]) {
      changedFields.push(field);
      changes[field] = {
        previous: storedInputs[field],
        current: currentInputs[field],
      };
    }
  }

  // Deep compare complex objects
  if (!deepEqualBalances(storedInputs.balancesByType, currentInputs.balancesByType)) {
    changedFields.push('balancesByType');
    changes['balancesByType'] = {
      previous: storedInputs.balancesByType,
      current: currentInputs.balancesByType,
    };
  }

  if (!deepEqualIncomeStreams(storedInputs.incomeStreams, currentInputs.incomeStreams)) {
    changedFields.push('incomeStreams');
    changes['incomeStreams'] = {
      previous: storedInputs.incomeStreams,
      current: currentInputs.incomeStreams,
    };
  }

  return {
    isStale: changedFields.length > 0,
    changedFields,
    changes,
  };
}

function deepEqualBalances(a: BalanceByType, b: BalanceByType): boolean {
  return (
    a.taxDeferred === b.taxDeferred &&
    a.taxFree === b.taxFree &&
    a.taxable === b.taxable
  );
}

function deepEqualIncomeStreams(a: IncomeStream[], b: IncomeStream[]): boolean {
  if (a.length !== b.length) return false;
  // Sort by ID for consistent comparison
  const sortedA = [...a].sort((x, y) => x.id.localeCompare(y.id));
  const sortedB = [...b].sort((x, y) => x.id.localeCompare(y.id));
  return JSON.stringify(sortedA) === JSON.stringify(sortedB);
}
```

#### UI Integration

```typescript
// In plans page or projection display component
const { isStale, changedFields, changes } = checkProjectionStaleness(
  storedProjection.inputs,
  currentSnapshot
);

if (isStale) {
  // Show staleness indicator with details
  return (
    <Alert variant="warning">
      <AlertTitle>Projection may be outdated</AlertTitle>
      <AlertDescription>
        Your financial data has changed since this projection was calculated.
        Changed: {changedFields.join(', ')}
      </AlertDescription>
      <Button onClick={recalculate}>Recalculate Projection</Button>
    </Alert>
  );
}
```

#### AI Narrative Integration

The `changes` object enables rich AI narratives:

```typescript
const STALENESS_NARRATIVE_PROMPT = `
The user's projection is outdated. Explain the impact of these changes:
${Object.entries(changes).map(([field, { previous, current }]) =>
  `- ${field}: ${previous} → ${current}`
).join('\n')}

Provide a brief explanation of how these changes might affect their retirement outlook.
`;
```

---

### 2. AI Narrative Storage (RESOLVED)

**Decision: Separate `projection_narratives` Table (Option B)**

AI-generated narratives should be stored in a dedicated table rather than as a column in `projection_results`.

#### Options Analyzed

| Option | Approach | Pros | Cons |
|--------|----------|------|------|
| A | JSONB column in projection_results | Simple, single query | Couples narrative lifecycle to projection, bloats table |
| **B** | **Separate projection_narratives table** | **Independent lifecycle, multiple narratives per projection, cleaner schema** | **Additional join required** |

#### Why Option B

1. **Independent lifecycle** - Narratives can be regenerated without touching projection data
2. **Multiple narratives** - Support different narrative types (summary, detailed, comparison)
3. **Versioning** - Track narrative regenerations over time
4. **Cost tracking** - Store token usage and generation metadata separately
5. **Lazy generation** - Projection can exist without narrative; generate on-demand
6. **Cache invalidation** - Clear narratives independently when AI prompts improve

#### Schema

```typescript
// src/db/schema/projection-narratives.ts
import { pgTable, uuid, text, jsonb, timestamp, integer } from 'drizzle-orm/pg-core';
import { projectionResults } from './projection-results';
import { userProfile } from './user-profile';

export type NarrativeType = 'summary' | 'detailed' | 'comparison' | 'staleness';

export interface NarrativeMetadata {
  model: string;           // e.g., 'gpt-4o-mini'
  promptVersion: string;   // e.g., 'v1.2'
  tokensUsed: number;
  generationTimeMs: number;
}

export const projectionNarratives = pgTable('projection_narratives', {
  id: uuid('id').primaryKey().defaultRandom(),
  projectionResultId: uuid('projection_result_id')
    .notNull()
    .references(() => projectionResults.id, { onDelete: 'cascade' }),
  userId: uuid('user_id')
    .notNull()
    .references(() => userProfile.id, { onDelete: 'cascade' }),

  // Narrative content
  type: text('type').notNull().$type<NarrativeType>(),
  content: text('content').notNull(),

  // Generation metadata
  metadata: jsonb('metadata').$type<NarrativeMetadata>(),

  // For comparison narratives, reference the baseline projection
  comparedToProjectionId: uuid('compared_to_projection_id')
    .references(() => projectionResults.id, { onDelete: 'set null' }),

  // Timestamps
  createdAt: timestamp('created_at').defaultNow(),
});
```

#### RLS Policy

```sql
ALTER TABLE "projection_narratives" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only access their own narratives"
  ON "projection_narratives"
  FOR ALL
  USING (auth.uid() = user_id);
```

#### API Endpoints

```typescript
// Generate narrative for a projection
POST /api/projections/[id]/narrative
Body: { type: 'summary' | 'detailed' | 'comparison', comparedToId?: string }

// Get narratives for a projection
GET /api/projections/[id]/narratives
Response: { narratives: ProjectionNarrative[] }

// Regenerate a specific narrative (e.g., after prompt improvements)
POST /api/narratives/[id]/regenerate
```

#### Query Patterns

```typescript
// Get projection with latest summary narrative
async getProjectionWithNarrative(projectionId: string) {
  const [projection] = await db
    .select()
    .from(projectionResults)
    .where(eq(projectionResults.id, projectionId));

  const [narrative] = await db
    .select()
    .from(projectionNarratives)
    .where(and(
      eq(projectionNarratives.projectionResultId, projectionId),
      eq(projectionNarratives.type, 'summary')
    ))
    .orderBy(desc(projectionNarratives.createdAt))
    .limit(1);

  return { projection, narrative };
}

// Check if narrative exists (for lazy generation)
async hasNarrative(projectionId: string, type: NarrativeType): Promise<boolean> {
  const [result] = await db
    .select({ count: count() })
    .from(projectionNarratives)
    .where(and(
      eq(projectionNarratives.projectionResultId, projectionId),
      eq(projectionNarratives.type, type)
    ));
  return result.count > 0;
}
```

#### Narrative Types

| Type | Purpose | When Generated |
|------|---------|----------------|
| `summary` | 2-3 paragraph overview of projection health | On-demand when user views projection |
| `detailed` | Comprehensive analysis with recommendations | User requests detailed view |
| `comparison` | Explains difference between two projections | When comparing scenarios |
| `staleness` | Explains impact of changed inputs | When projection marked stale |

#### Cost Optimization

```typescript
// Only generate if not already cached
async getOrGenerateNarrative(
  projectionId: string,
  type: NarrativeType
): Promise<string> {
  const existing = await db
    .select()
    .from(projectionNarratives)
    .where(and(
      eq(projectionNarratives.projectionResultId, projectionId),
      eq(projectionNarratives.type, type)
    ))
    .limit(1);

  if (existing.length > 0) {
    return existing[0].content;
  }

  // Generate new narrative
  const content = await generateNarrative(projectionId, type);

  // Store for future use
  await db.insert(projectionNarratives).values({
    projectionResultId: projectionId,
    userId: this.userId,
    type,
    content,
    metadata: { model: 'gpt-4o-mini', promptVersion: 'v1.0', ... }
  });

  return content;
}
```

---

### 3. Multiple Projections per Plan (RESOLVED)

**Decision: One-to-One (Update in Place)**

Each plan has exactly one stored projection result, updated in place when recalculated.

#### Options Analyzed

| Option | Approach | Pros | Cons |
|--------|----------|------|------|
| **A** | **One-to-one (update in place)** | **Simple, matches AC, storage efficient** | **No history** |
| B | One-to-many with latest flag | Tracks history, compare scenarios | Complex, storage bloat |

#### Why Option A

1. **Matches acceptance criteria** - "re-rendered without recalculation" implies caching, not versioning
2. **Staleness detection handles changes** - Already detecting when inputs change and prompting recalculation
3. **Comparison via narratives** - The `projection_narratives` table already has `comparedToProjectionId` for future comparison features
4. **Storage efficiency** - Projection records arrays can be large (40+ years of data); no need to accumulate
5. **Simpler queries** - No need for `isLatest` flag or version ordering

#### Schema Update

Add unique constraint on `planId`:

```typescript
// src/db/schema/projection-results.ts
export const projectionResults = pgTable('projection_results', {
  id: uuid('id').primaryKey().defaultRandom(),
  planId: uuid('plan_id')
    .notNull()
    .unique()  // Enforces one-to-one relationship
    .references(() => plans.id, { onDelete: 'cascade' }),
  userId: uuid('user_id')
    .notNull()
    .references(() => userProfile.id, { onDelete: 'cascade' }),

  // ... rest of schema
});
```

#### Upsert Pattern

```typescript
// src/db/secure-query.ts
async saveProjectionResult(
  planId: string,
  data: Omit<ProjectionResultInsert, 'planId' | 'userId'>
) {
  const [result] = await db
    .insert(projectionResults)
    .values({
      planId,
      userId: this.userId,
      ...data,
    })
    .onConflictDoUpdate({
      target: projectionResults.planId,
      set: {
        inputs: data.inputs,
        assumptions: data.assumptions,
        records: data.records,
        summary: data.summary,
        calculationTimeMs: data.calculationTimeMs,
        updatedAt: new Date(),
      },
    })
    .returning();

  return result;
}

async getProjectionForPlan(planId: string) {
  const [result] = await db
    .select()
    .from(projectionResults)
    .where(and(
      eq(projectionResults.planId, planId),
      eq(projectionResults.userId, this.userId)
    ));

  return result ?? null;
}
```

#### Future Scenario Comparison

If explicit scenario comparison is needed later, it would be a separate feature:
- User explicitly "saves" a scenario as a named snapshot
- New `projection_scenarios` table with `name`, `description`
- Not part of Story 3.5 scope

---

## Open Questions

All questions resolved. Ready for implementation.
