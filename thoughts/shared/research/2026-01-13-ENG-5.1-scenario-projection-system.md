---
date: 2026-01-13T00:00:00-08:00
researcher: Claude Sonnet 4.5
git_commit: f2f53273b619ad6cfaa2a819946967c492756e67
branch: main
repository: plan-smart
topic: "How the current scenario/projection system works"
tags: [research, codebase, projections, scenarios, epic-5, what-if, assumptions]
status: complete
last_updated: 2026-01-13
last_updated_by: Claude Sonnet 4.5
---

# Research: How the Current Scenario/Projection System Works

**Date**: 2026-01-13T00:00:00-08:00
**Researcher**: Claude Sonnet 4.5
**Git Commit**: f2f53273b619ad6cfaa2a819946967c492756e67
**Branch**: main
**Repository**: plan-smart

## Research Question

How does the current scenario/projection system work? This research supports Epic 5 Story 5.1: Natural-Language Scenario Parsing with Confirmation, which will allow users to ask "what if" questions in plain English with AI parsing and user confirmation.

## Summary

The projection system uses a **three-layer architecture** with well-defined data structures and an override mechanism that provides the foundation for scenario modeling:

1. **Data Layer**: `ProjectionInput` (computation-ready), `ProjectionAssumptions` (human-readable snapshot), and `ProjectionOverrides` (optional modifications)
2. **Calculation Layer**: Year-by-year simulation with two phases (accumulation and drawdown) using tax-aware strategies
3. **UI Layer**: Real-time assumption adjustments with automatic recalculation and debounced API calls

**Key Finding for Epic 5**: The existing `ProjectionOverrides` structure already contains all the parameters needed for "what-if" scenarios. The system supports on-the-fly calculations without corrupting base data, aligning perfectly with Story 5.1's "Safe by Design" goal. To extend for named scenarios, only schema additions and diff calculation are needed—the core architecture is scenario-ready.

## Detailed Findings

### 1. Core Data Structures

The projection system uses distinct types for different purposes:

#### ProjectionInput (Computation-Ready)
**Location**: [src/lib/projections/types.ts:57-90](src/lib/projections/types.ts#L57-L90)

Complete computational input containing:
- **Age parameters**: currentAge, retirementAge, maxAge
- **Account balances by tax category**: `BalanceByType` with taxDeferred, taxFree, taxable
- **Contribution configuration**: annualContribution, contributionAllocation, contributionGrowthRate
- **Return assumptions**: expectedReturn, inflationRate
- **Expenses**: annualExpenses, annualHealthcareCosts, healthcareInflationRate
- **Income/Debt**: incomeStreams array, annualDebtPayments

Tax categories are mapped via `ACCOUNT_TAX_CATEGORY` constant ([types.ts:35-42](src/lib/projections/types.ts#L35-L42)):
```typescript
{
  '401k': 'taxDeferred',
  'IRA': 'taxDeferred',
  'Roth_IRA': 'taxFree',
  'Brokerage': 'taxable',
  'Cash': 'taxable',
  'Other': 'taxable'
}
```

#### ProjectionAssumptions (Human-Readable Subset)
**Location**: [src/lib/projections/types.ts:173-180](src/lib/projections/types.ts#L173-L180)

Simplified snapshot containing only the 6 key configurable parameters:
- expectedReturn
- inflationRate
- healthcareInflationRate
- contributionGrowthRate
- retirementAge
- maxAge

**Purpose**: Stored alongside results for AI narrative generation and UI display.

#### ProjectionOverrides (Scenario Parameters)
**Location**: [src/lib/projections/input-builder.ts:20-30](src/lib/projections/input-builder.ts#L20-L30)

Optional modifications structure containing:
- Economic assumptions: expectedReturn, inflationRate, maxAge
- Life planning: retirementAge
- Income modeling: incomeStreams
- Cost planning: annualHealthcareCosts, healthcareInflationRate
- Savings strategy: contributionGrowthRate, contributionAllocation

**Critical Insight**: This structure already provides the foundation for scenario modeling—it contains all scenario-variable parameters.

#### Income Streams (Flexible Income Modeling)
**Location**: [src/lib/projections/types.ts:22-30](src/lib/projections/types.ts#L22-L30)

```typescript
{
  id: string,
  name: string,
  type: IncomeStreamType, // social_security, pension, rental, annuity, part_time, other
  annualAmount: number,
  startAge: number,
  endAge?: number,
  inflationAdjusted: boolean
}
```

Supports multiple income sources with different start/end ages and inflation treatment.

### 2. Database Storage

#### projection_results Table Schema
**Location**: [src/db/schema/projection-results.ts:11-37](src/db/schema/projection-results.ts#L11-L37)

Stores complete projection results with one-to-one relationship to plans:

- **Primary Key**: `id` (uuid)
- **Relationships**:
  - `planId` (uuid) with `.unique()` constraint - enforces one projection per plan
  - `userId` (uuid) for Row-Level Security
- **JSONB Columns**:
  - `inputs` (ProjectionInput) - Complete computational input for re-rendering
  - `assumptions` (ProjectionAssumptions) - Human-readable subset for AI/UI
  - `records` (ProjectionRecord[]) - Year-by-year projection data for charting
  - `summary` (ProjectionSummary) - Aggregate statistics
- **Metadata**: calculationTimeMs, createdAt, updatedAt

**One-to-One Constraint**: The unique constraint on `planId` means only one projection per plan currently. To support named scenarios, this would need to become a composite key `[planId, scenarioName]`.

#### Save Operation
**Location**: [src/db/secure-query.ts:86-117](src/db/secure-query.ts#L86-L117)

Uses upsert pattern with `onConflictDoUpdate`:
- Target: `projectionResults.planId`
- On conflict: Updates all data fields and `updatedAt` timestamp
- Security: Enforces user ownership via `this.userId`
- Automatic deduplication for same plan

### 3. Projection Calculation Engine

#### Entry Points
**Location**: [src/app/api/projections/calculate/route.ts](src/app/api/projections/calculate/route.ts)

- **GET handler** ([route.ts:276](src/app/api/projections/calculate/route.ts#L276)): Runs projection with all defaults
- **POST handler** ([route.ts:302-335](src/app/api/projections/calculate/route.ts#L302-L335)): Accepts optional overrides

#### Calculation Orchestration
**Location**: [src/app/api/projections/calculate/route.ts:102-271](src/app/api/projections/calculate/route.ts#L102-L271)

The `calculateProjection()` function orchestrates:

1. **Fetch Financial Snapshot** (lines 108-116): Queries user's current financial state
2. **Aggregate Balances by Tax Category** (lines 124-139): Maps account types to tax categories
3. **Calculate Annual Contribution** (lines 142-145): Sums monthly contributions × 12
4. **Derive Annual Expenses** (lines 148-161): Uses actual data or derives from income/savings rate
5. **Estimate Debt Payments** (lines 164-165): 10-year amortization calculation
6. **Build Income Streams** (lines 174-179): Handles backward compatibility with legacy SS fields
7. **Construct ProjectionInput** (lines 182-197): Combines snapshot + overrides + defaults
8. **Validate Age Relationships** (lines 200-211): Ensures currentAge < retirementAge < maxAge
9. **Generate Warnings** (lines 214-215): Non-blocking warnings for unusual inputs
10. **Run Projection** (lines 218-220): Calls core engine
11. **Conditional Persistence** (lines 227-246): Saves to database if planId provided
12. **Response Construction** (lines 248-270): Returns projection + meta + warnings

#### Core Projection Engine
**Location**: [src/lib/projections/engine.ts:117-240](src/lib/projections/engine.ts#L117-L240)

The `runProjection()` function implements year-by-year simulation:

**Initialization** (lines 118-128):
```typescript
const records: ProjectionRecord[] = [];
let balances = { ...input.balancesByType };
let totalContributions = 0;
let totalWithdrawals = 0;
let yearsUntilDepletion: number | null = null;
```

**Main Loop** (lines 130-227): Iterates from currentAge to maxAge

**Phase A: Accumulation** (age < retirementAge, lines 140-159):
1. Calculate grown contribution with growth rate: `annualContribution * (1 + growthRate)^years`
2. Subtract debt payments: `Math.max(0, grownContribution - debtPayments)`
3. Add contributions by allocation percentage to each tax category
4. Apply returns: `balance * (1 + returnRate)` (end-of-year model)

**Phase B: Drawdown** (age >= retirementAge, lines 160-207):
1. Calculate inflation-adjusted general expenses: `annualExpenses * (1 + inflationRate)^years`
2. Calculate healthcare costs with separate inflation: `healthcareCosts * (1 + healthcareInflation)^years`
3. Calculate total income from active streams (checking age ranges)
4. Calculate net withdrawal needed: `Max(0, expenses - income)`
5. Execute tax-aware withdrawal strategy (see below)
6. Subtract withdrawals from balances
7. Apply returns to remaining balance
8. Track depletion year if balance reaches zero

#### Tax-Aware Withdrawal Strategy
**Location**: [src/lib/projections/engine.ts:14-43](src/lib/projections/engine.ts#L14-L43)

The `withdrawFromAccounts()` function implements waterfall withdrawal:
1. **First**: Withdraw from taxable accounts (capital gains treatment)
2. **Second**: Withdraw from tax-deferred accounts (ordinary income)
3. **Third**: Withdraw from tax-free accounts (preserve tax-free growth)

Returns `{ withdrawals, shortfall }` where shortfall is any unmet need.

### 4. Default Assumptions

**Location**: [src/lib/projections/assumptions.ts](src/lib/projections/assumptions.ts)

#### Return Rates by Risk Tolerance (lines 7-11)
```typescript
DEFAULT_RETURN_RATES = {
  conservative: 0.04,  // 4%
  moderate: 0.06,      // 6%
  aggressive: 0.08,    // 8%
}
```

#### Inflation Rates
- **General Inflation**: 2.5% (line 16)
- **Healthcare Inflation**: 5% (line 45)

#### Age Assumptions
- **Max Age**: 90 (line 21)
- **Social Security Age**: 67 (line 26)

#### Contribution Allocation (lines 31-35)
```typescript
DEFAULT_CONTRIBUTION_ALLOCATION = {
  taxDeferred: 60,  // 60% to 401k/IRA
  taxFree: 30,      // 30% to Roth IRA
  taxable: 10,      // 10% to brokerage
}
```

#### Healthcare Costs by Age (lines 51-55)
- Under 65: $8,000/year (pre-Medicare)
- 65-74: $6,500/year (early Medicare)
- 75+: $12,000/year (late retirement)

#### Social Security Estimation (lines 84-104)
Uses tiered replacement rates:
- Income ≤ $30k: 55% replacement
- Income $30k-$80k: 40% replacement on amount over $30k
- Income > $80k: 30% replacement on amount over $80k
Applies 20% conservative haircut and caps at $4,500/month.

### 5. Override Mechanism (Current "What-If" System)

#### API Override Flow
**Location**: [src/app/api/projections/calculate/route.ts:302-335](src/app/api/projections/calculate/route.ts#L302-L335)

1. **Extract overrides from request body** (lines 310-311):
```typescript
const { planId, ...overridesBody } = body;
```

2. **Validate against schema** (line 312): Uses Zod validation from [src/lib/validation/projections.ts:33-105](src/lib/validation/projections.ts#L33-L105)

3. **Apply overrides using nullish coalescing** throughout calculation:
```typescript
expectedReturn: (overrides.expectedReturn as number) ?? DEFAULT_RETURN_RATES[riskTolerance]
inflationRate: (overrides.inflationRate as number) ?? DEFAULT_INFLATION_RATE
retirementAge: (overrides.retirementAge as number) ?? snapshot.targetRetirementAge
```

**Override Hierarchy**: Overrides → Snapshot Data → Defaults (from constants)

#### Validation Rules
**Location**: [src/lib/validation/projections.ts:33-105](src/lib/validation/projections.ts#L33-L105)

- expectedReturn: 0-30%, optional
- inflationRate: 0-10%, optional
- maxAge: 50-120, optional
- contributionGrowthRate: 0-10%, optional
- retirementAge: 30-80, optional
- contributionAllocation: Percentages must sum to 100
- incomeStreams: Array validation with type checking

### 6. UI State Management and User Flow

#### PlansClient Component
**Location**: [src/app/plans/plans-client.tsx:27-349](src/app/plans/plans-client.tsx#L27-L349)

**Core State** (lines 35-41):
```typescript
const [assumptions, setAssumptions] = useState<Assumptions>(currentAssumptions);
const [projection, setProjection] = useState<ProjectionResult>(initialProjection);
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const [validationError, setValidationError] = useState<string | null>(null);
const [inputWarnings, setInputWarnings] = useState<ProjectionWarning[]>([]);
```

**Debounced Recalculation** (lines 44-110):
- **Change Detection**: Compares assumptions to currentAssumptions
- **300ms Debounce**: Waits for user to stop adjusting before API call
- **AbortController**: Cancels in-flight requests when assumptions change again
- **Auto-Persistence**: Includes planId in request for automatic save
- **Error Handling**: Distinguishes validation errors (400) from general errors

**Reset Mechanism** (lines 112-114):
```typescript
const handleReset = useCallback(() => {
  setAssumptions(defaultAssumptions);
}, [defaultAssumptions]);
```

#### AssumptionsPanel Component
**Location**: [src/components/projections/AssumptionsPanel.tsx:25-270](src/components/projections/AssumptionsPanel.tsx#L25-L270)

Manages three assumptions with dual input methods (text inputs + sliders):

**Local Input State** (lines 34-42): Allows typing invalid values during entry without breaking validation

**Text Input Validation** (lines 56-101):
- Blur handler parses and validates input
- Clamps to valid ranges
- Resets to current value if invalid (NaN)
- Converts percentage display to decimal storage

**Slider Integration** (lines 104-118):
- Updates local text input state to match slider
- Immediately calls onChange to propagate

**Reset Button** (lines 121-126):
- Only appears when hasChanges is true
- Resets all inputs to defaultAssumptions
- Disabled during loading

**Modified Indicators** (lines 52-53): Shows "(modified)" text when value differs from defaults

#### User Flow

1. **User Adjusts Slider or Types in Input**:
   - AssumptionsPanel local state updates
   - On blur/Enter (text) or immediate (slider): Validates and calls onChange

2. **PlansClient Receives Change**:
   - setAssumptions updates state
   - useEffect detects change

3. **After 300ms Debounce**:
   - POST to /api/projections/calculate with overrides
   - Loading indicator appears

4. **Backend Processes**:
   - Validates overrides
   - Runs projection calculation
   - Auto-saves if planId provided

5. **Response Updates UI**:
   - setProjection updates state
   - Chart and metrics re-render
   - Warnings displayed if any

### 7. User Confirmation Patterns in Codebase

The codebase uses several confirmation patterns that could inform Epic 5's confirmation flow:

#### Pattern 1: Dialog with Form Editing and Save/Cancel
**Location**: [src/app/profile/profile-client.tsx:528-653](src/app/profile/profile-client.tsx#L528-L653)

```tsx
<Dialog open={editSection === 'basics'} onOpenChange={handleEditClose}>
  <DialogContent className="max-w-lg">
    <DialogHeader>
      <DialogTitle>Edit Basic Information</DialogTitle>
    </DialogHeader>
    <Step1PersonalInfo
      onNext={(data) => handleEditSave(data)}
      initialData={formData}
      submitLabel="Save"
      onChange={handleFormChange}
    />
  </DialogContent>
</Dialog>
```

**Key aspects**:
- Controlled dialog with open state
- Form with onNext callback for save
- Custom button labels
- Tracks changes via onChange
- Intercepts close to check for unsaved changes

#### Pattern 2: AI Preview with Confirmation
**Location**: [src/components/onboarding/smart-intake.tsx:152-256](src/components/onboarding/smart-intake.tsx#L152-L256)

```tsx
{parsedData && (
  <div className="space-y-3 p-4 bg-muted rounded-lg">
    <h4 className="font-medium">Detected Information:</h4>
    <ul className="space-y-2">
      {parsedData.fields.map((field) => (
        <li key={field.key} className="flex items-center justify-between">
          <span className="flex items-center gap-2">
            <Check className="h-4 w-4 text-green-600" />
            <span className="font-medium">{field.label}:</span>
            <span>{field.value}</span>
          </span>
          <span className={getConfidenceColor(field.confidence)}>
            {Math.round(field.confidence * 100)}% confident
          </span>
        </li>
      ))}
    </ul>
  </div>
)}

<div className="flex gap-3">
  <Button variant="ghost" onClick={onSkip}>
    Skip & Enter Manually
  </Button>
  {!parsedData ? (
    <Button onClick={handleParse} disabled={isLoading || !text.trim()}>
      {isLoading ? <><Loader2 className="animate-spin" /> Analyzing...</> : <><Sparkles /> Analyze</>}
    </Button>
  ) : (
    <Button onClick={handleApply}>Apply & Continue</Button>
  )}
</div>
```

**Key aspects**:
- Two-step process: Analyze then Apply
- Shows preview with confidence scores
- Explicit "Apply & Continue" confirmation required
- Alternative "Skip" option
- Color-coded confidence indicators

**This pattern is most relevant for Epic 5**: AI parses scenario → shows preview → user confirms → projection runs.

#### Pattern 3: Review and Confirmation Flow
**Location**: [src/components/onboarding/step5-review.tsx:1-379](src/components/onboarding/step5-review.tsx#L1-L379)

Review page with collapsible sections, each with an "Edit" button that opens a dialog. Final "Generate My Plan" button requires confirmation via review. Back button available for navigation.

#### Pattern 4: Toast Notifications for Feedback
**Location**: [src/app/profile/profile-client.tsx:125-135](src/app/profile/profile-client.tsx#L125-L135)

Success and error feedback after save operations:
```typescript
toast({
  title: 'Profile updated',
  description: 'Your financial information has been saved.',
});

// Error case
toast({
  title: 'Update failed',
  description: error.message,
  variant: 'destructive',
});
```

### 8. Extending for Named Scenarios

The current architecture already supports most requirements for named scenarios:

#### Required Schema Changes

**Extend projection_results table**:
```typescript
export const projectionResults = pgTable('projection_results', {
  // ... existing fields ...
  scenarioName: text('scenario_name').default('base'),
  scenarioDescription: text('scenario_description'),
  baseScenarioId: uuid('base_scenario_id').references(() => projectionResults.id),

  // Change unique constraint from planId to composite:
  // unique: ['planId', 'scenarioName']
});
```

#### Structured Diff Implementation

The `ProjectionInput` structure is flat and diffable:

**Numeric Fields**: Direct subtraction
- expectedReturn, inflationRate, annualContribution, etc.

**BalanceByType**: Per-category diff
```typescript
{
  field: 'balancesByType.taxDeferred',
  baseValue: 100000,
  scenarioValue: 120000,
  percentChange: 20
}
```

**Income Streams**: Array comparison by ID
- Detect additions, removals, and changes

**ProjectionResult Diff**: Compare year-by-year records and summary metrics
- Balance differences over time
- Depletion age changes
- Retirement balance impact

#### API Extension Points

**Current**: `POST /api/projections/calculate` with overrides
**Extended**: Add `scenarioName` to request body

**New Endpoints**:
- `GET /api/projections/[planId]/scenarios` - List all scenarios
- `GET /api/projections/[planId]/scenarios/[name]` - Get specific scenario
- `GET /api/projections/[planId]/scenarios/[name]/diff` - Compare to base
- `DELETE /api/projections/[planId]/scenarios/[name]` - Delete scenario

#### No Core Logic Changes Needed

The override mechanism (`ProjectionOverrides`) already supports:
- Economic assumptions (return, inflation)
- Life planning (retirement age, max age)
- Income modeling (income streams)
- Cost planning (healthcare)
- Savings strategy (contribution allocation, growth)

The calculation engine is stateless and accepts any valid `ProjectionInput`, making it scenario-agnostic.

## Code References

### Core Engine & Types
- [src/lib/projections/engine.ts:117-240](src/lib/projections/engine.ts#L117-L240) - Main projection calculation loop
- [src/lib/projections/types.ts:57-90](src/lib/projections/types.ts#L57-L90) - ProjectionInput definition
- [src/lib/projections/types.ts:173-180](src/lib/projections/types.ts#L173-L180) - ProjectionAssumptions definition
- [src/lib/projections/input-builder.ts:20-30](src/lib/projections/input-builder.ts#L20-L30) - ProjectionOverrides definition
- [src/lib/projections/input-builder.ts:32-101](src/lib/projections/input-builder.ts#L32-L101) - buildProjectionInputFromSnapshot function
- [src/lib/projections/assumptions.ts](src/lib/projections/assumptions.ts) - Default assumptions and estimation functions

### API & Database
- [src/app/api/projections/calculate/route.ts:102-271](src/app/api/projections/calculate/route.ts#L102-L271) - calculateProjection orchestration
- [src/app/api/projections/calculate/route.ts:302-335](src/app/api/projections/calculate/route.ts#L302-L335) - POST handler with overrides
- [src/db/schema/projection-results.ts:11-37](src/db/schema/projection-results.ts#L11-L37) - Database schema
- [src/db/secure-query.ts:86-117](src/db/secure-query.ts#L86-L117) - saveProjectionResult function

### UI Components
- [src/app/plans/plans-client.tsx:27-349](src/app/plans/plans-client.tsx#L27-L349) - Main orchestration component
- [src/app/plans/plans-client.tsx:44-110](src/app/plans/plans-client.tsx#L44-L110) - Debounced recalculation logic
- [src/components/projections/AssumptionsPanel.tsx:25-270](src/components/projections/AssumptionsPanel.tsx#L25-L270) - Assumption input controls
- [src/components/projections/ProjectionChart.tsx](src/components/projections/ProjectionChart.tsx) - Chart visualization
- [src/components/projections/ProjectionTable.tsx](src/components/projections/ProjectionTable.tsx) - Table display

### Validation & Warnings
- [src/lib/validation/projections.ts:33-105](src/lib/validation/projections.ts#L33-L105) - Zod schemas for overrides
- [src/lib/projections/warnings.ts:12-66](src/lib/projections/warnings.ts#L12-L66) - Warning generation
- [src/app/api/projections/calculate/route.ts:32-52](src/app/api/projections/calculate/route.ts#L32-L52) - Age relationship validation

### Confirmation Patterns
- [src/app/profile/profile-client.tsx:528-653](src/app/profile/profile-client.tsx#L528-L653) - Dialog confirmation pattern
- [src/components/onboarding/smart-intake.tsx:152-256](src/components/onboarding/smart-intake.tsx#L152-L256) - AI preview with confirmation (MOST RELEVANT FOR EPIC 5)
- [src/components/onboarding/step5-review.tsx:1-379](src/components/onboarding/step5-review.tsx#L1-L379) - Review and confirmation flow
- [src/components/ui/dialog.tsx](src/components/ui/dialog.tsx) - Dialog component primitives
- [src/components/ui/button.tsx](src/components/ui/button.tsx) - Button variants and states

## Architecture Insights

### Clean Separation of Concerns

The system maintains a clear boundary between:
- **Facts** (financial_snapshot): Actual financial data, never modified by assumptions
- **Knobs** (ProjectionOverrides): Hypothetical parameters, user-adjustable
- **Math** (runProjection): Pure calculation function, stateless
- **Results** (ProjectionResult): Output with year-by-year records and summary

This separation enables safe "what-if" exploration without data corruption.

### Stateless Calculation Engine

The projection engine (`runProjection`) is a pure function:
- Input: `ProjectionInput` object
- Output: `ProjectionResult` object
- No side effects, no database access, no external state

This design makes it trivial to run multiple scenarios—just call the function with different inputs.

### Override Mechanism as Foundation

The existing `ProjectionOverrides` structure provides all the building blocks for scenario modeling:
- Contains all scenario-variable parameters
- Used in API already (POST /api/projections/calculate)
- Validated via Zod schemas
- Applied via nullish coalescing for clean defaults

**To extend for named scenarios**: Add schema field for scenarioName and change unique constraint to composite key. No changes to core calculation logic needed.

### One-to-One Constraint

The current `projection_results.planId` unique constraint enforces one projection per plan. This prevents scenario proliferation but limits "what-if" exploration.

**For Epic 5**: Either:
1. Keep one-to-one and use transient scenarios (not persisted)
2. Change to composite key `[planId, scenarioName]` for named scenarios

Story 5.1 specifies "parsed scenario stored as structured diff", suggesting option 2.

### Tax-Aware Withdrawal Strategy

The withdrawal waterfall (taxable → tax-deferred → tax-free) optimizes for tax efficiency. Different scenarios might use different strategies (e.g., "aggressive tax harvesting" vs "preserve Roth growth").

**For Epic 5**: Consider allowing withdrawal strategy as a scenario parameter.

### Debounced Auto-Save

The UI uses 300ms debounce with automatic persistence. This creates smooth UX but means every adjustment saves to database.

**For Epic 5**: Consider whether conversational scenarios should auto-save or require explicit user action. Story 5.1 specifies "no projection runs without user confirmation", suggesting explicit save.

## Historical Context (from thoughts/)

### Epic 3 - Projection Engine Foundation
- [thoughts/personal/tickets/epic-3/projection-modeling/story-1-scope.md](thoughts/personal/tickets/epic-3/projection-modeling/story-1-scope.md) - Run Core Retirement Projection
- [thoughts/personal/tickets/epic-3/projection-modeling/story-3-scope.md](thoughts/personal/tickets/epic-3/projection-modeling/story-3-scope.md) - Adjust Assumptions (KEY FOR WHAT-IF)
- [thoughts/shared/plans/2025-12-18-epic-3-story-1-projection-engine.md](thoughts/shared/plans/2025-12-18-epic-3-story-1-projection-engine.md) - Initial projection engine implementation
- [thoughts/shared/plans/2025-12-26-story-2.4-adjust-assumptions.md](thoughts/shared/plans/2025-12-26-story-2.4-adjust-assumptions.md) - Adjust Assumptions implementation plan

The "Adjust Assumptions" feature (Story 3.3/2.4) implemented the core override mechanism:
- Allows users to modify assumptions (return, inflation, retirement age)
- Keeps assumptions separate from financial data
- Instantly re-runs projections with modified assumptions
- Provides foundation for "what-if" scenarios

### Epic 4 - AI Integration
- [thoughts/personal/tickets/epic-4/story-1-scope.md](thoughts/personal/tickets/epic-4/story-1-scope.md) - AI Retirement Storytelling scope
- [thoughts/shared/plans/2025-12-30-epic-4-story-1-ai-plan-summary.md](thoughts/shared/plans/2025-12-30-epic-4-story-1-ai-plan-summary.md) - AI plan summary implementation

AI integration depends on projection deltas from assumption changes, directly related to what-if scenarios.

### Epic 5 - Conversational What-If Engine (Planned)
- [thoughts/personal/tickets/epic-5/story-1-scope.md](thoughts/personal/tickets/epic-5/story-1-scope.md) - Natural Language Scenario Parsing with Confirmation (THIS RESEARCH SUPPORTS THIS STORY)

Key requirements:
- AI parses intent from plain English "what if" questions
- System confirms parameters before running projection
- No projection runs without user confirmation
- Parsed scenario stored as structured diff
- Built-in guardrails to prevent base plan corruption

### Future Features Mentioned
- [thoughts/shared/research/2025-12-29-story-3.5-persist-projection-results.md:773-779](thoughts/shared/research/2025-12-29-story-3.5-persist-projection-results.md#L773-L779) - Named scenarios feature mentioned but not implemented

## Related Research

- [thoughts/shared/research/2025-12-25-story-2.4-adjust-assumptions-research.md](thoughts/shared/research/2025-12-25-story-2.4-adjust-assumptions-research.md) - Research on adjusting assumptions (KEY FOR WHAT-IF)
- [thoughts/shared/research/2025-12-29-story-3.5-persist-projection-results.md](thoughts/shared/research/2025-12-29-story-3.5-persist-projection-results.md) - Persistence research mentioning future scenarios
- [thoughts/shared/research/2025-12-17-epic-3-projection-engine-implementation-readiness.md](thoughts/shared/research/2025-12-17-epic-3-projection-engine-implementation-readiness.md) - Initial projection engine readiness assessment

## Implications for Epic 5 Story 5.1

### What Already Works

1. **Override Mechanism**: `ProjectionOverrides` contains all scenario parameters
2. **Stateless Engine**: Can run multiple scenarios without side effects
3. **Validation**: Zod schemas validate all override parameters
4. **Safe by Design**: Financial snapshot never modified, only projections
5. **UI Patterns**: AI preview with confirmation already exists in codebase

### What Needs to Be Added

1. **NL Parsing**: Parse plain English "what if" questions into `ProjectionOverrides`
2. **Confirmation Flow**: Use AI preview pattern to show parsed parameters
3. **Scenario Storage**: Extend schema to support named scenarios with composite key
4. **Diff Calculation**: Compare scenario results to base projection
5. **Conversational UI**: Interface for asking questions and reviewing proposals

### Recommended Implementation Approach

1. **Phase 1 - NL Parsing**:
   - Create `/api/scenarios/parse` endpoint
   - Use AI to extract intent from natural language
   - Map to `ProjectionOverrides` structure
   - Return parsed parameters with confidence scores

2. **Phase 2 - Confirmation Flow**:
   - Reuse AI preview pattern from smart-intake
   - Show parsed parameters in human-readable format
   - Display confidence scores
   - Provide "Apply & Run" and "Edit Manually" options

3. **Phase 3 - Scenario Execution**:
   - On confirm: Call existing `/api/projections/calculate` with overrides
   - Display results alongside base projection
   - Show diff: highlight changes in key metrics

4. **Phase 4 - Scenario Persistence** (Optional):
   - Extend schema with scenarioName and composite key
   - Add scenario management endpoints
   - Store structured diff alongside results

### Key Design Decisions

**Question 1**: Should conversational scenarios auto-save or require explicit user action?
- Story 5.1 specifies "no projection runs without user confirmation"
- Suggests explicit save rather than auto-save
- Could offer "Save as Named Scenario" after viewing results

**Question 2**: Should scenarios be transient or persisted?
- Story 5.1 says "parsed scenario stored as structured diff"
- Suggests persistence
- But could mean "stored in memory during session" vs "stored in database"

**Question 3**: How to handle multiple consecutive what-if questions?
- Should each question create a new scenario?
- Or allow user to build up a single scenario iteratively?
- Conversational UX suggests iterative refinement

**Question 4**: Should scenarios compare to base or to each other?
- Base comparison: "What if I retire at 65?" vs current plan
- Scenario comparison: "What if I retire at 65 vs 67?"
- Both have value, start with base comparison

## Open Questions

1. **Scenario Naming**: How should AI-generated scenarios be named?
   - Auto-generate from parameters? ("Retire at 65 with 8% returns")
   - Ask user to name? (Additional friction)
   - Use timestamp? ("Scenario created Jan 13, 2026")

2. **Scenario Limits**: How many scenarios per plan?
   - Unlimited? (Database growth concern)
   - Fixed limit (e.g., 5)? (UX constraint)
   - Time-based expiration? (Transient scenarios)

3. **Confidence Thresholds**: When should AI refuse to parse?
   - Low confidence on key parameters?
   - Ambiguous questions?
   - Missing information?

4. **Parameter Conflicts**: What if parsed parameters are mutually incompatible?
   - Example: "Retire at 65 but contribute for 20 more years" (if currently age 50)
   - Validation should catch this, but how to communicate to user?

5. **Conversational Context**: How to maintain context across questions?
   - Session-based memory?
   - Explicit scenario branching?
   - Reference previous scenarios by name?

6. **Diff Visualization**: How to display scenario diffs effectively?
   - Side-by-side charts?
   - Overlay on single chart?
   - Delta metrics table?
   - AI-generated narrative explaining differences?
