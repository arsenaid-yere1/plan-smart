---
date: 2026-01-14T12:00:00-08:00
researcher: Claude
git_commit: 8eea59f6cd7a510a1070a66c8c3148fe2e61c28f
branch: main
repository: plan-smart
topic: "Delta-Based Explanation Implementation for What-If Scenarios"
tags: [research, codebase, scenarios, ai, projections, deltas]
status: complete
last_updated: 2026-01-14
last_updated_by: Claude
---

# Research: Delta-Based Explanation Implementation for What-If Scenarios

**Date**: 2026-01-14T12:00:00-08:00
**Researcher**: Claude
**Git Commit**: 8eea59f6cd7a510a1070a66c8c3148fe2e61c28f
**Branch**: main
**Repository**: plan-smart

## Research Question

How can we add Story 5.2 (Delta-Based Explanation) to the existing scenario implementation? The goal is to have AI explain what changed and why, computing deltas rather than rewriting the full plan.

## Summary

The existing codebase has strong foundations for implementing delta-based explanations:

1. **Staleness utility** ([staleness.ts](src/lib/projections/staleness.ts)) already computes field-level deltas between projection inputs
2. **Scenario parsing** ([scenario-parse.ts](src/lib/ai/prompts/scenario-parse.ts)) extracts overrides that can be compared to base assumptions
3. **AI summary pattern** ([plan-summary/route.ts](src/app/api/ai/plan-summary/route.ts)) provides a template for generating narrative explanations
4. **Plans client** ([plans-client.tsx](src/app/plans/plans-client.tsx)) manages both base and scenario projections

The implementation requires:
- A new AI prompt for delta explanations
- A new API endpoint that receives base + scenario projections
- A UI component to display the explanation
- Leveraging the existing `checkProjectionStaleness()` function for delta computation

## Detailed Findings

### 1. Current Scenario Flow

The scenario system currently works as follows:

1. User enters natural language query in `ScenarioInput` component
2. Query is parsed via `/api/scenarios/parse` using OpenAI
3. `ScenarioConfirmation` dialog shows parsed fields with confidence scores
4. User confirms, and overrides are applied to assumptions
5. `PlansClient` triggers recalculation with new assumptions
6. New projection is displayed (replaces the view)

**Gap**: After applying a scenario, there's no explanation of *what changed* or *why the numbers differ*.

### 2. Existing Delta Infrastructure

The codebase already has delta computation in [staleness.ts:13-80](src/lib/projections/staleness.ts#L13-L80):

```typescript
export interface StalenessResult {
  isStale: boolean;
  changedFields: string[];
  changes: Record<string, { previous: unknown; current: unknown }>;
}

export function checkProjectionStaleness(
  storedInputs: ProjectionInput,
  currentInputs: ProjectionInput
): StalenessResult
```

This function:
- Compares 12 primitive fields (currentAge, retirementAge, maxAge, expectedReturn, etc.)
- Deep-compares complex objects (balancesByType, incomeStreams)
- Returns structured delta with `{ previous, current }` values

**This can be repurposed for scenario comparison.**

### 3. AI Prompt Patterns

The existing plan summary prompt ([plan-summary.ts](src/lib/ai/prompts/plan-summary.ts)) demonstrates the pattern:
- System prompt with tone instructions and banned phrases
- JSON response format for structured output
- Validation against banned phrases
- Retry logic for compliance

**For Story 5.2**, a new prompt should:
- Receive base projection summary + scenario projection summary + deltas
- Output comparison narrative with quantified changes
- Use phrases like "Compared to your base plan..."
- Never suggest rewriting the base plan

### 4. Data Flow for Delta Explanation

Currently, `PlansClient` holds:
- `initialProjection`: The saved base projection
- `projection`: Current (potentially modified) projection
- `assumptions`: Current assumptions (may include scenario overrides)
- `currentAssumptions`: Original saved assumptions

This means **both base and scenario data are available** in the client for comparison.

### 5. Implementation Architecture

#### Option A: Client-Side Comparison (Recommended)

Store base projection when scenario is applied, then pass both to a new API:

```
User applies scenario
  → Save base projection in state
  → Calculate scenario projection
  → Call /api/scenarios/explain with { base, scenario }
  → Display delta explanation
```

**Pros**: Simple state management, follows existing patterns
**Cons**: Requires holding two projections in state

#### Option B: Server-Side Comparison

Pass scenario overrides to a new endpoint that calculates both projections:

```
User confirms scenario
  → Call /api/scenarios/explain with { planId, overrides }
  → Server calculates base + scenario projections
  → Server generates delta explanation
  → Return explanation to client
```

**Pros**: Single API call, cleaner client
**Cons**: Duplicates projection calculation logic

## Code References

### Scenario Components
- [src/components/scenarios/ScenarioInput.tsx](src/components/scenarios/ScenarioInput.tsx) - Input component for natural language queries
- [src/components/scenarios/ScenarioConfirmation.tsx](src/components/scenarios/ScenarioConfirmation.tsx) - Confirmation dialog with field editing

### Scenario Types
- [src/lib/scenarios/types.ts](src/lib/scenarios/types.ts) - `ParsedScenario`, `ParsedScenarioField`, `ScenarioParseResponse`

### AI Infrastructure
- [src/app/api/ai/plan-summary/route.ts](src/app/api/ai/plan-summary/route.ts) - Pattern for AI generation with retry/validation
- [src/lib/ai/prompts/scenario-parse.ts](src/lib/ai/prompts/scenario-parse.ts) - Scenario parsing prompt
- [src/lib/ai/validate-response.ts](src/lib/ai/validate-response.ts) - Banned phrase validation

### Projection System
- [src/lib/projections/staleness.ts](src/lib/projections/staleness.ts) - Delta computation utility
- [src/lib/projections/types.ts](src/lib/projections/types.ts) - `ProjectionInput`, `ProjectionSummary`, `ProjectionResult`
- [src/lib/projections/input-builder.ts](src/lib/projections/input-builder.ts) - `ProjectionOverrides` interface

### Integration Point
- [src/app/plans/plans-client.tsx](src/app/plans/plans-client.tsx) - Main plans page with scenario integration

## Architecture Insights

### Pattern: Scenario as Temporary Override

The current design treats scenarios as **temporary overlays**, not persisted entities:
- Scenarios modify `assumptions` state in `PlansClient`
- No separate database table for scenarios
- Reset to base by calling `handleReset()`

**For Story 5.2**, this means delta explanations should also be ephemeral, displayed alongside the scenario projection but not persisted.

### Pattern: AI Response Validation

All AI-generated content goes through:
1. JSON parsing with structure validation
2. Banned phrase checking via `validateSummaryResponse()`
3. Retry logic (up to 2 retries)

The delta explanation should follow this same pattern with scenario-specific banned phrases (e.g., "you should change your plan", "rewrite your goals").

### Pattern: Dual Projection Display

The UI should show:
- Base plan metrics (reference point)
- Scenario plan metrics (what-if result)
- Delta explanation (AI narrative)

Consider a side-by-side or overlay approach in the UI.

## Recommended Implementation Steps

### Step 1: Create Delta Explanation Prompt

Create `src/lib/ai/prompts/scenario-explain.ts`:

```typescript
export const SCENARIO_EXPLAIN_PROMPT = `You are explaining retirement projection changes.
Compare the scenario to the base plan and explain what changed and why.

Rules:
- Start with "Compared to your base plan..."
- Use quantified deltas ("+$50K", "-3 years", etc.)
- Explain cause-and-effect relationships
- Never suggest modifying the base plan
- Keep explanation under 150 words`;
```

### Step 2: Create Explain API Endpoint

Create `src/app/api/scenarios/explain/route.ts`:

```typescript
// Receives: baseProjection, scenarioProjection, overridesApplied
// Computes deltas using checkProjectionStaleness()
// Generates explanation via OpenAI
// Returns: { explanation: string, deltas: DeltaSummary }
```

### Step 3: Add UI Component

Create `src/components/scenarios/ScenarioExplanation.tsx`:

```typescript
// Displays AI explanation
// Shows key deltas (retirement balance, years until depletion)
// Option to dismiss or apply changes permanently
```

### Step 4: Integrate into PlansClient

Modify `src/app/plans/plans-client.tsx`:

```typescript
// Add state: baseProjection, isScenarioActive, scenarioExplanation
// When scenario applied: save base, fetch explanation
// Display explanation below scenario results
// Reset clears scenario state
```

### Step 5: Create Delta Summary Type

Add to `src/lib/scenarios/types.ts`:

```typescript
export interface DeltaSummary {
  retirementBalanceChange: number;
  yearsUntilDepletionChange: number | null;
  fieldsChanged: string[];
  explanation: string;
}
```

## Historical Context (from thoughts/)

- [thoughts/shared/research/2026-01-13-ENG-5.1-scenario-projection-system.md](thoughts/shared/research/2026-01-13-ENG-5.1-scenario-projection-system.md) - Story 5.1 research covering scenario parsing infrastructure
- [thoughts/shared/plans/2026-01-13-ENG-5.1-scenario-parsing-confirmation.md](thoughts/shared/plans/2026-01-13-ENG-5.1-scenario-parsing-confirmation.md) - Implementation plan for scenario confirmation flow
- [thoughts/personal/tickets/epic-5/story-1-scope.md](thoughts/personal/tickets/epic-5/story-1-scope.md) - Story 5.1 scope (natural language parsing)
- [thoughts/personal/tickets/epic-5/story-2-scope.md](thoughts/personal/tickets/epic-5/story-2-scope.md) - Story 5.2 scope (delta-based explanation)

## Open Questions

1. **Persistence**: Should delta explanations be cached like plan summaries, or always generated fresh?
   - Recommendation: Generate fresh since scenarios are ephemeral

2. **Side-by-side UI**: Should the base plan metrics remain visible alongside scenario, or use a toggle?
   - Recommendation: Keep base visible for easy comparison

3. **Multiple scenarios**: Should users be able to stack scenarios, or only one at a time?
   - Current design: One scenario at a time (reset to base before new scenario)

4. **Explanation trigger**: Generate explanation automatically or on user request?
   - Recommendation: Automatic after scenario confirmation for seamless UX
