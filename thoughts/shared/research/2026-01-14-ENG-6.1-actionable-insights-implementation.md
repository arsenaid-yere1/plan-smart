---
date: 2026-01-14T10:30:00-08:00
researcher: Claude
git_commit: e2de735b3b957dea64c99e1a8216931cc327a7c3
branch: main
repository: plan-smart
topic: "Epic 6 Story 1 - Actionable Insights Implementation Recommendations"
tags: [research, codebase, epic-6, actionable-insights, sensitivity-analysis, ai-integration]
status: complete
last_updated: 2026-01-14
last_updated_by: Claude
---

# Research: Epic 6 Story 1 - Actionable Insights Implementation Recommendations

**Date**: 2026-01-14T10:30:00-08:00
**Researcher**: Claude
**Git Commit**: e2de735b3b957dea64c99e1a8216931cc327a7c3
**Branch**: main
**Repository**: plan-smart

## Research Question

Provide recommended implementation for Epic 6 Story 1 - Actionable Insights, which includes:
- 6.1: Top 3 Levers (Quantified & Bounded)
- 6.2: Low-Friction Wins Identification
- 6.3: Assumption Sensitivity Explanation

## Summary

The implementation should leverage existing infrastructure:
1. **Projection engine** for computing lever impacts via parameter sensitivity
2. **Scenario/delta patterns** for comparing base vs. modified projections
3. **AI integration patterns** from Epic 4/5 for generating explanations
4. **UI component patterns** (cards, badges, charts) for displaying insights

Key architectural principle: **Computation happens algorithmically; AI only narrates results.** This ensures insights are reproducible, auditable, and don't cross into advice territory.

---

## Detailed Implementation Recommendations

### Feature 6.1: Top 3 Levers (Quantified & Bounded)

#### Concept
Automatically identify which input parameters have the largest impact on retirement outcomes, then have AI explain (not select) the results.

#### Implementation Approach

**Phase 1: Create Sensitivity Analysis Engine**

Create `/src/lib/projections/sensitivity.ts`:

```typescript
export interface LeverImpact {
  lever: string;                    // e.g., "expectedReturn", "retirementAge"
  displayName: string;              // e.g., "Expected Return", "Retirement Age"
  currentValue: number;
  testDelta: number;                // Amount we varied it by
  testDirection: 'increase' | 'decrease';
  impactOnBalance: number;          // $ change in retirement balance
  impactOnDepletion: number | null; // Years change in depletion (null if N/A)
  percentImpact: number;            // % change in outcome
}

export interface SensitivityResult {
  topLevers: LeverImpact[];         // Max 3, sorted by impact
  baselineBalance: number;
  baselineDepletion: number | null;
  analysisTimestamp: Date;
}

export async function analyzeSensitivity(
  baseInput: ProjectionInput
): Promise<SensitivityResult> {
  // 1. Run base projection
  const baseResult = runProjection(baseInput);

  // 2. Define test deltas for each lever
  const leverTests: Array<{
    lever: keyof ProjectionInput;
    displayName: string;
    delta: number;
    direction: 'increase' | 'decrease';
  }> = [
    { lever: 'expectedReturn', displayName: 'Expected Return', delta: 0.01, direction: 'increase' },
    { lever: 'inflationRate', displayName: 'Inflation Rate', delta: 0.005, direction: 'decrease' },
    { lever: 'retirementAge', displayName: 'Retirement Age', delta: 1, direction: 'increase' },
    { lever: 'annualContribution', displayName: 'Annual Savings', delta: baseInput.annualContribution * 0.1, direction: 'increase' },
    { lever: 'annualExpenses', displayName: 'Annual Expenses', delta: baseInput.annualExpenses * 0.1, direction: 'decrease' },
    { lever: 'annualHealthcareCosts', displayName: 'Healthcare Costs', delta: 1000, direction: 'decrease' },
  ];

  // 3. Run projection for each lever variation
  const impacts: LeverImpact[] = [];

  for (const test of leverTests) {
    const modifiedInput = { ...baseInput };
    modifiedInput[test.lever] = test.direction === 'increase'
      ? baseInput[test.lever] + test.delta
      : baseInput[test.lever] - test.delta;

    const modifiedResult = runProjection(modifiedInput);

    const impactOnBalance = modifiedResult.summary.projectedRetirementBalance
      - baseResult.summary.projectedRetirementBalance;

    const impactOnDepletion = calculateDepletionDelta(
      baseResult.summary.yearsUntilDepletion,
      modifiedResult.summary.yearsUntilDepletion
    );

    impacts.push({
      lever: test.lever,
      displayName: test.displayName,
      currentValue: baseInput[test.lever],
      testDelta: test.delta,
      testDirection: test.direction,
      impactOnBalance,
      impactOnDepletion,
      percentImpact: Math.abs(impactOnBalance / baseResult.summary.projectedRetirementBalance) * 100,
    });
  }

  // 4. Sort by absolute impact and take top 3
  const topLevers = impacts
    .sort((a, b) => Math.abs(b.impactOnBalance) - Math.abs(a.impactOnBalance))
    .slice(0, 3);

  return {
    topLevers,
    baselineBalance: baseResult.summary.projectedRetirementBalance,
    baselineDepletion: baseResult.summary.yearsUntilDepletion,
    analysisTimestamp: new Date(),
  };
}
```

**Phase 2: Create API Endpoint**

Create `/src/app/api/insights/levers/route.ts`:

```typescript
export async function POST(request: Request) {
  const user = await getServerUser();
  if (!user) return unauthorized();

  // 1. Get financial snapshot
  const snapshot = await getFinancialSnapshot(user.id);

  // 2. Build projection input
  const input = buildProjectionInputFromSnapshot(snapshot);

  // 3. Run sensitivity analysis (algorithmic)
  const sensitivityResult = await analyzeSensitivity(input);

  // 4. Generate AI explanation (narration only)
  const explanation = await generateLeverExplanation(sensitivityResult);

  return NextResponse.json({
    levers: sensitivityResult.topLevers,
    explanation,
    baseline: {
      balance: sensitivityResult.baselineBalance,
      depletion: sensitivityResult.baselineDepletion,
    },
  });
}
```

**Phase 3: Create AI Explanation Prompt**

Create `/src/lib/ai/prompts/lever-explanation.ts`:

```typescript
export const LEVER_EXPLANATION_SYSTEM_PROMPT = `You explain retirement projection sensitivity analysis results.

CRITICAL RULES:
1. NEVER use prescriptive language ("you should", "you need to", "consider")
2. Use ONLY observational language ("has the biggest effect", "shows the largest impact")
3. Include quantified impacts from the data provided
4. Keep explanations factual and bounded to the analysis

FORMAT:
- Lead with the #1 lever and its quantified impact
- Briefly mention the other top factors
- End with a general observation about sensitivity

EXAMPLE:
"Expected return has the biggest effect on your projected retirement balance. A 1% higher return would add approximately $127,000 to your retirement funds. Your retirement age and annual savings also show meaningful impact on long-term outcomes."

BANNED PHRASES:
- "you should"
- "you need to"
- "consider"
- "I recommend"
- "focus on"
- "prioritize"
`;

export function buildLeverUserMessage(result: SensitivityResult): string {
  const leverDescriptions = result.topLevers.map((lever, index) =>
    `${index + 1}. ${lever.displayName}: ${lever.testDirection === 'increase' ? '+' : '-'}${formatDelta(lever.testDelta)} → ${formatCurrency(lever.impactOnBalance)} impact on retirement balance`
  ).join('\n');

  return `TOP 3 LEVERS BY IMPACT:
${leverDescriptions}

BASELINE:
- Retirement Balance: ${formatCurrency(result.baselineBalance)}
- Fund Depletion: ${result.baselineDepletion ? `${result.baselineDepletion} years after retirement` : 'Never (sustainable)'}

Generate a 2-3 sentence explanation of these findings using observational language only.`;
}
```

**Phase 4: Create UI Component**

Create `/src/components/insights/TopLeversCard.tsx`:

```typescript
interface TopLeversCardProps {
  levers: LeverImpact[];
  explanation: string;
  isLoading?: boolean;
}

export function TopLeversCard({ levers, explanation, isLoading }: TopLeversCardProps) {
  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <TrendingUp className="h-5 w-5 animate-pulse" />
            Analyzing Key Factors...
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <Skeleton className="h-20 w-full" />
          <Skeleton className="h-16 w-full" />
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2 text-lg">
          <TrendingUp className="h-5 w-5 text-primary" />
          What Matters Most
        </CardTitle>
        <CardDescription>
          Factors with the biggest effect on your retirement projection
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* AI Explanation */}
        <p className="text-sm leading-relaxed">{explanation}</p>

        {/* Lever Cards */}
        <div className="space-y-3">
          {levers.map((lever, index) => (
            <LeverItem key={lever.lever} lever={lever} rank={index + 1} />
          ))}
        </div>

        {/* Disclaimer */}
        <p className="text-xs text-muted-foreground italic pt-2 border-t">
          Impact calculated by varying each factor individually. Actual results depend on multiple factors working together.
        </p>
      </CardContent>
    </Card>
  );
}

function LeverItem({ lever, rank }: { lever: LeverImpact; rank: number }) {
  const isPositive = lever.impactOnBalance > 0;

  return (
    <div className="flex items-center justify-between p-3 rounded-lg bg-muted/50">
      <div className="flex items-center gap-3">
        <span className={cn(
          "w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold",
          rank === 1 && "bg-primary text-primary-foreground",
          rank === 2 && "bg-secondary text-secondary-foreground",
          rank === 3 && "bg-muted-foreground/20 text-muted-foreground"
        )}>
          {rank}
        </span>
        <div>
          <p className="font-medium text-sm">{lever.displayName}</p>
          <p className="text-xs text-muted-foreground">
            {lever.testDirection === 'increase' ? '+' : '-'}{formatDeltaValue(lever.lever, lever.testDelta)}
          </p>
        </div>
      </div>
      <div className={cn(
        "text-right",
        isPositive ? "text-success" : "text-destructive"
      )}>
        <p className="font-semibold text-sm">
          {isPositive ? '+' : ''}{formatCurrency(lever.impactOnBalance)}
        </p>
        <p className="text-xs text-muted-foreground">
          {lever.percentImpact.toFixed(1)}% impact
        </p>
      </div>
    </div>
  );
}
```

---

### Feature 6.2: Low-Friction Wins Identification

#### Concept
Surface small changes (below defined thresholds) that produce outsized effects, without suggesting products or investments.

#### Implementation Approach

**Phase 1: Define Thresholds and Win Detection**

Add to `/src/lib/projections/sensitivity.ts`:

```typescript
export interface LowFrictionWin {
  id: string;
  title: string;
  description: string;
  effortLevel: 'minimal' | 'low' | 'moderate';
  potentialImpact: number;           // $ impact
  impactDescription: string;         // Plain language
  uncertaintyCaveat: string;
  lever: string;
  delta: number;
}

// Thresholds for "low friction"
const LOW_FRICTION_THRESHOLDS = {
  retirementAge: 1,                  // 1 year delay
  annualExpenses: 0.05,              // 5% reduction
  annualContribution: 0.10,          // 10% increase
  annualHealthcareCosts: 1000,       // $1000 reduction
};

export function identifyLowFrictionWins(
  baseInput: ProjectionInput,
  sensitivityResult: SensitivityResult
): LowFrictionWin[] {
  const wins: LowFrictionWin[] = [];
  const baseResult = runProjection(baseInput);

  // Win 1: Retire 1 year later (if applicable)
  if (baseInput.retirementAge < 70) {
    const laterRetirement = {
      ...baseInput,
      retirementAge: baseInput.retirementAge + 1,
    };
    const result = runProjection(laterRetirement);
    const impact = result.summary.projectedRetirementBalance - baseResult.summary.projectedRetirementBalance;

    if (impact > 10000) { // Only show if meaningful
      wins.push({
        id: 'retire-one-year-later',
        title: 'One additional working year',
        description: `Working until age ${baseInput.retirementAge + 1} instead of ${baseInput.retirementAge}`,
        effortLevel: 'moderate',
        potentialImpact: impact,
        impactDescription: `adds approximately ${formatCurrency(impact)} to retirement funds`,
        uncertaintyCaveat: 'Assumes continued employment and contribution levels',
        lever: 'retirementAge',
        delta: 1,
      });
    }
  }

  // Win 2: Small expense reduction
  const expenseReduction = baseInput.annualExpenses * 0.05;
  const reducedExpenses = {
    ...baseInput,
    annualExpenses: baseInput.annualExpenses - expenseReduction,
  };
  const expenseResult = runProjection(reducedExpenses);
  const expenseImpact = expenseResult.summary.projectedRetirementBalance - baseResult.summary.projectedRetirementBalance;

  if (expenseImpact > 5000) {
    wins.push({
      id: 'reduce-expenses-5pct',
      title: 'Modest expense reduction',
      description: `Reducing annual expenses by ${formatCurrency(expenseReduction)}/year (5%)`,
      effortLevel: 'low',
      potentialImpact: expenseImpact,
      impactDescription: `frees up approximately ${formatCurrency(expenseImpact)} for retirement`,
      uncertaintyCaveat: 'Based on current expense levels; actual savings may vary',
      lever: 'annualExpenses',
      delta: expenseReduction,
    });
  }

  // Win 3: Increase savings rate
  const contributionIncrease = baseInput.annualContribution * 0.10;
  const increasedContribution = {
    ...baseInput,
    annualContribution: baseInput.annualContribution + contributionIncrease,
  };
  const contributionResult = runProjection(increasedContribution);
  const contributionImpact = contributionResult.summary.projectedRetirementBalance - baseResult.summary.projectedRetirementBalance;

  if (contributionImpact > 5000) {
    wins.push({
      id: 'increase-savings-10pct',
      title: 'Incremental savings boost',
      description: `Saving an additional ${formatCurrency(contributionIncrease)}/year (10% increase)`,
      effortLevel: 'low',
      potentialImpact: contributionImpact,
      impactDescription: `grows to approximately ${formatCurrency(contributionImpact)} by retirement`,
      uncertaintyCaveat: 'Assumes consistent contribution over time; market returns may vary',
      lever: 'annualContribution',
      delta: contributionIncrease,
    });
  }

  // Sort by impact and take top 3
  return wins
    .sort((a, b) => b.potentialImpact - a.potentialImpact)
    .slice(0, 3);
}
```

**Phase 2: Create UI Component**

Create `/src/components/insights/LowFrictionWinsCard.tsx`:

```typescript
interface LowFrictionWinsCardProps {
  wins: LowFrictionWin[];
  isLoading?: boolean;
}

export function LowFrictionWinsCard({ wins, isLoading }: LowFrictionWinsCardProps) {
  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Zap className="h-5 w-5 animate-pulse" />
            Finding Quick Wins...
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-32 w-full" />
        </CardContent>
      </Card>
    );
  }

  if (wins.length === 0) {
    return null; // Don't show if no meaningful wins found
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2 text-lg">
          <Zap className="h-5 w-5 text-warning" />
          Small Changes, Big Effects
        </CardTitle>
        <CardDescription>
          Modest adjustments that show meaningful impact in projections
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {wins.map((win) => (
          <WinItem key={win.id} win={win} />
        ))}
      </CardContent>
    </Card>
  );
}

function WinItem({ win }: { win: LowFrictionWin }) {
  return (
    <div className="p-4 rounded-lg border bg-card">
      <div className="flex items-start justify-between gap-4">
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-1">
            <h4 className="font-medium text-sm">{win.title}</h4>
            <EffortBadge level={win.effortLevel} />
          </div>
          <p className="text-sm text-muted-foreground mb-2">
            {win.description}
          </p>
          <p className="text-sm">
            <span className="text-success font-medium">
              {win.impactDescription}
            </span>
          </p>
        </div>
        <div className="text-right">
          <p className="text-lg font-bold text-success">
            +{formatCurrency(win.potentialImpact)}
          </p>
        </div>
      </div>
      <p className="text-xs text-muted-foreground italic mt-3 pt-3 border-t">
        {win.uncertaintyCaveat}
      </p>
    </div>
  );
}

function EffortBadge({ level }: { level: LowFrictionWin['effortLevel'] }) {
  const styles = {
    minimal: 'bg-success/10 text-success',
    low: 'bg-warning/10 text-warning',
    moderate: 'bg-muted text-muted-foreground',
  };

  return (
    <span className={cn(
      'inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium',
      styles[level]
    )}>
      {level} effort
    </span>
  );
}
```

---

### Feature 6.3: Assumption Sensitivity Explanation

#### Concept
Explain which assumptions the projection is most sensitive to, encouraging periodic review rather than immediate action.

#### Implementation Approach

**Phase 1: Identify Sensitive Assumptions**

Add to `/src/lib/projections/sensitivity.ts`:

```typescript
export interface SensitiveAssumption {
  assumption: string;
  displayName: string;
  currentValue: number;
  formattedValue: string;
  sensitivityScore: number;         // 0-100 scale
  explanation: string;
  reviewSuggestion: string;
}

export function identifySensitiveAssumptions(
  input: ProjectionInput,
  sensitivityResult: SensitivityResult
): SensitiveAssumption[] {
  // Map levers to assumptions
  const assumptions: SensitiveAssumption[] = [];

  // Calculate sensitivity scores based on impact magnitude
  const maxImpact = Math.max(...sensitivityResult.topLevers.map(l => Math.abs(l.impactOnBalance)));

  for (const lever of sensitivityResult.topLevers.slice(0, 2)) {
    const sensitivityScore = Math.round((Math.abs(lever.impactOnBalance) / maxImpact) * 100);

    assumptions.push({
      assumption: lever.lever,
      displayName: lever.displayName,
      currentValue: lever.currentValue,
      formattedValue: formatAssumptionValue(lever.lever, lever.currentValue),
      sensitivityScore,
      explanation: generateAssumptionExplanation(lever),
      reviewSuggestion: generateReviewSuggestion(lever.lever),
    });
  }

  return assumptions;
}

function generateAssumptionExplanation(lever: LeverImpact): string {
  const direction = lever.impactOnBalance > 0 ? 'higher' : 'lower';
  const absImpact = Math.abs(lever.impactOnBalance);

  return `A ${formatDeltaValue(lever.lever, lever.testDelta)} ${lever.testDirection} in ${lever.displayName.toLowerCase()} results in approximately ${formatCurrency(absImpact)} ${direction} retirement balance.`;
}

function generateReviewSuggestion(lever: string): string {
  const suggestions: Record<string, string> = {
    expectedReturn: 'Review annually based on portfolio allocation and market conditions',
    inflationRate: 'Consider updating if inflation trends significantly change',
    retirementAge: 'Revisit as career plans evolve',
    annualContribution: 'Update when income or expenses change meaningfully',
    annualExpenses: 'Refresh after major life changes or annual budget review',
    annualHealthcareCosts: 'Review as healthcare needs or coverage changes',
  };

  return suggestions[lever] || 'Review periodically as circumstances change';
}
```

**Phase 2: Create AI Narration**

Create `/src/lib/ai/prompts/sensitivity-explanation.ts`:

```typescript
export const SENSITIVITY_EXPLANATION_SYSTEM_PROMPT = `You explain which assumptions a retirement projection is most sensitive to.

CRITICAL RULES:
1. Use observational language ONLY ("your projection depends heavily on", "shows sensitivity to")
2. NEVER suggest immediate action or changes
3. Encourage periodic review, not urgent response
4. Include the quantified sensitivity from the data
5. Frame as informational awareness, not advice

TONE:
- Educational and calm
- Forward-looking but not alarming
- Emphasize understanding over action

EXAMPLE:
"Your projection shows the most sensitivity to expected investment returns and retirement timing. The return assumption has a particularly large influence—variations of 1% translate to significant differences in projected outcomes. These assumptions are worth revisiting periodically as market conditions and your plans evolve."

BANNED PHRASES:
- "you should review"
- "you need to adjust"
- "take action"
- "immediately"
- "urgently"
`;
```

**Phase 3: Create UI Component**

Create `/src/components/insights/AssumptionSensitivityCard.tsx`:

```typescript
interface AssumptionSensitivityCardProps {
  assumptions: SensitiveAssumption[];
  explanation: string;
  isLoading?: boolean;
}

export function AssumptionSensitivityCard({
  assumptions,
  explanation,
  isLoading
}: AssumptionSensitivityCardProps) {
  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Settings className="h-5 w-5 animate-pulse" />
            Analyzing Assumptions...
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-24 w-full" />
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2 text-lg">
          <Settings className="h-5 w-5 text-primary" />
          Assumption Sensitivity
        </CardTitle>
        <CardDescription>
          Which assumptions your projection depends on most
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* AI Explanation */}
        <p className="text-sm leading-relaxed">{explanation}</p>

        {/* Top 2 Sensitive Assumptions */}
        <div className="space-y-3">
          {assumptions.map((assumption) => (
            <AssumptionItem key={assumption.assumption} assumption={assumption} />
          ))}
        </div>

        {/* Review Encouragement */}
        <div className="p-3 rounded-lg bg-muted/50 mt-4">
          <p className="text-sm text-muted-foreground">
            <Info className="h-4 w-4 inline mr-2" />
            These assumptions may evolve over time. Periodic review helps keep projections aligned with your actual situation.
          </p>
        </div>
      </CardContent>
    </Card>
  );
}

function AssumptionItem({ assumption }: { assumption: SensitiveAssumption }) {
  return (
    <div className="p-3 rounded-lg border">
      <div className="flex items-center justify-between mb-2">
        <h4 className="font-medium text-sm">{assumption.displayName}</h4>
        <SensitivityMeter score={assumption.sensitivityScore} />
      </div>
      <p className="text-sm text-muted-foreground mb-2">
        Current: <span className="font-medium text-foreground">{assumption.formattedValue}</span>
      </p>
      <p className="text-xs text-muted-foreground">
        {assumption.explanation}
      </p>
      <p className="text-xs text-primary mt-2">
        {assumption.reviewSuggestion}
      </p>
    </div>
  );
}

function SensitivityMeter({ score }: { score: number }) {
  return (
    <div className="flex items-center gap-2">
      <div className="w-16 h-2 rounded-full bg-muted overflow-hidden">
        <div
          className={cn(
            "h-full rounded-full transition-all",
            score >= 80 && "bg-destructive",
            score >= 50 && score < 80 && "bg-warning",
            score < 50 && "bg-success"
          )}
          style={{ width: `${score}%` }}
        />
      </div>
      <span className="text-xs text-muted-foreground">{score}%</span>
    </div>
  );
}
```

---

## Integration Plan

### Page Integration

Add insights section to `/src/app/plans/plans-client.tsx`:

```typescript
// Add state for insights
const [insights, setInsights] = useState<InsightsData | null>(null);
const [insightsLoading, setInsightsLoading] = useState(false);

// Fetch insights when projection changes
useEffect(() => {
  if (projection && !isScenarioActive) {
    fetchInsights();
  }
}, [projection, isScenarioActive]);

async function fetchInsights() {
  setInsightsLoading(true);
  try {
    const response = await fetch('/api/insights/analyze', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ assumptions }),
    });
    const data = await response.json();
    setInsights(data);
  } finally {
    setInsightsLoading(false);
  }
}

// In render, add after projection chart:
{!isScenarioActive && (
  <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3 mt-8">
    <TopLeversCard
      levers={insights?.topLevers ?? []}
      explanation={insights?.leverExplanation ?? ''}
      isLoading={insightsLoading}
    />
    <LowFrictionWinsCard
      wins={insights?.lowFrictionWins ?? []}
      isLoading={insightsLoading}
    />
    <AssumptionSensitivityCard
      assumptions={insights?.sensitiveAssumptions ?? []}
      explanation={insights?.sensitivityExplanation ?? ''}
      isLoading={insightsLoading}
    />
  </div>
)}
```

---

## File Structure

```
src/
├── lib/
│   ├── projections/
│   │   └── sensitivity.ts           # NEW: Sensitivity analysis engine
│   └── ai/
│       └── prompts/
│           ├── lever-explanation.ts     # NEW: Lever explanation prompt
│           └── sensitivity-explanation.ts # NEW: Sensitivity explanation prompt
├── app/
│   └── api/
│       └── insights/
│           ├── levers/
│           │   └── route.ts         # NEW: Top levers endpoint
│           ├── wins/
│           │   └── route.ts         # NEW: Low-friction wins endpoint
│           ├── sensitivity/
│           │   └── route.ts         # NEW: Sensitivity endpoint
│           └── analyze/
│               └── route.ts         # NEW: Combined insights endpoint
└── components/
    └── insights/
        ├── TopLeversCard.tsx        # NEW: Top 3 levers display
        ├── LowFrictionWinsCard.tsx  # NEW: Quick wins display
        └── AssumptionSensitivityCard.tsx # NEW: Sensitivity display
```

---

## Code References

### Existing Infrastructure to Leverage

- [engine.ts:117-227](src/lib/projections/engine.ts#L117-L227) - Core projection algorithm
- [types.ts:57-90](src/lib/projections/types.ts#L57-L90) - ProjectionInput structure
- [types.ts:145-152](src/lib/projections/types.ts#L145-L152) - ProjectionSummary with key metrics
- [scenario-explain.ts](src/lib/ai/prompts/scenario-explain.ts) - Guardrailed AI explanation pattern
- [validate-response.ts](src/lib/ai/validate-response.ts) - Banned phrase validation
- [plans-client.tsx:393-443](src/app/plans/plans-client.tsx#L393-L443) - Metric card patterns
- [ScenarioExplanation.tsx](src/components/scenarios/ScenarioExplanation.tsx) - Key changes badge pattern

---

## Architecture Insights

### Design Principles

1. **Computation-First, Narration-Second**: All insights are derived algorithmically. AI only explains pre-computed results.

2. **Guardrailed Language**: Reuse Epic 4/5's banned phrase validation to prevent prescriptive language.

3. **Quantified Impacts**: Every insight includes specific dollar amounts or percentages, not vague qualitative statements.

4. **Uncertainty Acknowledgment**: Each insight includes appropriate caveats about assumptions and limitations.

5. **Review-Oriented, Not Action-Oriented**: Language encourages periodic review rather than immediate changes.

### Security Considerations

- All sensitivity analysis runs server-side
- AI prompts include explicit guardrails against advice
- Response validation rejects prescriptive language
- No external product or investment suggestions

---

## Historical Context (from thoughts/)

- [thoughts/personal/tickets/epic-4/story-1-scope.md](thoughts/personal/tickets/epic-4/story-1-scope.md) - AI guardrail patterns established
- [thoughts/shared/plans/2025-12-30-epic-4-story-1-ai-plan-summary.md](thoughts/shared/plans/2025-12-30-epic-4-story-1-ai-plan-summary.md) - Four-phase AI implementation approach
- [thoughts/shared/research/2026-01-14-ENG-5.2-delta-based-explanation.md](thoughts/shared/research/2026-01-14-ENG-5.2-delta-based-explanation.md) - Delta comparison patterns
- [thoughts/shared/plans/2026-01-14-ENG-5.2-delta-based-explanation.md](thoughts/shared/plans/2026-01-14-ENG-5.2-delta-based-explanation.md) - Comparison-based AI explanations

---

## Related Research

- [2025-12-30-epic-4-story-1-ai-plan-summary.md](thoughts/shared/research/2025-12-30-epic-4-story-1-ai-plan-summary.md) - AI integration infrastructure
- [2026-01-13-ENG-5.1-scenario-projection-system.md](thoughts/shared/research/2026-01-13-ENG-5.1-scenario-projection-system.md) - Override/delta patterns
- [2026-01-14-ENG-5.2-delta-based-explanation.md](thoughts/shared/research/2026-01-14-ENG-5.2-delta-based-explanation.md) - Comparison explanations

---

## Open Questions

1. **Caching Strategy**: Should sensitivity results be cached like AI summaries? They're computationally heavier than single projections.

2. **Trigger Frequency**: When should insights refresh? On every assumption change, or only on explicit request?

3. **Mobile Layout**: Three-card grid may need single-column treatment on mobile.

4. **Scenario Integration**: Should insights be hidden during scenario mode (current recommendation) or show scenario-specific insights?

5. **A/B Testing**: Consider testing different phrasings of "low-friction wins" terminology.
