---
date: 2026-01-22T12:00:00-08:00
researcher: Claude
git_commit: 67291ff37bc0724970881c9e57c4b33f4db5e526
branch: main
repository: plan-smart
topic: "Story 10.1 Target Depletion Input Implementation Recommendation"
tags: [research, codebase, epic-10, depletion-target, projection-settings, implementation]
status: complete
last_updated: 2026-01-22
last_updated_by: Claude
---

# Research: Story 10.1 Target Depletion Input Implementation Recommendation

**Date**: 2026-01-22T12:00:00-08:00
**Researcher**: Claude
**Git Commit**: 67291ff37bc0724970881c9e57c4b33f4db5e526
**Branch**: main
**Repository**: plan-smart

## Research Question

How should Story 10.1 (Target Depletion Input) be implemented to integrate seamlessly with the existing codebase architecture, following established patterns for data models, UI components, validation, and projection recalculation?

## Summary

Story 10.1 should follow the **SpendingPhaseConfig pattern** established in Epic 9. The implementation involves:

1. **Data Model**: Add `DepletionTarget` interface to `types.ts` and `depletionTarget` JSONB column to `financial_snapshot` schema
2. **UI Component**: Create `DepletionTargetInput` component following `AssumptionsPanel` slider+input patterns
3. **Validation**: Add Zod schema with cross-field validation for age constraints
4. **Persistence**: Use existing `/api/profile` PATCH endpoint pattern
5. **Recalculation**: Extend `ProjectionInput` and trigger recalculation on changes

The architecture is well-suited for this feature - it follows existing patterns exactly.

---

## Detailed Findings

### 1. Data Model Implementation

#### 1.1 Add DepletionTarget Interface

**File**: `src/lib/projections/types.ts`
**Location**: After `SpendingPhaseConfig` interface (~line 97)

```typescript
// Epic 10: Intentional Portfolio Depletion Targets
export interface DepletionTarget {
  enabled: boolean;
  targetPercentageSpent: number;  // 0-100, e.g., 75 means spend 75% by target age
  targetAge: number;              // Age by which to reach depletion target
}
```

**Rationale**: Follows existing pattern of `SpendingPhaseConfig` with `enabled` boolean for opt-in behavior.

#### 1.2 Extend ProjectionInput

**File**: `src/lib/projections/types.ts`
**Location**: Add to `ProjectionInput` interface (~line 145)

```typescript
// Epic 10: Depletion target configuration
depletionTarget?: DepletionTarget;
```

#### 1.3 Database Schema

**File**: `src/db/schema/financial-snapshot.ts`

Add JSONB type definition (~line 68):
```typescript
export type DepletionTargetJson = {
  enabled: boolean;
  targetPercentageSpent: number;
  targetAge: number;
};
```

Add column to `financialSnapshot` table (~line 133):
```typescript
depletionTarget: jsonb('depletion_target').$type<DepletionTargetJson>(),
```

**Migration Required**: Create migration to add `depletion_target` JSONB column.

---

### 2. Default Values

**File**: `src/lib/projections/assumptions.ts`
**Location**: After `DEFAULT_SPENDING_PHASES` (~line 100)

```typescript
// Epic 10: Default depletion target (disabled by default)
export const DEFAULT_DEPLETION_TARGET: DepletionTarget = {
  enabled: false,
  targetPercentageSpent: 50,  // Spend 50% of portfolio
  targetAge: 85,              // By age 85
};

export function getDefaultDepletionTarget(maxAge: number): DepletionTarget {
  return {
    enabled: false,
    targetPercentageSpent: 50,
    targetAge: Math.min(85, maxAge - 5),  // 5 years before life expectancy
  };
}
```

**Rationale**: Default of 50% by age 85 provides a balanced starting point per the story's acceptance criteria. Feature is opt-in (disabled by default) to avoid surprising existing users.

---

### 3. Validation Schema

**File**: `src/lib/validation/projections.ts`
**Location**: After `spendingPhaseConfigSchema` (~line 50)

```typescript
// Epic 10: Depletion target validation
export const depletionTargetSchema = z.object({
  enabled: z.boolean(),
  targetPercentageSpent: z
    .number()
    .min(0, 'Depletion percentage cannot be negative')
    .max(100, 'Depletion percentage cannot exceed 100%'),
  targetAge: z
    .number()
    .int('Target age must be a whole number')
    .min(50, 'Target age must be at least 50')
    .max(120, 'Target age cannot exceed 120'),
});

// Cross-field validation (requires context from calling code)
export function validateDepletionTarget(
  target: DepletionTarget,
  currentAge: number,
  lifeExpectancy: number
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (target.targetAge <= currentAge) {
    errors.push(`Target age (${target.targetAge}) must be greater than your current age (${currentAge})`);
  }

  if (target.targetAge > lifeExpectancy) {
    errors.push(`Target age (${target.targetAge}) cannot exceed life expectancy (${lifeExpectancy})`);
  }

  return { valid: errors.length === 0, errors };
}
```

**Rationale**: Follows existing validation patterns. Cross-field validation separated since it requires runtime context (currentAge, lifeExpectancy) not available in static schema.

---

### 4. UI Component

#### 4.1 Component Structure

**File**: `src/components/depletion-target-input.tsx` (new file)

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { Slider } from '@/components/ui/slider';
import { Input } from '@/components/ui/input';
import { AlertCircle, Info } from 'lucide-react';
import { DepletionTarget } from '@/lib/projections/types';
import { DEFAULT_DEPLETION_TARGET } from '@/lib/projections/assumptions';
import { validateDepletionTarget } from '@/lib/validation/projections';

interface DepletionTargetInputProps {
  target: DepletionTarget | undefined;
  currentAge: number;
  lifeExpectancy: number;
  portfolioValue: number;
  onChange: (target: DepletionTarget) => void;
}

export function DepletionTargetInput({
  target,
  currentAge,
  lifeExpectancy,
  portfolioValue,
  onChange,
}: DepletionTargetInputProps) {
  const [localTarget, setLocalTarget] = useState<DepletionTarget>(
    target ?? { ...DEFAULT_DEPLETION_TARGET, targetAge: Math.min(85, lifeExpectancy - 5) }
  );

  // Local state for text inputs (allows typing without immediate validation)
  const [percentageInput, setPercentageInput] = useState(
    localTarget.targetPercentageSpent.toString()
  );
  const [ageInput, setAgeInput] = useState(localTarget.targetAge.toString());

  // Validation state
  const [validationErrors, setValidationErrors] = useState<string[]>([]);

  // Validate and propagate changes
  useEffect(() => {
    if (localTarget.enabled) {
      const result = validateDepletionTarget(localTarget, currentAge, lifeExpectancy);
      setValidationErrors(result.errors);
    } else {
      setValidationErrors([]);
    }
    onChange(localTarget);
  }, [localTarget, currentAge, lifeExpectancy, onChange]);

  // ... handlers follow AssumptionsPanel patterns
}
```

#### 4.2 Key UI Patterns to Follow

Based on `AssumptionsPanel.tsx` patterns:

1. **Dual Control (Slider + Input)**:
   - Use slider for primary interaction
   - Text input for precise values
   - Local state buffers input during typing
   - Validate and sync on blur/Enter

2. **Percentage Display**:
   - Store as whole number (0-100)
   - Display with `%` suffix
   - Slider range: 0-100, step: 5

3. **Age Input**:
   - Integer values only
   - Slider range: `currentAge + 1` to `lifeExpectancy`
   - Step: 1

4. **Enable/Disable Toggle**:
   - Follow `SpendingPhaseEditor` pattern with `Switch` component
   - Hide detailed inputs when disabled
   - Show helpful default explanation

5. **Messaging Framing**:
   - Use positive language ("spend" not "deplete")
   - Show projected reserve amount: `${(portfolioValue * (100 - targetPercentageSpent) / 100).toLocaleString()}`
   - Distinguish from "failure scenario" with explanatory text

---

### 5. API Integration

#### 5.1 Profile Update Endpoint

**File**: `src/app/api/profile/route.ts`
**Location**: Add to update handler (~line 82)

```typescript
if (data.depletionTarget !== undefined) {
  updateData.depletionTarget = data.depletionTarget;
}
```

**File**: `src/lib/validation/profile.ts`
**Location**: Add to `profileUpdateSchema`

```typescript
depletionTarget: depletionTargetSchema.optional(),
```

#### 5.2 Projection Calculation

**File**: `src/app/api/projections/calculate/route.ts`
**Location**: Add to `calculateProjection` function (~line 240)

```typescript
depletionTarget: (overrides.depletionTarget as DepletionTarget | undefined)
  ?? (snapshot.depletionTarget as DepletionTarget | null)
  ?? undefined,
```

#### 5.3 Input Builder

**File**: `src/lib/projections/input-builder.ts`
**Location**: Add to `buildProjectionInputFromSnapshot` (~line 128)

```typescript
const depletionTarget = overrides.depletionTarget
  ?? (snapshot.depletionTarget as DepletionTarget | null)
  ?? undefined;
```

And include in returned object:
```typescript
depletionTarget,
```

---

### 6. Projection Recalculation

#### 6.1 Plans Client Integration

**File**: `src/app/plans/plans-client.tsx`

Add state for depletion target:
```typescript
const [depletionTarget, setDepletionTarget] = useState<DepletionTarget | undefined>(
  initialDepletionTarget
);
```

Add change handler:
```typescript
const handleDepletionTargetChange = async (target: DepletionTarget) => {
  try {
    await fetch('/api/profile', {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ depletionTarget: target }),
    });
    setDepletionTarget(target);
    refetchProjection();
  } catch (error) {
    console.error('Failed to save depletion target:', error);
  }
};
```

#### 6.2 Change Detection

Extend the `hasChanges` detection in the recalculation useEffect to include depletion target changes if needed for real-time updates.

---

### 7. UI Placement Recommendation

Based on existing UI structure, the Depletion Target Input should be placed in one of these locations:

**Option A: Profile Page** (`src/app/profile/profile-client.tsx`)
- Alongside other retirement planning settings
- Persistent across sessions
- Follows pattern of spending phases

**Option B: Plans Page Sidebar** (`src/app/plans/plans-client.tsx`)
- Near AssumptionsPanel
- Allows real-time impact visibility
- More contextual for "what-if" scenarios

**Recommendation**: **Option A (Profile Page)** for initial implementation, matching the story's acceptance criteria that "Depletion target persists in user's plan settings." Add a link/reference from Plans page for visibility.

---

## Implementation Order

### Phase 1: Data Layer
1. Add `DepletionTarget` interface to `types.ts`
2. Add JSONB type to `financial-snapshot.ts`
3. Create database migration
4. Add default values to `assumptions.ts`

### Phase 2: Validation
1. Add Zod schema to `projections.ts`
2. Add validation function for cross-field checks
3. Add to `profileUpdateSchema`

### Phase 3: API Integration
1. Update `/api/profile` PATCH handler
2. Update `/api/projections/calculate` to include in input
3. Update `input-builder.ts`

### Phase 4: UI Component
1. Create `DepletionTargetInput` component
2. Add to Profile page
3. Wire up change handlers and persistence

### Phase 5: Projection Integration
1. Update `PlansClient` to receive depletion target
2. Ensure changes trigger recalculation
3. (Story 10.2+) Update engine to use target for calculations

---

## Code References

| File | Line | Purpose |
|------|------|---------|
| `src/lib/projections/types.ts` | 76-97 | SpendingPhaseConfig pattern to follow |
| `src/lib/projections/types.ts` | 103-146 | ProjectionInput interface to extend |
| `src/db/schema/financial-snapshot.ts` | 54-68 | JSONB type definition pattern |
| `src/db/schema/financial-snapshot.ts` | 132 | spendingPhases column pattern |
| `src/lib/projections/assumptions.ts` | 78-116 | Default value patterns |
| `src/lib/validation/projections.ts` | 6-48 | Validation schema patterns |
| `src/components/projections/AssumptionsPanel.tsx` | 56-84 | Slider+input validation pattern |
| `src/components/spending-phase-editor.tsx` | 96-100 | Enable/disable toggle pattern |
| `src/app/api/profile/route.ts` | 79-82 | PATCH handler pattern |
| `src/app/plans/plans-client.tsx` | 189-208 | Save config and refetch pattern |

---

## Architecture Insights

### Patterns Discovered

1. **Optional Feature Pattern**: Use `enabled: boolean` for opt-in features (SpendingPhaseConfig, DepletionTarget)

2. **JSONB Storage Pattern**: Complex settings stored as typed JSONB columns with TypeScript types

3. **Dual-Control Input Pattern**: Slider + text input with local state buffering for good UX

4. **Settings Resolution Priority**: Request overrides > Snapshot values > Defaults

5. **Debounced Recalculation**: 300ms debounce with AbortController for settings changes

6. **Separation of Concerns**: Engine calculates, API fetches/persists, UI manages state

### Design Decisions

1. **Whole Number Percentages**: Store `targetPercentageSpent` as 0-100 (not decimal) for consistency with `savingsRate` pattern

2. **Disabled by Default**: Opt-in pattern prevents surprising existing users

3. **Cross-Field Validation Separate**: Age constraints require runtime context, so validation function is separate from Zod schema

---

## Historical Context (from thoughts/)

### Related Epic 9 Implementation
- `thoughts/shared/research/2026-01-19-ENG-9.1-phase-based-spending-integration.md` - SpendingPhaseConfig integration patterns
- `thoughts/shared/plans/2026-01-22-ENG-9.3-projection-chart-spending-timeline.md` - Recent implementation provides architectural template

### Epic 10 Story Sequence
- `thoughts/personal/tickets/epic-10/story-1-scope.md` - This story (input)
- `thoughts/personal/tickets/epic-10/story-2-scope.md` - Reserve preservation logic (uses this input)
- `thoughts/personal/tickets/epic-10/story-3-scope.md` - Spending translation feedback (visualization)

---

## Related Research

- [2026-01-19-ENG-9.1-phase-based-spending-integration.md](2026-01-19-ENG-9.1-phase-based-spending-integration.md) - SpendingPhaseConfig implementation
- [2026-01-22-ENG-9.3-projection-chart-implementation.md](2026-01-22-ENG-9.3-projection-chart-implementation.md) - Recent projection chart work
- [2026-01-13-ENG-5.1-scenario-projection-system.md](2026-01-13-ENG-5.1-scenario-projection-system.md) - Projection system architecture

---

## Open Questions

1. **Engine Integration**: Story 10.1 is input-only. Story 10.2 will need to update the projection engine to actually use the depletion target for calculations. Should we stub the engine integration now or defer completely?

2. **Multiple Targets**: The story explicitly excludes "Multiple depletion milestones." Should the data model be designed to easily extend to an array later, or keep it simple as a single target?

3. **Target Age vs Life Expectancy**: If user changes life expectancy to be less than target age, should we auto-adjust target age or show validation error?

---

## Estimated Scope

- **New Files**: 1 (DepletionTargetInput component)
- **Modified Files**: ~8 (types, schema, assumptions, validation, profile API, projections API, input-builder, profile-client)
- **Database Migration**: 1 (add depletion_target column)
- **Test Files**: 2-3 (validation tests, component tests, API tests)
