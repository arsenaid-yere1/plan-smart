---
date: 2026-01-23T12:00:00-08:00
researcher: Claude
git_commit: 94ba201861648921cb171625595eb9d7993cd2c1
branch: main
repository: plan-smart
topic: "Story 10.2 Reserve Preservation Implementation Recommendation"
tags: [research, codebase, epic-10, reserve, depletion, projection-engine, configuration]
status: complete
last_updated: 2026-01-23
last_updated_by: Claude
last_updated_note: "Completed all design decisions - reserve behavior, chart, runway, income floor separation"
---

# Research: Story 10.2 Reserve Preservation Implementation Recommendation

**Date**: 2026-01-23T12:00:00-08:00
**Researcher**: Claude
**Git Commit**: 94ba201861648921cb171625595eb9d7993cd2c1
**Branch**: main
**Repository**: plan-smart

## Research Question

How should Story 10.2 (Reserve Preservation) be implemented to allow users to preserve a portion of their portfolio as a safety buffer, following established codebase patterns?

## Summary

Story 10.2 can be implemented by extending the existing `DepletionTarget` infrastructure from Story 10.1. The recommended approach:

1. **Extend the data model** to include `ReserveConfig` alongside `DepletionTarget`
2. **Add bidirectional sync** between depletion percentage and reserve percentage in the UI
3. **Modify the projection engine** to respect reserve floors during drawdown calculations
4. **Add validation** to ensure mathematical consistency between depletion and reserve settings
5. **Create a unified "Depletion & Reserve" configuration UI** that shows both as complementary values

The implementation follows established patterns from Story 10.1 (depletion target) and Epic 9 (spending phases).

## Detailed Findings

### 1. Current Depletion Target Infrastructure (Story 10.1)

Story 10.1 has already been implemented and provides the foundation for Story 10.2.

#### Data Model (`src/lib/projections/types.ts:103-107`)
```typescript
export interface DepletionTarget {
  enabled: boolean;
  targetPercentageSpent: number;  // 0-100
  targetAge: number;
}
```

#### Database Storage (`src/db/schema/financial-snapshot.ts:142`)
- JSONB column `depletion_target` in `financial_snapshot` table
- Migration: `0010_wise_morph.sql`

#### UI Component (`src/components/depletion-target-input.tsx`)
- Switch toggle for enable/disable
- Dual-control inputs (slider + text) for percentage and age
- Real-time validation with error display
- Shows "Projected reserve" as calculated value (line 117): `portfolioValue * (1 - targetPercentageSpent / 100)`

**Key Insight**: The current UI already displays reserve as a derived value. Story 10.2 extends this to make reserve a first-class input option.

### 2. Projection Engine Analysis

#### Current Behavior (`src/lib/projections/engine.ts`)
- **No portfolio floor enforcement** - balances can deplete to zero
- Depletion tracking (lines 275-277) records when `totalBalance <= 0`
- `DepletionTarget` is in the type system but **not yet consumed** by the engine

#### Required Changes for Reserve Preservation
The engine needs modification to:
1. Calculate the reserve floor amount (absolute or percentage-based)
2. Reduce available withdrawal capacity when approaching reserve floor
3. Track reserve breach warnings in projection output

#### Withdrawal Strategy (`src/lib/projections/engine.ts:16-45`)
Current tax-aware withdrawal order: Taxable â†’ Tax-deferred â†’ Tax-free

**Proposed Reserve Logic** (insert before withdrawal):
```typescript
// Calculate reserve floor
const reserveFloor = reserve.type === 'percentage'
  ? initialPortfolio * (reserve.amount / 100)
  : reserve.amount;

// Reduce withdrawal if it would breach reserve
const currentTotal = totalBalance(balances);
const maxWithdrawal = Math.max(0, currentTotal - reserveFloor);
const actualWithdrawal = Math.min(withdrawalNeeded, maxWithdrawal);
```

### 3. Recommended Data Model Extension

#### Option A: Extend DepletionTarget (Recommended)
```typescript
export interface DepletionTarget {
  enabled: boolean;
  targetPercentageSpent: number;  // 0-100
  targetAge: number;

  // New fields for Story 10.2
  reserve: ReserveConfig;
}

export interface ReserveConfig {
  type: 'derived' | 'absolute' | 'percentage';  // 'derived' = 100 - targetPercentageSpent
  amount?: number;           // Only used if type is 'absolute' or 'percentage'
  purpose?: ReservePurpose[];
  notes?: string;
}

export type ReservePurpose =
  | 'longevity'
  | 'emergency'
  | 'legacy'
  | 'healthcare'
  | 'peace_of_mind';
```

**Rationale**:
- Keeps depletion and reserve in one logical unit
- Enforces mathematical consistency (depletion + reserve = 100% in derived mode)
- Backward compatible (existing records have `reserve: undefined`)

#### Option B: Separate Reserve Interface
```typescript
export interface ReserveConfig {
  enabled: boolean;
  type: 'absolute' | 'percentage';
  amount: number;
  purpose?: ReservePurpose[];
  notes?: string;
}
```

**Rationale**:
- More explicit separation
- Requires separate validation logic

**Recommendation**: Option A provides better UX (unified control) and simpler validation.

### 4. UI Component Design

#### Pattern: Unified Depletion & Reserve Panel

Following the existing `DepletionTargetInput` component patterns:

```tsx
// Conceptual structure
<div className="space-y-6">
  {/* Enable Toggle */}
  <Switch checked={target.enabled} />

  {target.enabled && (
    <>
      {/* Depletion Target Section */}
      <div className="space-y-4">
        <h4>Spending Target</h4>
        <Slider value={targetPercentageSpent} />
        <span>Spend {targetPercentageSpent}% by age {targetAge}</span>
      </div>

      {/* Reserve Section - NEW */}
      <div className="space-y-4 pt-4 border-t">
        <h4>Reserve Protection</h4>

        {/* Reserve Mode Toggle */}
        <RadioGroup value={reserve.type}>
          <RadioGroupItem value="derived" label="Match spending target" />
          <RadioGroupItem value="percentage" label="Custom percentage" />
          <RadioGroupItem value="absolute" label="Specific dollar amount" />
        </RadioGroup>

        {/* Conditional Inputs */}
        {reserve.type === 'derived' && (
          <div className="p-3 bg-muted rounded-lg">
            Reserve: {100 - targetPercentageSpent}% (${reserveAmount.toLocaleString()})
          </div>
        )}

        {reserve.type === 'percentage' && (
          <Slider value={reserve.amount} min={0} max={100} />
        )}

        {reserve.type === 'absolute' && (
          <Input type="number" value={reserve.amount} placeholder="$100,000" />
        )}

        {/* Purpose Tags (Optional) */}
        <div className="space-y-2">
          <Label>Reserve Purpose (optional)</Label>
          <div className="flex flex-wrap gap-2">
            {RESERVE_PURPOSES.map(purpose => (
              <button
                key={purpose.value}
                onClick={() => togglePurpose(purpose.value)}
                className={cn(
                  "px-3 py-1 rounded-full text-sm border",
                  selectedPurposes.has(purpose.value)
                    ? "bg-primary text-primary-foreground"
                    : "bg-muted hover:bg-muted/80"
                )}
              >
                {purpose.label}
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Summary */}
      <div className="p-4 bg-blue-50 dark:bg-blue-950 rounded-lg">
        <p>By age {targetAge}:</p>
        <ul>
          <li>Spend: ${spendingAmount.toLocaleString()} ({targetPercentageSpent}%)</li>
          <li>Keep in reserve: ${reserveAmount.toLocaleString()} ({reservePercent}%)</li>
        </ul>
      </div>

      {/* Validation Warnings */}
      {breachWarning && (
        <Alert variant="warning">
          Current trajectory breaches reserve by age {breachAge}
        </Alert>
      )}
    </>
  )}
</div>
```

#### Existing UI Patterns to Follow

1. **Toggle + Conditional Panel** (`src/components/depletion-target-input.tsx:121-241`)
2. **Percentage vs Absolute Toggle** (`src/components/spending-phase-editor.tsx:148-271`)
3. **Multi-Select Tags** (`src/components/onboarding/step3-financial-info.tsx:46-230`)
4. **Validation Error Banner** (`src/components/depletion-target-input.tsx:222-231`)

### 5. Validation Strategy

#### Schema Validation (Zod)

```typescript
// In src/lib/validation/projections.ts

export const reserveConfigSchema = z.object({
  type: z.enum(['derived', 'absolute', 'percentage']),
  amount: z.number().min(0).optional(),
  purpose: z.array(z.enum([
    'longevity', 'emergency', 'legacy', 'healthcare', 'peace_of_mind'
  ])).optional(),
  notes: z.string().max(500).optional(),
});

export const depletionTargetSchemaV2 = depletionTargetSchema.extend({
  reserve: reserveConfigSchema.optional(),
});
```

#### Runtime Cross-Field Validation

```typescript
// In src/lib/validation/projections.ts

export function validateDepletionAndReserve(
  target: DepletionTarget,
  reserve: ReserveConfig,
  initialPortfolio: number,
  currentAge: number,
  maxAge: number
): { valid: boolean; errors: string[]; warnings: string[] } {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Existing depletion validation
  if (target.targetAge <= currentAge) {
    errors.push(`Target age must be greater than current age (${currentAge})`);
  }

  // Reserve consistency checks
  if (reserve.type !== 'derived') {
    const reservePercent = reserve.type === 'percentage'
      ? reserve.amount
      : (reserve.amount / initialPortfolio) * 100;

    const impliedReserve = 100 - target.targetPercentageSpent;

    // Allow 1% tolerance for rounding
    if (Math.abs(impliedReserve - reservePercent) > 1) {
      warnings.push(
        `Depletion target implies ${impliedReserve.toFixed(0)}% reserve, ` +
        `but reserve is set to ${reservePercent.toFixed(0)}%`
      );
    }
  }

  // Reserve floor feasibility
  if (reserve.type === 'absolute' && reserve.amount > initialPortfolio) {
    errors.push('Reserve amount cannot exceed current portfolio value');
  }

  return { valid: errors.length === 0, errors, warnings };
}
```

### 6. Projection Engine Integration

#### Modified Drawdown Logic

```typescript
// In src/lib/projections/engine.ts

// Add to ProjectionInput interface
export interface ProjectionInput {
  // ... existing fields
  depletionTarget?: DepletionTarget;
  reserveFloor?: number;  // Pre-calculated absolute amount
}

// In input-builder.ts, calculate reserveFloor from ReserveConfig
const calculateReserveFloor = (
  reserve: ReserveConfig,
  initialPortfolio: number,
  depletionTarget: DepletionTarget
): number => {
  if (!reserve || reserve.type === 'derived') {
    return initialPortfolio * (1 - depletionTarget.targetPercentageSpent / 100);
  }
  return reserve.type === 'percentage'
    ? initialPortfolio * (reserve.amount / 100)
    : reserve.amount;
};

// Modified withdrawal logic in engine.ts
const executeWithdrawal = (
  balances: BalancesByType,
  withdrawalNeeded: number,
  reserveFloor: number | undefined
): WithdrawalResult => {
  const currentTotal = totalBalance(balances);

  // Apply reserve floor constraint
  const maxWithdrawal = reserveFloor !== undefined
    ? Math.max(0, currentTotal - reserveFloor)
    : withdrawalNeeded;

  const constrainedWithdrawal = Math.min(withdrawalNeeded, maxWithdrawal);

  // Execute tax-aware withdrawal with constrained amount
  const result = withdrawFromAccounts(balances, constrainedWithdrawal);

  // Track if reserve constrained the withdrawal
  if (constrainedWithdrawal < withdrawalNeeded) {
    result.reserveConstrained = true;
    result.reserveShortfall = withdrawalNeeded - constrainedWithdrawal;
  }

  return result;
};
```

#### New Output Fields

```typescript
// In src/lib/projections/types.ts

export interface ProjectionRecord {
  // ... existing fields
  reserveBalance?: number;      // Remaining above reserve floor
  reserveConstrained?: boolean; // Was withdrawal limited by reserve?
  reserveShortfall?: number;    // Unmet expenses due to reserve
}

export interface ProjectionSummary {
  // ... existing fields
  reserveAtTargetAge?: number;
  yearsReserveConstrained?: number;
  firstReserveBreachAge?: number | null;
}
```

### 7. Implementation Phases

#### Phase 1: Data Model & Schema (Day 1)
1. Extend `DepletionTarget` type with `reserve: ReserveConfig`
2. Add Zod validation schema
3. Update database migration (add fields to JSONB)
4. Update API route to accept reserve config

#### Phase 2: Engine Integration (Day 2)
1. Add `reserveFloor` to `ProjectionInput`
2. Modify `input-builder.ts` to calculate reserve floor
3. Update `withdrawFromAccounts` to respect reserve floor
4. Add reserve-related fields to `ProjectionRecord` and `ProjectionSummary`
5. Add unit tests for reserve constraint logic

#### Phase 3: UI Component (Day 3)
1. Extend `DepletionTargetInput` component with reserve section
2. Add reserve mode toggle (derived/percentage/absolute)
3. Implement purpose tag multi-select
4. Add bidirectional sync between depletion and reserve percentages
5. Display reserve summary and warnings

#### Phase 4: Validation & Warnings (Day 4)
1. Implement consistency validation
2. Add "reserve breach" warning in projections
3. Show warning banner when trajectory would breach reserve
4. Add tooltip explanations for reserve purposes

#### Phase 5: Testing & Polish (Day 5)
1. Integration tests for reserve flow
2. Edge case testing (0% reserve, 100% reserve)
3. Visual testing for all reserve modes
4. Accessibility review

## Code References

### Existing Implementation (Story 10.1)
- [types.ts:103-107](src/lib/projections/types.ts#L103-L107) - DepletionTarget interface
- [financial-snapshot.ts:142](src/db/schema/financial-snapshot.ts#L142) - Database column
- [depletion-target-input.tsx](src/components/depletion-target-input.tsx) - UI component
- [projections.ts:55-97](src/lib/validation/projections.ts#L55-L97) - Validation

### Projection Engine
- [engine.ts:175-326](src/lib/projections/engine.ts#L175-L326) - Main projection loop
- [engine.ts:16-45](src/lib/projections/engine.ts#L16-L45) - Withdrawal strategy
- [engine.ts:222-289](src/lib/projections/engine.ts#L222-L289) - Drawdown logic
- [input-builder.ts:36](src/lib/projections/input-builder.ts#L36) - Input construction

### UI Patterns to Follow
- [spending-phase-editor.tsx:148-271](src/components/spending-phase-editor.tsx#L148-L271) - Percentage vs absolute toggle
- [step3-financial-info.tsx:46-230](src/components/onboarding/step3-financial-info.tsx#L46-L230) - Multi-select cards
- [profile-client.tsx:181-200](src/app/profile/profile-client.tsx#L181-L200) - Save handler pattern

## Architecture Insights

### Design Principles

1. **Reserve as "Flip Side" of Depletion**: The UI should present reserve and depletion as complementary values that sum to 100%. When user adjusts one, the other updates automatically in "derived" mode.

2. **Opt-In Complexity**: Default to "derived" reserve mode where reserve = 100 - depletion. Only show absolute/percentage options for advanced users.

3. **Engine Stays Stateless**: Calculate `reserveFloor` in input-builder, pass as absolute dollar amount to engine. Engine doesn't need to know about percentages.

4. **Warnings, Not Blocks**: If spending trajectory would breach reserve, show warning but don't prevent the projection. Users may consciously choose aggressive spending.

5. **Purpose Tags are Optional Metadata**: Reserve purposes help users think through their goals but don't affect calculations. They're for documentation/reflection.

### Consistency with Story 10.1

- Same JSONB storage pattern
- Same validation approach (Zod + runtime cross-field)
- Same UI component structure (toggle + conditional panel)
- Same API route structure (`/api/profile` PATCH)

### Mathematical Relationship

```
portfolioValue = spendingTarget + reserve
100% = targetPercentageSpent + reservePercentage

// Example:
portfolioValue = $1,000,000
targetPercentageSpent = 75%
reservePercentage = 25% (derived)
spendingTarget = $750,000
reserve = $250,000
```

## Historical Context (from thoughts/)

- [2026-01-22-ENG-10.1-implementation-recommendation.md](thoughts/shared/research/2026-01-22-ENG-10.1-implementation-recommendation.md) - Story 10.1 patterns to follow
- [2026-01-22-ENG-10.1-target-depletion-input.md](thoughts/shared/plans/2026-01-22-ENG-10.1-target-depletion-input.md) - Story 10.1 implementation plan
- [2026-01-19-ENG-9.1-phase-based-spending-integration.md](thoughts/shared/research/2026-01-19-ENG-9.1-phase-based-spending-integration.md) - Similar optional feature pattern

## Design Decisions

### Reserve Breach Behavior (DECIDED)

**Decision**: When projection hits reserve floor, spending is **reduced proportionally, then cut to essentials only** as a two-stage approach.

**Rationale**: This provides intuitive behavior - discretionary spending is reduced first, preserving essential expenses as long as possible.

#### Implementation: Two-Stage Spending Reduction

```typescript
// In src/lib/projections/engine.ts

interface ReserveConstrainedWithdrawal {
  essentialWithdrawal: number;
  discretionaryWithdrawal: number;
  totalWithdrawal: number;
  reductionStage: 'none' | 'discretionary_reduced' | 'essentials_only' | 'essentials_reduced';
  shortfall: number;
}

const calculateReserveConstrainedSpending = (
  balances: BalancesByType,
  essentialExpenses: number,
  discretionaryExpenses: number,
  totalIncome: number,
  reserveFloor: number
): ReserveConstrainedWithdrawal => {
  const currentTotal = totalBalance(balances);
  const availableAboveReserve = Math.max(0, currentTotal - reserveFloor);

  // Full expenses needed from portfolio (after income)
  const essentialFromPortfolio = Math.max(0, essentialExpenses - totalIncome);
  const discretionaryFromPortfolio = discretionaryExpenses; // Discretionary fully from portfolio
  const totalNeeded = essentialFromPortfolio + discretionaryFromPortfolio;

  // Stage 1: No constraint needed
  if (availableAboveReserve >= totalNeeded) {
    return {
      essentialWithdrawal: essentialFromPortfolio,
      discretionaryWithdrawal: discretionaryFromPortfolio,
      totalWithdrawal: totalNeeded,
      reductionStage: 'none',
      shortfall: 0,
    };
  }

  // Stage 2: Reduce discretionary proportionally, preserve essentials
  if (availableAboveReserve >= essentialFromPortfolio) {
    const remainingForDiscretionary = availableAboveReserve - essentialFromPortfolio;
    const discretionaryRatio = remainingForDiscretionary / discretionaryFromPortfolio;

    return {
      essentialWithdrawal: essentialFromPortfolio,
      discretionaryWithdrawal: remainingForDiscretionary,
      totalWithdrawal: availableAboveReserve,
      reductionStage: 'discretionary_reduced',
      shortfall: discretionaryFromPortfolio - remainingForDiscretionary,
    };
  }

  // Stage 3: Essentials only (no discretionary)
  if (availableAboveReserve > 0) {
    return {
      essentialWithdrawal: availableAboveReserve,
      discretionaryWithdrawal: 0,
      totalWithdrawal: availableAboveReserve,
      reductionStage: 'essentials_only',
      shortfall: essentialFromPortfolio - availableAboveReserve + discretionaryFromPortfolio,
    };
  }

  // Stage 4: Reserve depleted - nothing available
  return {
    essentialWithdrawal: 0,
    discretionaryWithdrawal: 0,
    totalWithdrawal: 0,
    reductionStage: 'essentials_reduced',
    shortfall: totalNeeded,
  };
};
```

#### Updated Output Types

```typescript
// In src/lib/projections/types.ts

export interface ProjectionRecord {
  // ... existing fields

  // Reserve tracking
  reserveBalance: number;              // Amount above reserve floor
  reserveConstrained: boolean;         // Was spending reduced due to reserve?
  reductionStage: 'none' | 'discretionary_reduced' | 'essentials_only' | 'essentials_reduced';

  // Spending breakdown (when reserve-constrained)
  actualEssentialSpending: number;     // What was actually spent on essentials
  actualDiscretionarySpending: number; // What was actually spent on discretionary
  spendingShortfall: number;           // Unmet spending need
}

export interface ProjectionSummary {
  // ... existing fields

  // Reserve summary
  reserveFloor: number;
  reserveAtTargetAge: number;
  yearsReserveConstrained: number;
  firstReserveConstraintAge: number | null;  // When discretionary first reduced
  firstEssentialsOnlyAge: number | null;     // When reduced to essentials only
}
```

#### UI Warning Messaging

Based on `reductionStage`, show contextual warnings:

| Stage | Warning Message |
|-------|-----------------|
| `none` | (no warning) |
| `discretionary_reduced` | "Discretionary spending reduced to protect reserve" |
| `essentials_only` | "Only essential expenses covered to protect reserve" |
| `essentials_reduced` | "Reserve depleted - essential expenses partially unfunded" |

### Chart Visualization (DECIDED)

**Decision**: Use **Dual-Area Chart** showing portfolio split into "Available" and "Reserve" zones.

**Rationale**: This approach makes the reserve relationship visually intuitive - green is what you can spend, yellow/amber is protected. It matches the "flip side" mental model from the depletion/reserve UI.

#### Implementation

```tsx
// In src/components/projections/ProjectionChart.tsx

import { Area, AreaChart, XAxis, YAxis, Tooltip, Legend, ReferenceLine } from 'recharts';

// Transform projection data for dual-area display
const chartData = projectionRecords.map(record => ({
  age: record.age,
  totalBalance: record.totalBalance,
  reserveFloor: reserveFloor,  // Constant line
  balanceAboveReserve: Math.max(0, record.totalBalance - reserveFloor),
  reservePortion: Math.min(record.totalBalance, reserveFloor),
  reductionStage: record.reductionStage,
}));

<AreaChart data={chartData}>
  <XAxis dataKey="age" />
  <YAxis tickFormatter={(v) => `$${(v / 1000).toFixed(0)}k`} />

  {/* Reserve zone (bottom) - protected funds */}
  <Area
    type="monotone"
    dataKey="reservePortion"
    stackId="1"
    fill="#fef3c7"
    stroke="#f59e0b"
    name="Reserve"
  />

  {/* Available zone (top) - spendable funds */}
  <Area
    type="monotone"
    dataKey="balanceAboveReserve"
    stackId="1"
    fill="#bbf7d0"
    stroke="#22c55e"
    name="Available for Spending"
  />

  {/* Reference line at reserve floor for clarity */}
  <ReferenceLine
    y={reserveFloor}
    stroke="#d97706"
    strokeDasharray="3 3"
    label={{ value: `Reserve: $${(reserveFloor / 1000).toFixed(0)}k`, position: 'right' }}
  />

  <Tooltip content={<ReserveTooltip reserveFloor={reserveFloor} />} />
  <Legend />
</AreaChart>
```

#### Custom Tooltip Component

```tsx
const ReserveTooltip = ({ active, payload, reserveFloor }) => {
  if (!active || !payload?.length) return null;

  const data = payload[0].payload;
  const aboveReserve = data.balanceAboveReserve;
  const totalBalance = data.totalBalance;

  return (
    <div className="bg-white dark:bg-gray-800 p-3 rounded-lg shadow-lg border">
      <p className="font-medium">Age {data.age}</p>
      <p className="text-sm">
        Total Balance: <span className="font-medium">${totalBalance.toLocaleString()}</span>
      </p>
      <p className="text-sm text-green-600 dark:text-green-400">
        Available: ${aboveReserve.toLocaleString()}
      </p>
      <p className="text-sm text-amber-600 dark:text-amber-400">
        Reserve: ${Math.min(totalBalance, reserveFloor).toLocaleString()}
      </p>

      {data.reductionStage !== 'none' && (
        <p className={cn(
          "text-xs mt-2 pt-2 border-t",
          data.reductionStage === 'discretionary_reduced' && "text-amber-600",
          data.reductionStage === 'essentials_only' && "text-orange-600",
          data.reductionStage === 'essentials_reduced' && "text-red-600",
        )}>
          {stageWarnings[data.reductionStage]}
        </p>
      )}
    </div>
  );
};

const stageWarnings = {
  none: '',
  discretionary_reduced: 'âš ï¸ Discretionary spending reduced',
  essentials_only: 'âš ï¸ Only essentials covered',
  essentials_reduced: 'ğŸš¨ Essential expenses unfunded',
};
```

#### Visual Design

| Zone | Color | Meaning |
|------|-------|---------|
| Top (Available) | Green (`#bbf7d0` fill, `#22c55e` stroke) | Funds available for spending |
| Bottom (Reserve) | Amber (`#fef3c7` fill, `#f59e0b` stroke) | Protected reserve funds |
| Reference Line | Dashed amber (`#d97706`) | Reserve floor threshold |

#### Edge Cases

1. **Reserve > Total Balance**: When portfolio drops below reserve floor, the green "Available" area disappears entirely, leaving only amber
2. **No Reserve Configured**: Fall back to single-line chart (current behavior)
3. **Reserve = 0**: Chart shows all green (everything available)

### Reserve Runway Display (DECIDED)

**Decision**: Yes, show **reserve runway** - how many years the reserve would last if the user needed to dip into it.

**Rationale**: This gives users a tangible sense of their safety margin. "Your reserve could cover 8 years of essential expenses" is more meaningful than just "$200,000 reserve".

#### Calculation

```typescript
// In src/lib/projections/reserve-runway.ts

export interface ReserveRunwayResult {
  yearsOfEssentials: number;      // How many years reserve covers essentials only
  yearsOfFullSpending: number;    // How many years reserve covers full spending
  monthsOfEssentials: number;     // More granular for smaller reserves
  scenarioDescription: string;    // Human-readable summary
}

export const calculateReserveRunway = (
  reserveAmount: number,
  annualEssentialExpenses: number,
  annualDiscretionaryExpenses: number,
  guaranteedAnnualIncome: number,  // From income floor (Epic 8)
  inflationRate: number = 0.025
): ReserveRunwayResult => {
  // Essential expenses not covered by guaranteed income
  const essentialGap = Math.max(0, annualEssentialExpenses - guaranteedAnnualIncome);
  const fullSpendingGap = essentialGap + annualDiscretionaryExpenses;

  // Simple calculation (no inflation for clarity)
  const yearsOfEssentials = essentialGap > 0
    ? reserveAmount / essentialGap
    : Infinity;  // Fully covered by income floor

  const yearsOfFullSpending = fullSpendingGap > 0
    ? reserveAmount / fullSpendingGap
    : Infinity;

  // With inflation adjustment (more accurate)
  const yearsOfEssentialsInflationAdjusted = calculateInflationAdjustedRunway(
    reserveAmount,
    essentialGap,
    inflationRate
  );

  return {
    yearsOfEssentials: Math.floor(yearsOfEssentialsInflationAdjusted),
    yearsOfFullSpending: Math.floor(yearsOfFullSpending),
    monthsOfEssentials: Math.floor(yearsOfEssentialsInflationAdjusted * 12),
    scenarioDescription: generateRunwayDescription(yearsOfEssentialsInflationAdjusted, essentialGap),
  };
};

// Account for inflation eating into reserve purchasing power
const calculateInflationAdjustedRunway = (
  reserve: number,
  annualNeed: number,
  inflationRate: number
): number => {
  if (annualNeed <= 0) return Infinity;

  let remaining = reserve;
  let years = 0;
  let currentNeed = annualNeed;

  while (remaining > 0 && years < 100) {
    remaining -= currentNeed;
    currentNeed *= (1 + inflationRate);
    years++;
  }

  return years;
};

const generateRunwayDescription = (years: number, essentialGap: number): string => {
  if (essentialGap <= 0) {
    return "Your guaranteed income covers all essential expenses";
  }
  if (years >= 30) {
    return "Reserve provides 30+ years of essential expense coverage";
  }
  if (years >= 10) {
    return `Reserve covers ~${Math.floor(years)} years of essential expenses`;
  }
  if (years >= 1) {
    return `Reserve covers ${Math.floor(years)} year${years >= 2 ? 's' : ''} of essential expenses`;
  }
  return `Reserve covers ${Math.floor(years * 12)} months of essential expenses`;
};
```

#### UI Display

Add reserve runway to the summary panel in the depletion/reserve configuration:

```tsx
// In extended DepletionTargetInput component

{reserveEnabled && (
  <div className="p-4 bg-muted rounded-lg space-y-2">
    <h4 className="font-medium text-sm">Reserve Safety Net</h4>

    <div className="grid grid-cols-2 gap-4 text-sm">
      <div>
        <p className="text-muted-foreground">Reserve Amount</p>
        <p className="font-medium">${reserveAmount.toLocaleString()}</p>
      </div>
      <div>
        <p className="text-muted-foreground">Reserve Runway</p>
        <p className="font-medium text-amber-600 dark:text-amber-400">
          {runway.yearsOfEssentials === Infinity
            ? "âˆ (income covers essentials)"
            : `${runway.yearsOfEssentials} years`
          }
        </p>
      </div>
    </div>

    <p className="text-xs text-muted-foreground">
      {runway.scenarioDescription}
    </p>

    {/* Optional: breakdown tooltip */}
    <details className="text-xs">
      <summary className="cursor-pointer text-muted-foreground hover:text-foreground">
        How is this calculated?
      </summary>
      <div className="mt-2 p-2 bg-background rounded border text-muted-foreground">
        <p>Essential expenses: ${annualEssentials.toLocaleString()}/year</p>
        <p>Guaranteed income: ${guaranteedIncome.toLocaleString()}/year</p>
        <p>Gap to cover: ${Math.max(0, annualEssentials - guaranteedIncome).toLocaleString()}/year</p>
        <p>Reserve Ã· Gap = {runway.yearsOfEssentials} years</p>
        <p className="mt-1 italic">Adjusted for {(inflationRate * 100).toFixed(1)}% annual inflation</p>
      </div>
    </details>
  </div>
)}
```

#### Add to Projection Summary

```typescript
// In ProjectionSummary type extension

export interface ProjectionSummary {
  // ... existing fields

  // Reserve runway (calculated from final state)
  reserveRunway?: {
    yearsOfEssentials: number;
    yearsOfFullSpending: number;
    description: string;
  };
}
```

#### Integration with Income Floor (Epic 8)

The reserve runway calculation naturally integrates with Epic 8's income floor:
- **Guaranteed income** (Social Security, pensions, annuities) reduces the "gap" that reserve must cover
- If income floor fully covers essentials, reserve runway = infinity (peace of mind buffer only)
- This reinforces the "permission to spend" philosophy - users see their safety layers

### Income Floor Integration (DECIDED)

**Decision**: Reserve and Income Floor are **separate concepts** that work together but don't depend on each other.

**Rationale**: This keeps the mental model clear - income floor is about guaranteed income streams, reserve is about portfolio protection. Users can have one, both, or neither.

#### Conceptual Separation

| Concept | Source | Purpose | Epic |
|---------|--------|---------|------|
| **Income Floor** | Guaranteed income (SS, pensions, annuities) | Covers essential expenses with predictable income | Epic 8 |
| **Reserve** | Portfolio allocation | Protects against sequence-of-returns risk, longevity | Epic 10 |

#### How They Interact (But Don't Depend)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SAFETY LAYERS                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 1: Income Floor (Epic 8)                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
â”‚  Guaranteed income covering essential expenses              â”‚
â”‚  â†’ "Your Social Security + pension covers 80% of essentials"â”‚
â”‚                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 2: Reserve (Epic 10)                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                              â”‚
â”‚  Portfolio floor that won't be depleted                     â”‚
â”‚  â†’ "Keep $200k in reserve for peace of mind"               â”‚
â”‚                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 3: Available Portfolio                               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                               â”‚
â”‚  Funds available for discretionary spending                 â”‚
â”‚  â†’ "You can spend $50k/year from this pool"                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Implementation Independence

```typescript
// Income floor calculation (Epic 8) - standalone
const incomeFloorAnalysis = calculateIncomeFloor(
  guaranteedIncomeStreams,
  essentialExpenses
);
// Returns: { coverageRatio, isFullyCovered, gap }

// Reserve calculation (Epic 10) - standalone
const reserveConfig = {
  type: 'percentage',
  amount: 25,  // 25% of portfolio
  purpose: ['longevity', 'peace_of_mind'],
};
// Returns: absolute reserve floor amount

// Reserve runway - OPTIONALLY uses income floor data
const reserveRunway = calculateReserveRunway(
  reserveAmount,
  essentialExpenses,
  discretionaryExpenses,
  incomeFloorAnalysis.guaranteedIncome,  // Optional enhancement
  inflationRate
);
```

#### UI: Separate But Visible Together

On the Plans page, show both as separate insight cards:

```tsx
<div className="grid grid-cols-2 gap-4">
  {/* Income Floor Card (Epic 8) */}
  <InsightCard
    title="Income Floor"
    status={incomeFloor.isFullyCovered ? 'success' : 'warning'}
    value={`${(incomeFloor.coverageRatio * 100).toFixed(0)}%`}
    description="Essential expenses covered by guaranteed income"
  />

  {/* Reserve Card (Epic 10) */}
  <InsightCard
    title="Reserve Protection"
    status={reserve.enabled ? 'active' : 'inactive'}
    value={`$${reserveAmount.toLocaleString()}`}
    description={`${reserveRunway.yearsOfEssentials} years of backup`}
  />
</div>
```

#### No Cross-Dependencies

- Income floor does NOT require reserve to be set
- Reserve does NOT require income floor to be calculated
- Reserve runway calculation CAN use income floor data for better accuracy, but defaults to 0 if not available
- Each feature can be enabled/disabled independently

## Summary: All Design Decisions

| Question | Decision |
|----------|----------|
| Reserve breach behavior | Two-stage: reduce discretionary proportionally, then essentials only |
| Chart visualization | Dual-area chart with green (available) and amber (reserve) zones |
| Reserve runway | Yes, show years of essential expense coverage |
| Income floor integration | Separate concepts, independent but complementary |
