---
date: 2026-01-25T10:00:00-08:00
researcher: Claude
git_commit: 9dcf2b1b282fd1fd76260f7094212892c0c98b0e
branch: main
repository: plan-smart
topic: "Story 10.3 Depletion Feedback Implementation Options"
tags: [research, codebase, epic-10, depletion-feedback, projection-chart, spending-calculation, implementation]
status: complete
last_updated: 2026-01-25
last_updated_by: Claude
---

# Research: Story 10.3 Depletion Feedback Implementation Options

**Date**: 2026-01-25T10:00:00-08:00
**Researcher**: Claude
**Git Commit**: 9dcf2b1b282fd1fd76260f7094212892c0c98b0e
**Branch**: main
**Repository**: plan-smart

## Research Question

What are the implementation options for Story 10.3 (Depletion Feedback), which provides users with visual feedback showing how their depletion target translates into monthly spending and portfolio trajectory?

## Summary

Story 10.3 builds on the solid foundation from Stories 10.1 (Depletion Target Input) and 10.2 (Reserve Preservation). The implementation involves:

1. **New Calculation Logic**: `calculateDepletionFeedback()` function to compute sustainable spending from depletion target
2. **Chart Enhancement**: Add depletion target marker and trajectory comparison to existing `ProjectionChart`
3. **Summary Component**: Create `DepletionFeedbackSummary` with spending breakdown and status indicators
4. **Real-Time Integration**: Wire into existing debounced recalculation pattern

**Key Finding**: All required infrastructure already exists. The projection engine already tracks reserve constraints, phase-based spending, and portfolio trajectory. This story adds a **new calculation layer** (sustainable spending) and **visualization layer** (feedback UI).

---

## Implementation Options Analysis

### Option A: Integrated Approach (Recommended)

Add depletion feedback as part of the existing projection flow, computing sustainable spending during or after projection calculation.

**Pros**:
- Single source of truth for projections
- Reuses existing caching and debouncing
- Consistent with current architecture

**Cons**:
- Slightly couples feedback to projection timing

**Implementation**:
1. Add `calculateDepletionFeedback()` to `src/lib/projections/`
2. Call from projection API route after `runProjection()`
3. Return feedback alongside projection results

### Option B: Separate Calculation Service

Create independent feedback calculation that runs in parallel with projections.

**Pros**:
- Can optimize independently
- Doesn't block projection rendering

**Cons**:
- Duplicate data fetching
- Potential inconsistency between projection and feedback

### Option C: Client-Side Calculation

Compute feedback in the browser from projection results.

**Pros**:
- Instant updates without API round-trip
- Reduces server load

**Cons**:
- Duplicates calculation logic
- Less precise (no access to full input parameters)

**Recommendation**: **Option A** - matches existing patterns and provides consistency.

---

## Detailed Implementation Plan

### 1. Core Calculation Module

#### New File: `src/lib/projections/depletion-feedback.ts`

```typescript
import { ProjectionInput, ProjectionRecord, DepletionTarget, SpendingPhaseConfig } from './types';

export interface DepletionFeedback {
  // Core sustainable spending
  sustainableMonthlySpending: number;
  sustainableAnnualSpending: number;

  // Phase-based breakdown (if phases enabled)
  phaseBreakdown?: PhaseSpendingBreakdown[];

  // Status assessment
  trajectoryStatus: 'on_track' | 'underspending' | 'overspending';
  statusMessage: string;

  // Warnings
  warningMessages: string[];

  // Projections
  projectedReserveAtTarget: number;
  projectedDepletionAge: number | null;
}

export interface PhaseSpendingBreakdown {
  phaseName: string;
  startAge: number;
  endAge: number;
  monthlySpending: number;
  annualSpending: number;
  yearsInPhase: number;
}

export function calculateDepletionFeedback(
  input: ProjectionInput,
  records: ProjectionRecord[],
  currentPlannedSpending: number
): DepletionFeedback {
  const { depletionTarget, reserveFloor, spendingPhaseConfig } = input;

  if (!depletionTarget?.enabled) {
    return createDisabledFeedback();
  }

  // Calculate target ending value
  const targetReserve = reserveFloor ?? 0;
  const currentPortfolio = input.currentSavings;
  const yearsToTarget = depletionTarget.targetAge - input.currentAge;

  // Calculate sustainable withdrawal using present value of annuity
  const realReturn = calculateRealReturn(input.expectedReturn, input.inflationRate);
  const sustainableAnnual = calculateSustainableWithdrawal(
    currentPortfolio,
    targetReserve,
    yearsToTarget,
    realReturn
  );

  // Compare with current plan
  const trajectoryStatus = assessTrajectoryStatus(
    sustainableAnnual,
    currentPlannedSpending,
    0.05 // 5% tolerance
  );

  // Calculate phase breakdown if enabled
  const phaseBreakdown = spendingPhaseConfig?.enabled
    ? calculatePhaseBreakdown(sustainableAnnual, spendingPhaseConfig, input)
    : undefined;

  // Find projected values at target age
  const targetAgeRecord = records.find(r => r.age === depletionTarget.targetAge);
  const projectedReserveAtTarget = targetAgeRecord?.balance ?? 0;

  // Generate warnings
  const warnings = generateWarnings(
    trajectoryStatus,
    currentPlannedSpending,
    sustainableAnnual,
    projectedReserveAtTarget,
    targetReserve,
    records
  );

  return {
    sustainableMonthlySpending: sustainableAnnual / 12,
    sustainableAnnualSpending: sustainableAnnual,
    phaseBreakdown,
    trajectoryStatus,
    statusMessage: generateStatusMessage(trajectoryStatus, sustainableAnnual, depletionTarget),
    warningMessages: warnings,
    projectedReserveAtTarget,
    projectedDepletionAge: findDepletionAge(records),
  };
}
```

#### Sustainable Withdrawal Formula

The calculation uses the present value of annuity formula, adjusted for real returns:

```typescript
function calculateSustainableWithdrawal(
  currentPortfolio: number,
  targetReserve: number,
  years: number,
  realReturn: number
): number {
  // Amount available for spending over the period
  const spendablePortfolio = currentPortfolio - targetReserve;

  if (spendablePortfolio <= 0 || years <= 0) {
    return 0;
  }

  // Use annuity formula: PMT = PV * [r(1+r)^n] / [(1+r)^n - 1]
  // Adjusted for beginning-of-period withdrawals

  if (realReturn === 0) {
    // Simple case: no real growth
    return spendablePortfolio / years;
  }

  const r = realReturn;
  const n = years;
  const numerator = r * Math.pow(1 + r, n);
  const denominator = Math.pow(1 + r, n) - 1;

  return spendablePortfolio * (numerator / denominator);
}

function calculateRealReturn(nominalReturn: number, inflationRate: number): number {
  return (1 + nominalReturn) / (1 + inflationRate) - 1;
}
```

### 2. Phase Breakdown Calculation

When spending phases are enabled, distribute sustainable spending across phases:

```typescript
function calculatePhaseBreakdown(
  sustainableAnnual: number,
  config: SpendingPhaseConfig,
  input: ProjectionInput
): PhaseSpendingBreakdown[] {
  const phases = config.phases;
  const retirementAge = input.retirementAge;
  const targetAge = input.depletionTarget?.targetAge ?? input.maxAge;

  // Calculate weighted average of phase multipliers
  const phaseYears: Array<{ phase: SpendingPhase; years: number }> = [];

  for (let i = 0; i < phases.length; i++) {
    const phase = phases[i];
    const startAge = Math.max(phase.startAge, retirementAge);
    const endAge = i < phases.length - 1
      ? phases[i + 1].startAge
      : targetAge;

    if (startAge < targetAge && startAge < endAge) {
      phaseYears.push({
        phase,
        years: Math.min(endAge, targetAge) - startAge,
      });
    }
  }

  // Calculate weighted multiplier
  const totalYears = phaseYears.reduce((sum, p) => sum + p.years, 0);
  const weightedMultiplier = phaseYears.reduce((sum, p) => {
    const avgMultiplier = (p.phase.essentialMultiplier + p.phase.discretionaryMultiplier) / 2;
    return sum + (avgMultiplier * p.years / totalYears);
  }, 0);

  // Base spending that, when multiplied by phase ratios, equals sustainable
  const baseSpending = sustainableAnnual / weightedMultiplier;

  // Generate breakdown
  return phaseYears.map(({ phase, years }) => {
    const avgMultiplier = (phase.essentialMultiplier + phase.discretionaryMultiplier) / 2;
    const annualSpending = baseSpending * avgMultiplier;

    return {
      phaseName: phase.name,
      startAge: phase.startAge,
      endAge: phase.startAge + years,
      monthlySpending: annualSpending / 12,
      annualSpending,
      yearsInPhase: years,
    };
  });
}
```

### 3. Chart Enhancements

#### Extend `ProjectionChart.tsx`

Add new props and annotations:

```typescript
interface ProjectionChartProps {
  records: ProjectionRecord[];
  retirementAge: number;
  currentAge: number;
  inflationRate?: number;
  shortfallAge?: number | null;
  spendingEnabled?: boolean;
  onPhaseClick?: (phaseId: string) => void;
  reserveFloor?: number;

  // NEW: Depletion feedback props
  depletionTarget?: DepletionTarget;
  depletionFeedback?: DepletionFeedback;
  showTargetTrajectory?: boolean;
}
```

#### New Annotations

**Depletion Target Point** (similar to existing ReferenceLine pattern):

```tsx
{/* Depletion Target Marker */}
{depletionTarget?.enabled && (
  <ReferenceLine
    x={targetXValue}
    stroke="hsl(var(--primary))"
    strokeDasharray="5 5"
    label={{
      value: `Target: Age ${depletionTarget.targetAge}`,
      position: 'top',
      fill: 'hsl(var(--primary))',
      fontSize: 12,
    }}
  />
)}

{/* Reserve Floor Line (already implemented in 10.2) */}
{reserveFloor && (
  <ReferenceLine
    y={displayReserveFloor}
    stroke="hsl(var(--warning))"
    strokeDasharray="3 3"
    label={{
      value: `Reserve: ${formatCurrency(reserveFloor)}`,
      position: 'right',
      fill: 'hsl(var(--warning))',
      fontSize: 10,
    }}
  />
)}
```

**Target Trajectory Line** (shows ideal path to hit depletion target):

```tsx
{/* Target Trajectory - dashed line from current to target */}
{showTargetTrajectory && targetTrajectoryData && (
  <Line
    type="monotone"
    data={targetTrajectoryData}
    dataKey="balance"
    stroke="hsl(var(--muted-foreground))"
    strokeDasharray="8 4"
    strokeWidth={1}
    dot={false}
    name="Target Trajectory"
  />
)}
```

#### Target Trajectory Calculation

```typescript
const targetTrajectoryData = useMemo(() => {
  if (!depletionTarget?.enabled || !showTargetTrajectory) return null;

  const startBalance = records[0]?.balance ?? 0;
  const endBalance = reserveFloor ?? 0;
  const startAge = currentAge;
  const endAge = depletionTarget.targetAge;

  // Generate linear interpolation points
  return records
    .filter(r => r.age >= startAge && r.age <= endAge)
    .map(r => {
      const progress = (r.age - startAge) / (endAge - startAge);
      const targetBalance = startBalance - (startBalance - endBalance) * progress;

      return {
        age: r.age,
        xValue: xAxisType === 'age' ? r.age : r.year,
        balance: targetBalance,
      };
    });
}, [records, depletionTarget, reserveFloor, currentAge, xAxisType, showTargetTrajectory]);
```

### 4. Summary Component

#### New File: `src/components/projections/DepletionFeedbackSummary.tsx`

```tsx
'use client';

import { DepletionFeedback, DepletionTarget } from '@/lib/projections/types';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { TrendingUp, TrendingDown, Minus, AlertTriangle, Check } from 'lucide-react';
import { cn } from '@/lib/utils';

interface DepletionFeedbackSummaryProps {
  feedback: DepletionFeedback;
  depletionTarget: DepletionTarget;
  currentPlannedSpending: number;
}

export function DepletionFeedbackSummary({
  feedback,
  depletionTarget,
  currentPlannedSpending,
}: DepletionFeedbackSummaryProps) {
  const { trajectoryStatus, sustainableMonthlySpending, phaseBreakdown } = feedback;

  const statusConfig = {
    on_track: {
      icon: Check,
      color: 'text-success',
      bgColor: 'bg-success/10',
      label: 'On Track',
    },
    underspending: {
      icon: TrendingDown,
      color: 'text-warning',
      bgColor: 'bg-warning/10',
      label: 'Underspending',
    },
    overspending: {
      icon: TrendingUp,
      color: 'text-destructive',
      bgColor: 'bg-destructive/10',
      label: 'Overspending',
    },
  };

  const config = statusConfig[trajectoryStatus];
  const StatusIcon = config.icon;

  const spendingDiff = sustainableMonthlySpending - (currentPlannedSpending / 12);
  const diffPercent = currentPlannedSpending > 0
    ? ((feedback.sustainableAnnualSpending - currentPlannedSpending) / currentPlannedSpending * 100)
    : 0;

  return (
    <Card>
      <CardHeader className="pb-3">
        <CardTitle className="text-lg flex items-center gap-2">
          Spending Guidance
          <span className={cn('px-2 py-0.5 rounded-full text-xs', config.bgColor, config.color)}>
            {config.label}
          </span>
        </CardTitle>
      </CardHeader>

      <CardContent className="space-y-4">
        {/* Main spending message */}
        <div className={cn('p-4 rounded-lg', config.bgColor)}>
          <p className="text-sm text-muted-foreground">
            To reach {depletionTarget.targetPercentageSpent}% depletion by age {depletionTarget.targetAge}:
          </p>
          <p className="text-2xl font-bold mt-1">
            ${feedback.sustainableMonthlySpending.toLocaleString(undefined, { maximumFractionDigits: 0 })}/month
          </p>
          <p className="text-sm text-muted-foreground mt-1">
            (${feedback.sustainableAnnualSpending.toLocaleString(undefined, { maximumFractionDigits: 0 })}/year)
          </p>
        </div>

        {/* Comparison with current plan */}
        {currentPlannedSpending > 0 && (
          <div className="flex items-center gap-2 text-sm">
            {spendingDiff > 0 ? (
              <>
                <TrendingUp className="h-4 w-4 text-success" />
                <span>
                  You can spend <span className="font-medium text-success">
                    ${Math.abs(spendingDiff).toLocaleString(undefined, { maximumFractionDigits: 0 })}/month more
                  </span> than your current plan
                </span>
              </>
            ) : spendingDiff < 0 ? (
              <>
                <TrendingDown className="h-4 w-4 text-destructive" />
                <span>
                  Your current plan is <span className="font-medium text-destructive">
                    ${Math.abs(spendingDiff).toLocaleString(undefined, { maximumFractionDigits: 0 })}/month higher
                  </span> than sustainable
                </span>
              </>
            ) : (
              <>
                <Minus className="h-4 w-4 text-muted-foreground" />
                <span>Your current plan matches sustainable spending</span>
              </>
            )}
          </div>
        )}

        {/* Phase breakdown */}
        {phaseBreakdown && phaseBreakdown.length > 0 && (
          <div className="pt-4 border-t">
            <h4 className="text-sm font-medium mb-3">Spending by Life Phase</h4>
            <div className="space-y-2">
              {phaseBreakdown.map((phase) => (
                <div
                  key={phase.phaseName}
                  className="flex justify-between items-center p-2 bg-muted/50 rounded"
                >
                  <div>
                    <span className="font-medium">{phase.phaseName}</span>
                    <span className="text-sm text-muted-foreground ml-2">
                      (Ages {phase.startAge}-{phase.endAge})
                    </span>
                  </div>
                  <span className="font-medium">
                    ${phase.monthlySpending.toLocaleString(undefined, { maximumFractionDigits: 0 })}/mo
                  </span>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Warnings */}
        {feedback.warningMessages.length > 0 && (
          <div className="space-y-2">
            {feedback.warningMessages.map((warning, i) => (
              <Alert key={i} variant="destructive" className="py-2">
                <AlertTriangle className="h-4 w-4" />
                <AlertDescription className="text-sm ml-2">
                  {warning}
                </AlertDescription>
              </Alert>
            ))}
          </div>
        )}

        {/* Reserve at target */}
        <div className="pt-4 border-t text-sm text-muted-foreground">
          <p>
            Projected balance at age {depletionTarget.targetAge}:{' '}
            <span className="font-medium text-foreground">
              ${feedback.projectedReserveAtTarget.toLocaleString(undefined, { maximumFractionDigits: 0 })}
            </span>
          </p>
        </div>
      </CardContent>
    </Card>
  );
}
```

### 5. Warning Generation

```typescript
function generateWarnings(
  status: 'on_track' | 'underspending' | 'overspending',
  currentSpending: number,
  sustainableSpending: number,
  projectedReserve: number,
  targetReserve: number,
  records: ProjectionRecord[]
): string[] {
  const warnings: string[] = [];

  // Overspending warning
  if (status === 'overspending') {
    const overagePercent = ((currentSpending - sustainableSpending) / sustainableSpending * 100).toFixed(0);
    warnings.push(
      `Current spending exceeds sustainable rate by ${overagePercent}%. ` +
      `Consider reducing to ${formatCurrency(sustainableSpending / 12)}/month.`
    );
  }

  // Underspending message (framed positively)
  if (status === 'underspending') {
    const underspendPercent = ((sustainableSpending - currentSpending) / currentSpending * 100).toFixed(0);
    warnings.push(
      `You're spending ${underspendPercent}% below your sustainable rate. ` +
      `You could enjoy more now without risking your goals!`
    );
  }

  // Reserve breach warning
  if (projectedReserve < targetReserve) {
    const shortfall = targetReserve - projectedReserve;
    warnings.push(
      `Current trajectory shows reserve shortfall of ${formatCurrency(shortfall)} at target age.`
    );
  }

  // Early depletion warning
  const depletionRecord = records.find(r => r.balance <= 0);
  if (depletionRecord) {
    warnings.push(
      `Warning: Portfolio depletes at age ${depletionRecord.age}, before reaching your target.`
    );
  }

  return warnings;
}
```

### 6. API Integration

#### Extend Projection Response

Update `src/app/api/projections/calculate/route.ts`:

```typescript
// After running projection
const projection = runProjection(builtInput);

// NEW: Calculate depletion feedback
const depletionFeedback = input.depletionTarget?.enabled
  ? calculateDepletionFeedback(
      builtInput,
      projection.records,
      builtInput.annualExpenses ?? 0
    )
  : null;

return Response.json({
  projection,
  inputs: builtInput,
  metadata,
  depletionFeedback,  // NEW
});
```

### 7. Real-Time Updates

The existing debounced recalculation pattern in `plans-client.tsx` (lines 250-300) already handles this. Changes to:
- `depletionTarget.targetPercentageSpent`
- `depletionTarget.targetAge`
- `reserve` configuration

Will trigger `refetchProjection()` which returns updated `depletionFeedback`.

---

## UI/UX Implementation Notes

### Tone and Framing (from Story Scope)

The feedback messaging should follow these principles:

| Status | Framing | Example Message |
|--------|---------|-----------------|
| On Track | Affirmation | "You're on track to meet your spending goals" |
| Underspending | Opportunity | "You could enjoy $500/month more without risking your goals" |
| Overspending | Guidance | "Consider reducing spending to stay on track" |

### Color Coding

| Status | Color | CSS Variable |
|--------|-------|--------------|
| On Track | Green | `hsl(var(--success))` |
| Underspending | Amber | `hsl(var(--warning))` |
| Overspending | Red | `hsl(var(--destructive))` |

### Layout Recommendation

Place `DepletionFeedbackSummary` component:
- In the Plans page sidebar, below `DepletionTargetInput`
- OR as a collapsible section within the main projection area

---

## Code References

### Existing Infrastructure to Build On

| File | Lines | Purpose |
|------|-------|---------|
| [engine.ts](src/lib/projections/engine.ts) | 188-263 | Reserve-constrained spending calculation |
| [engine.ts](src/lib/projections/engine.ts) | 151-178 | Phase-adjusted expense calculation |
| [ProjectionChart.tsx](src/components/projections/ProjectionChart.tsx) | 547-571 | ReferenceLine pattern for markers |
| [ProjectionChart.tsx](src/components/projections/ProjectionChart.tsx) | 573-596 | Dual-area reserve visualization |
| [depletion-target-input.tsx](src/components/depletion-target-input.tsx) | 252-281 | Reserve runway calculation pattern |
| [SpendingImpactSummary.tsx](src/components/projections/SpendingImpactSummary.tsx) | 41-65 | Metric card grid pattern |
| [IncomeFloorCard.tsx](src/components/insights/IncomeFloorCard.tsx) | 171-200 | Status-based color coding pattern |

### New Files to Create

| File | Purpose |
|------|---------|
| `src/lib/projections/depletion-feedback.ts` | Core calculation logic |
| `src/components/projections/DepletionFeedbackSummary.tsx` | Summary card component |

### Files to Modify

| File | Changes |
|------|---------|
| `src/lib/projections/types.ts` | Add `DepletionFeedback` interface |
| `src/components/projections/ProjectionChart.tsx` | Add target marker and trajectory line |
| `src/app/api/projections/calculate/route.ts` | Calculate and return feedback |
| `src/app/plans/plans-client.tsx` | Display feedback summary |

---

## Architecture Insights

### Calculation Philosophy

The depletion feedback calculation answers: "Given my depletion target, what can I sustainably spend?"

This is the **inverse** of the projection engine's question: "Given my spending, when do I deplete?"

Both are needed:
- Projection shows actual trajectory based on current plan
- Feedback shows what spending would achieve the target

### Integration with Existing Features

| Feature | Integration Point |
|---------|-------------------|
| Spending Phases (Epic 9) | Distribute sustainable spending across phase multipliers |
| Reserve Preservation (10.2) | Reserve floor defines ending target for calculation |
| Income Floor (Epic 8) | Could enhance by showing gap guaranteed income covers |

### Separation of Concerns

```
┌────────────────────────────────────────────────────────┐
│  Projection Engine (engine.ts)                          │
│  - Calculates actual trajectory from current spending   │
│  - Enforces reserve constraints                         │
│  - Tracks phase transitions                             │
└───────────────────────┬────────────────────────────────┘
                        │
                        ▼
┌────────────────────────────────────────────────────────┐
│  Depletion Feedback (NEW)                               │
│  - Computes sustainable spending for target             │
│  - Compares to current plan                             │
│  - Generates guidance messages                          │
└───────────────────────┬────────────────────────────────┘
                        │
                        ▼
┌────────────────────────────────────────────────────────┐
│  UI Components                                          │
│  - DepletionFeedbackSummary (spending guidance)        │
│  - ProjectionChart (trajectory visualization)          │
│  - DepletionTargetInput (configuration)                │
└────────────────────────────────────────────────────────┘
```

---

## Historical Context (from thoughts/)

### Story Dependencies

- **Story 10.1** ([2026-01-22-ENG-10.1-implementation-recommendation.md](2026-01-22-ENG-10.1-implementation-recommendation.md)): Established `DepletionTarget` interface and input component
- **Story 10.2** ([2026-01-23-ENG-10.2-reserve-preservation-implementation.md](2026-01-23-ENG-10.2-reserve-preservation-implementation.md)): Added reserve floor, dual-area chart, and constraint logic

### Epic 9 Foundation

- **Story 9.1** ([2026-01-19-ENG-9.1-phase-based-spending-integration.md](2026-01-19-ENG-9.1-phase-based-spending-integration.md)): Spending phases with multipliers
- **Story 9.3** ([2026-01-22-ENG-9.3-projection-chart-implementation.md](2026-01-22-ENG-9.3-projection-chart-implementation.md)): Chart enhancements and spending timeline

---

## Implementation Phases

### Phase 1: Core Calculation (Day 1)
1. Create `src/lib/projections/depletion-feedback.ts`
2. Implement `calculateDepletionFeedback()` function
3. Add `DepletionFeedback` interface to types
4. Unit tests for sustainable withdrawal calculation

### Phase 2: API Integration (Day 1-2)
1. Call feedback calculation from projection route
2. Return feedback in API response
3. Update response type definitions
4. Integration tests

### Phase 3: Summary Component (Day 2)
1. Create `DepletionFeedbackSummary` component
2. Implement status badges and spending display
3. Add phase breakdown section
4. Add warning messages

### Phase 4: Chart Enhancements (Day 3)
1. Add depletion target vertical marker
2. Add optional target trajectory line
3. Update tooltip to show target comparison
4. Update legend

### Phase 5: Integration & Polish (Day 3-4)
1. Wire up to Plans page
2. Handle edge cases (no target, phases disabled)
3. Add toggle for trajectory visibility
4. Accessibility review

---

## Open Questions

1. **Target Trajectory Line**: Should the target trajectory be shown by default, or require a toggle? Could clutter the chart.

2. **Phase Breakdown Accuracy**: The phase breakdown distributes sustainable spending proportionally to phase multipliers. Should it instead solve for the exact amount per phase that achieves the target?

3. **Income Integration**: Should feedback calculation account for guaranteed income (from Epic 8) when computing sustainable withdrawal?

4. **Comparison Baseline**: What "current planned spending" should we compare against - the phase-adjusted amount, or a flat annual rate?

---

## Related Research

- [2026-01-22-ENG-10.1-implementation-recommendation.md](2026-01-22-ENG-10.1-implementation-recommendation.md) - Depletion target input patterns
- [2026-01-23-ENG-10.2-reserve-preservation-implementation.md](2026-01-23-ENG-10.2-reserve-preservation-implementation.md) - Reserve configuration and chart visualization
- [2026-01-22-ENG-9.3-projection-chart-implementation.md](2026-01-22-ENG-9.3-projection-chart-implementation.md) - Chart implementation patterns
- [2026-01-19-ENG-9.1-phase-based-spending-integration.md](2026-01-19-ENG-9.1-phase-based-spending-integration.md) - Spending phase architecture
